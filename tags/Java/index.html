<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: Java - Erick Navarro</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Erick Navarro"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Erick Navarro"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Erick Navarro"><meta property="og:url" content="https://ericknavarro.github.io/"><meta property="og:site_name" content="Erick Navarro"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://ericknavarro.github.io/img/og_image.png"><meta property="article:author" content="Erick Navarro"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ericknavarro.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ericknavarro.github.io"},"headline":"Erick Navarro","image":["https://ericknavarro.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Erick Navarro"},"publisher":{"@type":"Organization","name":"Erick Navarro","logo":{"@type":"ImageObject","url":"https://ericknavarro.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-145306707-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-145306707-1');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Erick Navarro" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Connect on LinkedIn" href="https://www.linkedin.com/in/ericknd/"><i class="fab fa-linkedin"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags/">Tags</a></li><li class="is-active"><a href="#" aria-current="page">Java</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-10T22:14:34.000Z" title="2/10/2020, 4:14:34 PM">2020-02-10</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/10/23-Mi-primer-proyecto-utilizando-JavaCC/">Mi primer proyecto utilizando JavaCC</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presenta como salida el resultado de dichas expresiones.</p>
<p>Las tecnologías para utilizar son:</p>
<ul>
<li><strong>JavaCC</strong>: Generador de analizadores léxicos y sintácticos.</li>
<li><strong>Windows 10</strong>: Sistema operativo.</li>
<li><strong>Netbeans 8.2</strong>: IDE (entorno de desarrollo integrado)</li>
<li><strong>Java 8</strong>: Lenguaje de programación.</li>
</ul>
<p>El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC">Mi primer proyecto utilizando JavaCC</a></li>
</ul>
<h3 id="JavaCC"><a href="#JavaCC" class="headerlink" title="JavaCC"></a><strong>JavaCC</strong></h3><p><a target="_blank" rel="noopener" href="https://javacc.github.io/javacc/">Java Compiler Compiler</a> es un generador de analizadores para utilizar en java. Este generador es una herramienta que lee la especificación gramatical y la convierte en un programa de java que puede reconocer coincidencias con la gramática. Además del generador de analizadores en sí, JavaCC proporciona otras capacidades estándar relacionadas con la generación de analizadores, como la construcción de árboles (a través de una herramienta llamada JJTree incluida con JavaCC), acciones y depuración. Todo lo que se necesita para ejecutar un analizador JavaCC, una vez generado, es Java Runtime Environment (JRE).</p>
<h3 id="Caracteristicas"><a href="#Caracteristicas" class="headerlink" title="Características"></a><strong>Características</strong></h3><ul>
<li>JavaCC utiliza un analizador descendente lo que permite el uso de gramáticas más generales.</li>
<li>Por defecto JavaCC genera un analizador LL(1), aunque JavaCC ofrece capacidades de anticipación sintáctica para resolver ambigüedades.</li>
<li>JavaCC permite la utilización de BNF Extendido, o lo que vendría siendo utilizar expresiones regulares tanto en la parte léxica como gramatical.</li>
<li>JavaCC permite la utilización de estados para manejar de mejor forma las expresiones regulares.</li>
<li>Para más información visitar la página oficial de <a target="_blank" rel="noopener" href="https://javacc.github.io/javacc/">JavaCC</a>.</li>
</ul>
<h3 id="Prerrequisitos"><a href="#Prerrequisitos" class="headerlink" title="Prerrequisitos"></a><strong>Prerrequisitos</strong></h3><p>Para este este ejemplo necesitamos las siguientes herramientas</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/downloads/index.html">Java Development Kit (JDK)</a></li>
<li><a target="_blank" rel="noopener" href="https://netbeans.apache.org/download/index.html">NetBeans</a> (o cualquier IDE de nuestro agrado)</li>
<li><a target="_blank" rel="noopener" href="https://javacc.github.io/javacc/">JavaCC</a></li>
</ul>
<h3 id="Agregar-jdk-a-las-variables-de-entorno"><a href="#Agregar-jdk-a-las-variables-de-entorno" class="headerlink" title="Agregar jdk a las variables de entorno"></a><strong>Agregar jdk a las variables de entorno</strong></h3><p>Debemos asegurarnos de que la carpeta bin del JDK haya sido agregada a nuestra variable de entorno Path, para ello vamos a la configuración de dicha variable de entorno </p>
<ul>
<li>Clic derecho en Este equipo </li>
<li>Propiedades</li>
</ul>


<ul>
<li>Configuración avanzada del sistema </li>
<li>Variables de entorno </li>
<li>Variable Path </li>
<li>Editar</li>
</ul>


<p>y si no existe agregamos la ruta a la carpeta bin del JDK, que en mi caso es: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_211\bin</span><br></pre></td></tr></table></figure>

<h3 id="Descarga-e-instalacion-de-JavaCC"><a href="#Descarga-e-instalacion-de-JavaCC" class="headerlink" title="Descarga e instalación de JavaCC"></a><strong>Descarga e instalación de JavaCC</strong></h3><p>Nos dirigimos a la <a target="_blank" rel="noopener" href="https://javacc.github.io/javacc/">página oficial de JavaCC</a>, al ingresar hacemos clic sobre el botón de Download[Version].zip    </p>


<p>Una vez descargado el archivo, lo extraemos y podremos ver el siguiente contenido:</p>


<p>El archivo que nos interesa es javacc.jar que se encuentra en la carpeta bootstrap:</p>


<p>Por conveniencia, vamos a trasladar el archivo .jar a la carpeta C:&#x2F;javacc, sin embargo, podría guardarse en otra ubicación.</p>

<p>Más adelante le daremos uso a nuestro archivo javacc.jar.</p>
<h3 id="Crear-el-proyecto-utilizando-NetBeans"><a href="#Crear-el-proyecto-utilizando-NetBeans" class="headerlink" title="Crear el proyecto utilizando NetBeans"></a><strong>Crear el proyecto utilizando NetBeans</strong></h3><p>Como mencionamos vamos a utilizar NetBeans, sin embargo podría usarse cualquier otro IDE. Vamos a mostrar la creación del proyecto y su estructura.</p>
<ul>
<li>Seleccionamos la opción de nuevo proyecto.</li>
<li>Ahora seleccionamos el tipo de proyecto, en este caso Java Application y damos clic en siguiente.</li>
</ul>


<ul>
<li>Por último, agregamos el nombre del proyecto y finalizamos.</li>
</ul>


<ul>
<li>Vemos el resultado de la creación del proyecto.</li>
</ul>


<ul>
<li>A continuación, creamos un nuevo paquete llamado Analizador, produciendo el siguiente resultado.</li>
</ul>


<ul>
<li><p>Dentro de este paquete vamos a crear un nuevo archivo llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/Gramatica.jj">Gramatica.jj</a>, este archivo contendrá la gramática para reconocer el lenguaje que vamos a realizar.</p>
</li>
<li><p>Para facilitar la compilación de la gramática vamos a crear un archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/compilarGramatica.bat">compilarGramatica.bat</a>, con el siguiente contenido, siempre en el paquete Analizador.</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> C:\javacc\javacc.jar javacc Gramatica.jj</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>Lo que indican estas sentencias:</p>
<ul>
<li>Agregar el archivo jar al classpath mediante el argumento -cp (classpath) – -cp C:\javacc\javacc.jar (o la ubicación de nuestro archivo javacc.jar)</li>
<li>Ejecutar java – java</li>
<li>Pasar el main del archivo jar – javacc</li>
<li>Pasar la gramática a compilar – Gramatica.jj</li>
<li>Evitar que se cierre la ventana de comando para ver el resultado – pause</li>
<li><em>Nota</em>: utilizamos el argumento classpath para indicarle a java donde debe buscar los paquetes y clases a ejecutar, mas información en el siguiente <a target="_blank" rel="noopener" href="https://howtodoinjava.com/java/basics/java-classpath/">link</a>.</li>
</ul>
<h3 id="Construccion-del-lenguaje-en-JavaCC"><a href="#Construccion-del-lenguaje-en-JavaCC" class="headerlink" title="Construcción del lenguaje en JavaCC"></a><strong>Construcción del lenguaje en JavaCC</strong></h3><p>Luego de esta introducción vamos a construir una programa que reconozca un lenguaje compuesto por una lista de instrucciones <strong>Evaluar</strong> que reciben una expresión aritmética para ser evaluada, por ejemplo:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluar [3*4-2*9]</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-de-la-estructura-del-archivo-Gramatica-jj"><a href="#Explicacion-de-la-estructura-del-archivo-Gramatica-jj" class="headerlink" title="Explicación de la estructura del archivo Gramatica.jj"></a><strong>Explicación de la estructura del archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/Gramatica.jj">Gramatica.jj</a></strong></h3><ul>
<li><p><strong>Sección de opciones</strong>: Esta sección es opcional, el área de opciones permite especificar algunas directrices que ayuden a JavaCC a generar analizadores léxico-sintácticos más eficientes y adaptados a las necesidades concretas del desarrollador. Existen muchas, si quieres conocerlas mejor puedes verificar la página 132 del libro <a target="_blank" rel="noopener" href="http://www.lcc.uma.es/~galvez/ftp/libros/Compiladores.pdf">Compiladores, de Sergio Gálvez Rojas Y Miguel Ángel Mora Mata</a>. En este caso particular utilizamos solamente dos:</p>
<ul>
<li><strong>Ignore_Case</strong> &#x3D; true, para no hacer distinción entre mayúsculas y minúsculas.</li>
<li><strong>Static</strong> &#x3D; false, para que los métodos que genere la compilación no sean estáticos.</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">IGNORE_CASE = <span class="literal">true</span>;</span><br><span class="line">STATIC = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Clausulas PARSER_BEGIN – PARSER_END</strong>: Sirven para indicarle a JavaCC el nombre de nuestra clase principal, así como para englobar tanto a esta como a cualquier otra que se quiera incluir de apoyo. En este ejemplo no definimos ningun método main, solo una clase llamada gramática para nuestro parser, por supuesto que esta clase gramática es la que debemos utilizar para invocar a nuestro parser, y el main lo incluimos fuera de este para tener un código más claro.</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PARSER_BEGIN(Gramatica)</span><br><span class="line">/** Analizador de expresiones aritmeticas sencillas. */</span><br><span class="line">package Analizador; </span><br><span class="line">public class Gramatica &#123;</span><br><span class="line">&#125;</span><br><span class="line">PARSER_END(Gramatica)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Sección para definición léxica</strong>: Esta sección contendrá los tokens permitidos por nuestro lenguaje, contiene distintas clausulas, pero las que utilizamos son:</p>
<ul>
<li><strong>Token</strong>: Constituyen los tokens que nuestro analizador va a reconocer, generalmente aquí se incluyen todos los terminales de nuestro lenguaje, aunque también se pueden utilizar tokens en la definición sintáctica sin haberlos definido en esta sección.</li>
<li><strong>Skip</strong>: En esta sección se incluyen los tokens que se van a ignorar durante el análisis, por ejemplo, los espacios o saltos de línea.</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/** Lexico */</span><br><span class="line">SKIP : &#123;</span><br><span class="line">	<span class="string">&quot; &quot;</span></span><br><span class="line">	| <span class="string">&quot;\t&quot;</span></span><br><span class="line">	| <span class="string">&quot;\r&quot;</span></span><br><span class="line">	| <span class="string">&quot;\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TOKEN : &#123;</span><br><span class="line">	&lt;NUMERO: ([<span class="string">&quot;0&quot;</span>-<span class="string">&quot;9&quot;</span>])+&gt;</span><br><span class="line">	| &lt;DECIMAL: ([<span class="string">&quot;0&quot;</span>-<span class="string">&quot;9&quot;</span>])+<span class="string">&quot;.&quot;</span>([<span class="string">&quot;0&quot;</span>-<span class="string">&quot;9&quot;</span>])+&gt;</span><br><span class="line">	| &lt;EVALUAR: <span class="string">&quot;Evaluar&quot;</span>&gt;</span><br><span class="line">	| &lt;PCOMA: <span class="string">&quot;;&quot;</span>&gt;</span><br><span class="line">	| &lt;PARENI: <span class="string">&quot;(&quot;</span>&gt;</span><br><span class="line">	| &lt;PAREND: <span class="string">&quot;)&quot;</span>&gt;</span><br><span class="line">	| &lt;CORI: <span class="string">&quot;[&quot;</span>&gt;</span><br><span class="line">	| &lt;CORD: <span class="string">&quot;]&quot;</span>&gt;</span><br><span class="line">	| &lt;MAS: <span class="string">&quot;+&quot;</span>&gt;</span><br><span class="line">	| &lt;MENOS: <span class="string">&quot;-&quot;</span>&gt;</span><br><span class="line">	| &lt;POR: <span class="string">&quot;*&quot;</span>&gt;</span><br><span class="line">	| &lt;DIV: <span class="string">&quot;/&quot;</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line">/** Fin Lexico */</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Sección para definición sintáctica</strong>: Aquí vamos a definir las producciones para nuestro analizador, estas están definidas como funciones. A continuación explicamos la estructura:</p>
<ul>
<li>Como buena práctica es recomendable agregar en un comentario la producción en formato BNF para que sea más fácil entender la producción actual, ya que las reglas sintácticas en JavaCC pueden ser un poco confusas. </li>
<li>La definición de un método incluye:</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TIPO&gt; &lt;NOMBRE&gt; () : </span><br><span class="line">&#123;Sección para código de java, generalmente para declaraciones&#125;</span><br><span class="line">&#123;Producciones, estas pueden incluir notación de expresiones regulares&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Si quisiéramos invocar a otra producción, agregamos su llamada a método y para obtener su valor lo hacemos de la siguiente manera</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/** Instruccion -&gt; evaluar [ Expresion ]; */</span><br><span class="line">void Instruccion() :</span><br><span class="line">&#123;double e;&#125;</span><br><span class="line">&#123;</span><br><span class="line">&lt;EVALUAR&gt; &lt;CORI&gt; e=Expresion() &lt;CORD&gt; &lt;PCOMA&gt; &#123;System.out.println(<span class="string">&quot;El valor de la expresion es: &quot;</span>+e);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>En tal caso necesitásemos obtener el valor de un terminal, debemos utilizar el atributo image, ya que cada terminal es un objeto de tipo Token, para obtenerlo hacemos lo siguiente</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">double Primitivo() :</span><br><span class="line">&#123;double e;&#125;</span><br><span class="line">&#123;</span><br><span class="line">	&lt;NUMERO&gt; &#123;<span class="built_in">return</span> Double.parseDouble(token.image);&#125;</span><br><span class="line">	|</span><br><span class="line">	&lt;DECIMAL&gt; &#123;<span class="built_in">return</span> Double.parseDouble(token.image);&#125;</span><br><span class="line">	|</span><br><span class="line">	&lt;PARENI&gt; e=Expresion() &lt;PAREND&gt; &#123;<span class="built_in">return</span> e;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Algo a tomar en cuenta es que, podemos declarar variables de tipo Token y asignarlas al terminal, esto es por si tuviéramos varios terminales en una misma producción y así sepamos diferenciar cada uno.</li>
</ul>
</li>
</ul>
<h3 id="Compilacion-de-la-gramatica"><a href="#Compilacion-de-la-gramatica" class="headerlink" title="Compilación de la gramática"></a><strong>Compilación de la gramática</strong></h3><p>Una vez finalizado nuestro archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/Gramatica.jj">Gramatica.jj</a>, vamos a compilar este para generar los archivos necesarios para su ejecución, vamos a utilizar el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/compilarGramatica.bat">compilarGramatica.bat</a> creado al inicio. Al ejecutar el archivo veremos lo siguiente:</p>


<p>Como resultado de esto, en nuestro paquete analizador se crearon los siguientes archivos</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/Gramatica.java">Gramatica.java</a></strong>: Este archivo contiene las funciones de cada no terminal de la sección sintáctica </li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/GramaticaConstants.java">GramaticaConstanst.java</a></strong>: Esta interfaz contiene las constantes de tipo entero que identifican a cada token de nuestro lenguaje y son asignadas a las variables kind.</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/GramaticaTokenManager.java">GramaticaTokenManager.java</a></strong>: Se encarga de reconocer los tokens durante el análisis léxico.</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/ParseException.java">ParseException.java</a></strong>: Se utiliza para lanzar los errores durante el análisis sintáctico.</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/TokenMgrError.java">TokenMgrError.java</a></strong>: Se encarga de manejar los errores léxicos.</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/Token.java">Token.java</a></strong>: Representa cada token definido en nuestra sección léxica.</li>
</ul>
<h3 id="Clase-Principal"><a href="#Clase-Principal" class="headerlink" title="Clase Principal"></a><strong>Clase Principal</strong></h3><p>Por último, vamos a invocar a nuestro parser en el <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/proyectojavacc/ProyectoJavaCC.java">método main</a>, para utilizar nuestro parser basta con crear la clase Gramatica y pasar por parámetro nuestro archivo de entrada, luego de crear la instancia invocamos al método inicial que en nuestro caso sería el método analizar.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package proyectojavacc;</span><br><span class="line"></span><br><span class="line">import Analizador.Gramatica;</span><br><span class="line">import Analizador.ParseException;</span><br><span class="line">import Analizador.TokenMgrError;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.util.logging.Level;</span><br><span class="line">import java.util.logging.Logger;</span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @author Pavel</span><br><span class="line"> */</span><br><span class="line">public class ProyectoJavaCC &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param args the <span class="built_in">command</span> line arguments</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Gramatica parser = new Gramatica(new BufferedReader(new FileReader(<span class="string">&quot;./entrada.txt&quot;</span>)));</span><br><span class="line">            parser.Analizar();</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            Logger.getLogger(ProyectoJavaCC.class.getName()).<span class="built_in">log</span>(Level.SEVERE, <span class="string">&quot;Error al intentar leer el archivo.&quot;</span>, e);</span><br><span class="line">        &#125; catch(TokenMgrError e)&#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ejecucion-del-archivo-de-entrada"><a href="#Ejecucion-del-archivo-de-entrada" class="headerlink" title="Ejecución del archivo de entrada"></a><strong>Ejecución del archivo de entrada</strong></h3><p>El <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/entrada.txt">archivo</a> que vamos a utilizar debe encontrarse dentro de la carpeta de nuestro proyecto.</p>
<p>Y su contenido es el siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1+1];</span><br><span class="line">Evaluar[1+1*2];</span><br><span class="line">Evaluar[-(1+1*6/3-5+7)];</span><br><span class="line">Evaluar[-(1+1*6/3-5+1*-2)];</span><br><span class="line">Evaluar[-(1+1)];</span><br></pre></td></tr></table></figure>

<p>Ejecutamos nuestro programa y vemos la siguiente salida:</p>



<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/PvasquezF">Pavel Vásquez</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas"></a><strong>Fuentes consultadas</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.lcc.uma.es/~galvez/ftp/libros/Compiladores.pdf">Java a tope: Compiladores</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/javacc/javacc">JavaCC: Repositorio</a></li>
<li><a target="_blank" rel="noopener" href="https://www.javadoc.io/doc/net.java.dev.javacc/javacc">JavaCC: Documentación</a></li>
<li><a target="_blank" rel="noopener" href="https://howtodoinjava.com/java/basics/java-classpath/">Java: Classpath</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:40.000Z" title="4/26/2019, 3:21:40 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Data-Structures/">Data Structures</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/09-Graficar-arboles-binarios-de-busqueda-con-Graphviz-y-Java/">Graficar árboles binarios de búsqueda con Graphviz y Java</a></p><div class="content"><p>En este tutorial se desarrolla un ejemplo sencillo en el que se grafica un árbol binario de búsqueda con ayuda de la herramienta Graphviz. Es importante mencionar que para que ejemplo funcione correctamente debe estar instalado Graphviz. Este proyecto se desarrolló utilizando Ubuntu 14.04 y Netbeans 8.0. El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ABBGraphviz">Graficar árboles binarios de búsqueda con Graphviz y Java</a>.</p>
<p>Todo el código dentro del proyecto está documentado con comentarios que contienen explicaciones sobre su funcionamiento.</p>
<h3 id="Instalacion-de-Graphviz"><a href="#Instalacion-de-Graphviz" class="headerlink" title="Instalación de Graphviz"></a><strong>Instalación de Graphviz</strong></h3><p>Lo primero que haremos será instalar Graphviz, en caso de que no lo hayamos instalado todavía, para ello abrimos una terminal, en Ubuntu puede hacerse con la combinación de teclas Ctrl+Alt+t o en Aplicaciones → Accesorios → Terminal, una vez abierta la terminal ingresamos el comando “sudo apt-get install graphviz”, autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado Graphviz.</p>


<h3 id="Funcionamiento-del-proyecto"><a href="#Funcionamiento-del-proyecto" class="headerlink" title="Funcionamiento del proyecto"></a><strong>Funcionamiento del proyecto</strong></h3><p>El proyecto cuenta con la clase <em>ArbolBinarioBusqueda</em>, en el método principal de la aplicación, se instancian dos objetos de esta clase, es decir, dos árboles binarios de búsqueda, el primero almacena únicamente texto y el segundo únicamente números. El código de la clase principal de la aplicación es el siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Ejemplo desarrollado por Erick Navarro</span><br><span class="line"> * GitHub Page: ericknavarro.github.io</span><br><span class="line"> * Octubre - 2015</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">package abbgraphviz;</span><br><span class="line"></span><br><span class="line">import abb.ArbolBinarioBusqueda;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Clase principal de la aplicación.</span><br><span class="line"> * @author Erick Navarro</span><br><span class="line"> */</span><br><span class="line">public class ABBGraphviz &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Método principal de la aplicación</span><br><span class="line">     * @param args los argumentos de la línea de comando</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Creamos un árbol cuyos nodos contendrán solamente texto</span><br><span class="line">        ArbolBinarioBusqueda arbol_texto=new ArbolBinarioBusqueda();</span><br><span class="line">        //Llenamos con información el árbol</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Juan&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Pedro&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;María&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Roberto&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Teodoro&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Manuel&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Diego&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Alejandro&quot;</span>);</span><br><span class="line">        //Graficamos el árbol generando la imagen arbol_texto.jpg</span><br><span class="line">        arbol_texto.graficar(<span class="string">&quot;arbol_texto.jpg&quot;</span>);</span><br><span class="line">        //Imprimimos el contenido del árbol ordenado</span><br><span class="line">        arbol_texto.inorden();</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        //Creamos un árbol cuyos nodos contendrán solamente numeros</span><br><span class="line">        ArbolBinarioBusqueda arbol_numeros=new ArbolBinarioBusqueda();</span><br><span class="line">        //Llenamos con información el árbol</span><br><span class="line">        arbol_numeros.insertar(12);</span><br><span class="line">        arbol_numeros.insertar(5);</span><br><span class="line">        arbol_numeros.insertar(26);</span><br><span class="line">        arbol_numeros.insertar(33);</span><br><span class="line">        arbol_numeros.insertar(59);</span><br><span class="line">        arbol_numeros.insertar(27);</span><br><span class="line">        arbol_numeros.insertar(15);      </span><br><span class="line">        //Graficamos el árbol generando la imagen arbol_numeros.jpg</span><br><span class="line">        arbol_numeros.graficar(<span class="string">&quot;arbol_numeros.jpg&quot;</span>);</span><br><span class="line">        //Imprimimos el contenido del árbol ordenado</span><br><span class="line">        arbol_numeros.inorden();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Al ser ejecutada la aplicación, se generan dos imagenes, una para cada árbol la primera *arbol_texto.jpg *corresponde al árbol que solo almacena texto en sus nodos.</p>


<p>La segunda <em>arbol_numeros.jpg</em> corresponde al árbol que solo almacena números.</p>


<p>En la consola se verán los elementos de ambos árboles impresos en orden, esto se logra haciendo un recorrido <em>enorden</em> de los arboles binarios de búsqueda.</p>


<h3 id="Arbol-binario-de-busqueda"><a href="#Arbol-binario-de-busqueda" class="headerlink" title="Árbol binario de búsqueda"></a><strong>Árbol binario de búsqueda</strong></h3><p>En un árbol binario, todos los nodos tienen como máximo dos hijos.</p>
<p>“Un <strong>árbol binario de búsqueda</strong> es aquel que dado un nodo, todos los datos del subárbol izquierdo son menores que los datos de ese nodo, mientras que todos los datos del subárbol derecho son mayores que sus propios datos.”</p>
<p><em>Fuente: Programación en Java 2. Luis Joyanes Aguilar, Ignacio Zahonero Martínez.</em></p>
<p>En este árbol únicamente se desarrolla el método para insertar nodos, porque el objetivo de la aplicación es únicamente graficar el árbol, adicionalmente, podrían desarrollarse métodos para eliminar nodos, buscar nodos, vaciar el árbol, calcular la profundidad del árbol, etc. El único recorrido que se hace del árbol es el <em>enorden</em>, que muestra los nodos del árbol ordenados, pero existen otros recorridos que también podrían implementarse como el recorrido <em>preorden</em>, <em>postorden</em> o el recorrido por anchura.</p>
<h3 id="Interfaz-Comparable-El-secreto-tras-la-flexibilidad-de-este-arbol"><a href="#Interfaz-Comparable-El-secreto-tras-la-flexibilidad-de-este-arbol" class="headerlink" title="Interfaz Comparable: El secreto tras la flexibilidad de este árbol"></a><strong>Interfaz Comparable: El secreto tras la flexibilidad de este árbol</strong></h3><p>La razón por la cual este árbol puede utilizarse para almacenar cadenas o bien para almacenar números es la interfaz <em>Comparable.</em> Lo que almacena el nodo es la instancia de una clase que implementa la interfaz <em>Comparable</em>, por supuesto que todos los nodos tienen que poder compararse satisfactoriamente, por ejemplo no se podrían almacenar números enteros y también cadenas de caracteres en un mismo árbol, ya que no podrían comparase satisfactoriamente porque se daría un problema de tipos. Pero si todos los nodos almacenan números, el árbol funciona sin problemas, al igual cuando todos los nodos almacenan cadenas.</p>
<p>Si deseáramos almacenar otro tipo de información podríamos programar una clase que contenga los atributos que deseamos y que implemente la interfaz <em>Comparable</em>, entonces sin modificar el árbol podríamos almacenar esta información.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Programación en Java 2. Algoritmos, estructuras de datos y programación orientada a objetos. Luis Joyanes Aguilar, Ignacio Zahonero Martínez.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:38.000Z" title="4/26/2019, 3:21:38 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Data-Structures/">Data Structures</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/08-Graficar-arboles-AVL-con-Graphviz-y-Java/">Graficar árboles AVL con Graphviz y Java</a></p><div class="content"><p>En este tutorial se desarrolla un ejemplo sencillo en el que se grafica un árbol AVL con ayuda de la herramienta Graphviz. Es importante mencionar que para que ejemplo funcione correctamente debe estar instalado Graphviz. Este proyecto se desarrolló utilizando Ubuntu 14.04 y Netbeans 8.0. El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/AVLGraphviz">Graficar árboles AVL con Graphviz y Java</a>.</p>
<p>Todo el código dentro del proyecto está documentado con comentarios que contienen explicaciones sobre su funcionamiento.</p>
<h3 id="Instalacion-de-Graphviz"><a href="#Instalacion-de-Graphviz" class="headerlink" title="Instalación de Graphviz"></a><strong>Instalación de Graphviz</strong></h3><p>Lo primero que haremos será instalar Graphviz, en caso de que no lo hayamos instalado todavía, para ello abrimos una terminal, en Ubuntu puede hacerse con la combinación de teclas Ctrl+Alt+t o en Aplicaciones → Accesorios → Terminal, una vez abierta la terminal ingresamos el comando “sudo apt-get install graphviz”, autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado Graphviz.</p>


<h3 id="Funcionamiento-del-proyecto"><a href="#Funcionamiento-del-proyecto" class="headerlink" title="Funcionamiento del proyecto"></a><strong>Funcionamiento del proyecto</strong></h3><p>El proyecto cuenta con la clase ArbolAVL, en el método principal de la aplicación, se instancian dos objetos de esta clase, es decir, dos árboles AVL, el primero almacena únicamente texto y el segundo únicamente números. El código de la clase principal de la aplicación es el siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Ejemplo desarrollado por Erick Navarro</span><br><span class="line"> * GitHub Page: ericknavarro.github.io</span><br><span class="line"> * Octubre - 2015</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">package avlgraphviz;</span><br><span class="line"></span><br><span class="line">import avl.ArbolAVL;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Clase principal de la aplicación.</span><br><span class="line"> * @author Erick Navarro</span><br><span class="line"> */</span><br><span class="line">public class AVLGraphviz &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Método principal de la aplicación</span><br><span class="line">     * @param args los argumentos de la línea de comando.</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Creamos un árbol cuyos nodos contendrán solamente texto</span><br><span class="line">        ArbolAVL arbol_texto=new ArbolAVL();</span><br><span class="line">        //Llenamos con información el árbol</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Juan&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Pedro&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;María&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Roberto&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Teodoro&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Manuel&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Diego&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Alejandro&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Margarita&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Luis&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Hernán&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Jaime&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Ana&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Francisco&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Andrea&quot;</span>);</span><br><span class="line">        //Graficamos el árbol generando la imagen arbol_texto.jpg</span><br><span class="line">        arbol_texto.graficar(<span class="string">&quot;arbol_texto.jpg&quot;</span>);</span><br><span class="line">        //Imprimimos el contenido del árbol ordenado</span><br><span class="line">        arbol_texto.inorden();</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        //Creamos un árbol cuyos nodos contendrán solamente numeros</span><br><span class="line">        ArbolAVL arbol_numeros=new ArbolAVL();</span><br><span class="line">        //Llenamos con información el árbol</span><br><span class="line">        arbol_numeros.insertar(12);</span><br><span class="line">        arbol_numeros.insertar(5);</span><br><span class="line">        arbol_numeros.insertar(26);</span><br><span class="line">        arbol_numeros.insertar(33);</span><br><span class="line">        arbol_numeros.insertar(59);</span><br><span class="line">        arbol_numeros.insertar(27);</span><br><span class="line">        arbol_numeros.insertar(15);      </span><br><span class="line">        arbol_numeros.insertar(47);</span><br><span class="line">        arbol_numeros.insertar(74);</span><br><span class="line">        arbol_numeros.insertar(84);</span><br><span class="line">        arbol_numeros.insertar(88);</span><br><span class="line">        arbol_numeros.insertar(90);</span><br><span class="line">        arbol_numeros.insertar(124);</span><br><span class="line">        arbol_numeros.insertar(612);</span><br><span class="line">        //Graficamos el árbol generando la imagen arbol_numeros.jpg</span><br><span class="line">        arbol_numeros.graficar(<span class="string">&quot;arbol_numeros.jpg&quot;</span>);</span><br><span class="line">        //Imprimimos el contenido del árbol ordenado</span><br><span class="line">        arbol_numeros.inorden();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Al ser ejecutada la aplicación, se generan dos imagenes, una para cada árbol la primera arbol_texto.jpg corresponde al árbol que solo almacena texto en sus nodos.</p>


<p>La segunda arbol_numeros.jpg corresponde al árbol que solo almacena números.</p>


<p>En la consola se verán los elementos de ambos árboles impresos en orden, esto se logra haciendo un recorrido enorden de los arboles AVL.</p>
<h3 id="Arbol-AVL"><a href="#Arbol-AVL" class="headerlink" title="Árbol AVL"></a><strong>Árbol AVL</strong></h3><p>El árbol AVL es un árbol binario de búsqueda equilibrado. Recibió el nombre del árbol AVL en honor de Adelson, Velskii y Landis, que fueron los primeros científicos en estudiar esta estructura de datos. “Un árbol AVL es un árbol binario de búsqueda en el que las alturas de los subárboles izquierdo y derecho de cualquier nodo difieren como máximo en 1.”</p>
<p><em>Fuente: Algoritmos y estructuras de datos, una perspectiva en C. Luis Joyanes Aguilar, Ignacio Zahonero Martínez.</em></p>
<p>En este árbol únicamente se desarrolla el método para insertar nodos, porque el objetivo de la aplicación es únicamente graficar el árbol, adicionalmente, podrían desarrollarse métodos para eliminar nodos, buscar nodos, vaciar el árbol, calcular la profundidad del árbol, etc. El único recorrido que se hace del árbol es el enorden, que muestra los nodos del árbol ordenados, pero existen otros recorridos que también podrían implementarse como el recorrido preorden, postorden o el recorrido por anchura.</p>
<h3 id="Interfaz-Comparable-El-secreto-tras-la-flexibilidad-de-este-arbol"><a href="#Interfaz-Comparable-El-secreto-tras-la-flexibilidad-de-este-arbol" class="headerlink" title="Interfaz Comparable: El secreto tras la flexibilidad de este árbol"></a><strong>Interfaz Comparable: El secreto tras la flexibilidad de este árbol</strong></h3><p>La razón por la cual este árbol puede utilizarse para almacenar cadenas o bien para almacenar números es la interfaz Comparable. Lo que almacena el nodo es la instancia de una clase que implementa la interfaz Comparable, por supuesto que todos los nodos tienen que poder compararse satisfactoriamente, por ejemplo no se podrían almacenar números enteros y también cadenas de caracteres en un mismo árbol, ya que no podrían comparase satisfactoriamente porque se daría un problema de tipos. Pero si todos los nodos almacenan números, el árbol funciona sin problemas, al igual cuando todos los nodos almacenan cadenas. Si deseáramos almacenar otro tipo de información podríamos programar una clase que contenga los atributos que deseamos y que implemente la interfaz Comparable, entonces sin modificar el árbol podríamos almacenar esta información.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas"></a><strong>Fuentes consultadas</strong></h3><p>Algoritmos y estructuras de datos, una perspectiva en C. Luis Joyanes Aguilar, Ignacio Zahonero Martínez.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:36.000Z" title="4/26/2019, 3:21:36 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/07-Graficar-expresiones-aritmeticas-con-Graphviz-Java-Jlex-y-Cup/">Graficar expresiones aritméticas con Graphviz, Java, Jlex y Cup</a></p><div class="content"><p>En este tutorial se desarrolla un ejemplo sencillo de un intérprete que recibe como entrada un archivo de texto que contiene varias expresiones aritméticas que son evaluadas y posteriormente graficadas por Graphviz, para ello se hace análisis léxico y sintáctico de dicha entrada, los analizadores se generan con Jlex y Cup. Es importante mencionar que para que el ejemplo funcione correctamente debe estar instalado Graphviz. Para desarrollar el proyecto se utilizó Ubuntu 14.04 y Netbeans 8.0. El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/GraficandoAritmeticas">Graficar expresiones aritméticas con Graphviz, Java, Jlex y Cup</a></p>
<p>Todo el código dentro del proyecto está documentado con comentarios que contienen explicaciones sobre su funcionamiento.</p>
<p>Si desean, una pequeña introducción al uso de Jlex y Cup pueden visitar alguno de mis posts:</p>
<ul>
<li><a href="/2019/04/25/01-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Linux/" title="Mi primer proyecto utilizando Jlex y Cup (Linux)">Mi primer proyecto utilizando Jlex y Cup (Linux)</a></li>
<li><a href="/2019/04/26/02-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Windows/" title="Mi primer proyecto utilizando Jlex y Cup (Windows)">Mi primer proyecto utilizando Jlex y Cup (Windows)</a></li>
</ul>
<h3 id="Instalacion-de-Graphviz"><a href="#Instalacion-de-Graphviz" class="headerlink" title="Instalación de Graphviz"></a><strong>Instalación de Graphviz</strong></h3><p>Lo primero que haremos será instalar Graphviz, para ello abrimos una terminal, en Ubuntu puede hacerse con la combinación de teclas Ctrl+Alt+t o en Aplicaciones → Accesorios → Terminal, una vez abierta la terminal ingresamos el comando “sudo apt-get install graphviz”, autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado Graphviz.</p>


<h3 id="Funcionamiento-del-proyecto"><a href="#Funcionamiento-del-proyecto" class="headerlink" title="Funcionamiento del proyecto"></a><strong>Funcionamiento del proyecto</strong></h3><p>La aplicación recibe como entrada un archivo que se encuentra en la carpeta del proyecto, dicho archivo se llama “entrada.txt” y contiene lo siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1+1];</span><br><span class="line">Evaluar[1+1*2];</span><br><span class="line">Evaluar[1.5+1.25*6.4/3.3-5.2+7.1];</span><br><span class="line">Evaluar[1.1+1.2*6.3/3.4-5+1*-2.12345];</span><br><span class="line">Evaluar[(2+2)*3+(1-1)];</span><br></pre></td></tr></table></figure>

<p>Al ejecutar la aplicación, esta le hace análisis léxico y sintáctico al archivo de entrada, evalúa las expresiones aritméticas e indica el resultado de la expresión y el nombre del archivo en el que se generó la imagen.</p>


<p>Veremos que se generan una serie de archivos .dot y una serie de archivos .jpg, los archivos dot, contienen el código con el que Graphviz genera la imagen jpg correspondiente.</p>


<p>A continuación se muestra el detalle de las imágenes que se generaron para cada línea del archivo de entrada.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1+1];</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1+1*2];</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1.5+1.25*6.4/3.3-5.2+7.1];</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1.1+1.2*6.3/3.4-5+1*-2.12345];</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[(2+2)*3+(1-1)];</span><br></pre></td></tr></table></figure>



<h3 id="La-magia-detras-de-todo-esto-Arbol-de-sintaxis-abstracta-AST"><a href="#La-magia-detras-de-todo-esto-Arbol-de-sintaxis-abstracta-AST" class="headerlink" title="La magia detrás de todo esto: Árbol de sintaxis abstracta (AST)"></a><strong>La magia detrás de todo esto: Árbol de sintaxis abstracta (AST)</strong></h3><p>Un árbol de sintaxis abstracta (AST) es una representación simplificada de la estructura sintáctica del código fuente. A nivel de programación un AST es una estructura de datos que se genera durante el proceso de análisis sintáctico.</p>
<p>En este ejemplo el AST es la pieza más importante porque con él pueden ejecutarse las principales funciones que son: evaluar la expresión y graficar la expresión.</p>
<p>En este ejemplo el AST se construye al hacer análisis sintáctico al archivo de entrada, esta estructura es un árbol binario, ya que cada nodo puede tener como máximo dos hijos y modela bien el funcionamiento de las expresiones aritméticas porque todas sus operaciones tienen dos operandos y el caso del operador “-” de las expresiones negativas que tiene un solo operando.</p>
<p>Hacemos análisis sintáctico una sola vez para cargar el árbol, posteriormente podemos recorrer ese árbol las veces que deseemos, podemos manipularlo y hacer muchas cosas sin necesidad de hacer nuevamente análisis sintáctico al archivo de entrada.</p>
<p>En este caso, el árbol se carga y posteriormente se recorre para evaluar la expresión aritmética y mostrar en consola el resultado. Se recorre nuevamente el árbol para generar el código de Graphviz y guardarlo en un archivo .dot, con el archivo .dot podemos pedirle a Graphviz que cree el diagrama de la expresión aritmética.</p>
<p>Todos los métodos que realizan estas acciones luego de cargar el árbol se encuentran en la clase “Nodo”, del paquete “arbol”. El método getValor, devuelve el resultado de la expresión aritmética evaluada. El método graficar, genera el diagrama de la expresión aritmética y devuelve el nombre del archivo generado.</p>
<p>Si les gusto este tutorial, puede que también estén interesados en este otro: </p>
<ul>
<li><a href="/2019/04/26/05-Interprete-sencillo-utilizando-Java-Jlex-y-Cup/" title="Intérprete sencillo utilizando Java, Jlex y Cup">Intérprete sencillo utilizando Java, Jlex y Cup</a></li>
</ul>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:33.000Z" title="4/26/2019, 3:21:33 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/Java/">Java</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/06-Chat-con-Sockets-en-Java/">Chat con Sockets en Java</a></p><div class="content"><p>El chat que se muestra en esta publicación utiliza sockets para la comunicación, se desarrolló utilizando Java 1.8 y NetBeans 8.0. El ejemplo está formado por dos aplicaciones, el cliente y el servidor, ambas pueden descargarse de los siguientes enlaces:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ChatServidor">Chat con Sockets en Java (Servidor)</a>.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ChatCliente">Chat con Sockets en Java (Cliente)</a>.</p>
<p>Todo el código dentro ambos proyectos está documentado con comentarios que explican su funcionamiento.</p>
<h3 id="Funcionamiento-del-chat"><a href="#Funcionamiento-del-chat" class="headerlink" title="Funcionamiento del chat"></a><strong>Funcionamiento del chat</strong></h3><p>Para que el chat funcione correctamente, debe ejecutarse primero la aplicación servidor, en la que el cliente debe ingresar el puerto por el cual el servidor escuchara las conexiones de los clientes que participen en el chat. Puede dejarse el puerto por defecto o puede indicarse uno diferente, que no esté siendo utilizado por ninguna otra aplicación.</p>


<p>Si el servidor inicia correctamente se mostrará una ventana como la siguiente.</p>


<p>En este punto ya podremos ejecutar aplicaciones cliente que se conecten al chat, al ejecutar la aplicación cliente nos pedirá la IP de la máquina en la que se ejecuta la aplicación servidor, por defecto tiene la dirección de <em>localhost</em>, en este caso se utiliza esta porque el servidor y todos los clientes se están ejecutando en la misma máquina. Además de la dirección IP, se debe ingresar el puerto por el que el servidor escucha las conexiones de los clientes y el nombre del usuario que se desea conectar.</p>


<p>Si la conexión es correcta, entonces se muestra una ventana que tiene una <em>JTextArea</em> en la que se muestra el historial de las conversaciones, un <em>JComboBox</em> que muestra el listado de los usuarios conectados a los que se puede enviar mensajes, un <em>JTextField</em> en el que se puede ingresar los mensajes a enviar y un <em>JButton</em> para enviar el mensaje.</p>


<p>Si solamente está conectado un cliente, no habrá nadie a quien se le pueda enviar mensajes, si el cliente intentara enviar uno se mostraría el siguiente mensaje de información.</p>


<p>Al ejecutar más de un cliente estos ya podrán comunicarse entre sí.</p>


<p>Luego de que los clientes envíen y reciban múltiples mensajes se tiene algo como lo siguiente.</p>


<p>Si se cierran las ventanas, la aplicación cliente considerará que el usuario está cerrando sesión y enviará una notificación al servidor para elimine a este cliente de la lista de clientes y notifique al resto de los usuarios conectados que deben eliminarlo de su lista de contactos.</p>


<p>En la aplicación servidor se muestra un log, en el que se informa cuando un usuario inicia o cierra sesión.</p>


<p>Si el servidor se cierra repentinamente, mientras aún hay clientes conectados, estas aplicaciones cliente se cerrarán luego de mostrar el siguiente mensaje.</p>


<p>Si se intenta ejecutar una aplicación cliente sin haber ejecutado antes la aplicación servidor o se ingresa una dirección IP o un puerto equivocado se mostrará el siguiente mensaje.</p>


<h3 id="Logica-del-chat"><a href="#Logica-del-chat" class="headerlink" title="Lógica del chat"></a><strong>Lógica del chat</strong></h3><p>El chat consiste de dos aplicaciones, el cliente y el servidor, el servidor se ejecuta una vez y el cliente se ejecuta <strong>N</strong> veces, donde <strong>N</strong> es el número de usuarios que participarán en el chat, todos los mensajes que los usuarios del chat se envían entre sí pasan a través del servidor, cuando un cliente quiere enviar un mensaje a otro, le envía el mensaje al servidor indicándole su destinatario y el servidor se encarga de reenviar este mensaje, el servidor también se encarga de indicarle a todos los usuarios cuando un usuario nuevo se conecta al chat, para que puedan incluirlo en su lista de contactos y por ende en la conversación. Asimismo, cuando un cliente se desconecta, el servidor se encarga de informar a todos los usuarios que deben eliminar al cliente que cerró su sesión de la lista de contactos porque ya no podrán enviarle mensajes. No hay comunicación directa entre clientes, el servidor siempre es intermediario entre la comunicación de los clientes. Si se ejecutara el servidor y luego se ejecutaran cuatro clientes que se conectaran a dicho servidor, la comunicación sería como se muestra en la siguiente imagen.</p>


<h3 id="Funcionamiento-del-servidor"><a href="#Funcionamiento-del-servidor" class="headerlink" title="Funcionamiento del servidor"></a><strong>Funcionamiento del servidor</strong></h3><p>El servidor tiene tres clases, que se describen a continuación:</p>
<ul>
<li><p><em>VentanaS</em>: esta clase gestiona la interfaz gráfica del servidor, que básicamente muestra un log de las principales acciones del servidor (conexión y desconexión de clientes).</p>
</li>
<li><p><em>Servidor</em>: Esta clase gestiona a los clientes que se conectan al servidor, es un hilo que tiene como principal función escuchar constantemente en caso de que algún nuevo cliente quiera conectarse al chat.</p>
</li>
<li><p><em>HiloCliente</em>: Cada vez que un nuevo cliente se conecta, dentro de la clase servidor se instancia un nuevo *HiloCliente *y se agrega a la lista de clientes. Este hilo cuenta con un socket con el que puede enviar y recibir mensajes del cliente con el que está conectado y tiene como principal función escuchar constantemente en caso de que el cliente envíe mensajes.</p>
</li>
</ul>
<p>A continuación se muestra una imagen que ilustra el funcionamiento de la aplicación servidor.</p>


<h3 id="Funcionamiento-del-cliente"><a href="#Funcionamiento-del-cliente" class="headerlink" title="Funcionamiento del cliente"></a><strong>Funcionamiento del cliente</strong></h3><p>El cliente tiene dos clases, que se describen a continuación:</p>
<ul>
<li><p><em>VentanaC</em>: esta clase gestiona la interfaz gráfica del servidor, que básicamente muestra una lista de contactos, un historial de conversación, una caja de texto para ingresar nuevos mensajes y un botón que permite enviar mensajes.</p>
</li>
<li><p><em>Cliente</em>: Cuando el cliente se instancia y se conecta con el servidor, se crea un hilo que está escuchar constantemente en caso de que el servidor envíe mensajes. Este cliente cuenta con un socket con el que puede enviar y recibir mensajes del servidor con el que está conectado.</p>
</li>
</ul>
<p>A continuación se muestra una imagen que ilustra el funcionamiento de la aplicación cliente.</p>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:31.000Z" title="4/26/2019, 3:21:31 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/05-Interprete-sencillo-utilizando-Java-Jlex-y-Cup/">Intérprete sencillo utilizando Java, Jlex y Cup</a></p><div class="content"><p>En los cursos de compiladores de la universidad, es bastante común que se solicite al estudiante desarrollar un intérprete, una herramienta que reciba como entrada cierto lenguaje de programación y lo ejecute, pero la mayoría de documentación al respecto solo muestra ejemplos de cosas sencillas, como una calculadora o un lenguaje que imprime cadenas en consola. Pero qué pasa si lo que deseamos es que se ejecuten sentencias de control como el IF o ciclos como la sentencia WHILE y que además estas sentencias soporten muchos niveles de anidamiento, que se declaren variables y se asigne valores a estas variables, que se tenga control de los ámbitos de las variables, en fin, que tenga las funciones básicas de un lenguaje de programación. No es común encontrar este tipo de ejemplos, en lo personal, puedo asegurar que nunca encontré un tutorial en el que se mostrara un ejemplo documentado y bien explicado sobre esto. Es por eso que les traigo este ejemplo, espero que les sea útil.</p>
<h3 id="Funcionamiento-de-la-aplicacion"><a href="#Funcionamiento-de-la-aplicacion" class="headerlink" title="Funcionamiento de la aplicación"></a><strong>Funcionamiento de la aplicación</strong></h3><p>En este tutorial se desarrolla un intérprete que recibe como entrada un archivo de texto que contiene varias sentencias en un lenguaje programación diseñado especialmente para esta aplicación, primero se hace análisis léxico y sintáctico de dicha entrada, durante el análisis sintáctico se carga en memoria un Árbol de Sintaxis Abstracta (AST) que se utiliza posteriormente para ejecutar las sentencias. Los analizadores se generan con Jlex y Cup. Se desarrollaron dos versiones del proyecto, una utilizando Windows 10 y otra utilizando Ubuntu 14.04. El proyecto completo del ejemplo puede descargarse de los siguientes enlaces:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencillo">Intérprete sencillo utilizando Java, Jlex y Cup (Linux)</a><br><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloWindows">Intérprete sencillo utilizando Java, Jlex y Cup (Windows)</a></p>
<p>Todo el código dentro del proyecto está documentado con comentarios que contienen explicaciones sobre su funcionamiento.</p>
<p>Si desean una pequeña introducción al uso de Jlex y Cup pueden visitar mi post: <a href="/2019/04/25/01-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Linux/" title="Mi primer proyecto utilizando Jlex y Cup (Linux)">Mi primer proyecto utilizando Jlex y Cup (Linux)</a> o bien <a href="/2019/04/26/02-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Windows/" title="Mi primer proyecto utilizando Jlex y Cup (Windows)">Mi primer proyecto utilizando Jlex y Cup (Windows)</a>.</p>
<h3 id="El-lenguaje-de-entrada"><a href="#El-lenguaje-de-entrada" class="headerlink" title="El lenguaje de entrada"></a><strong>El lenguaje de entrada</strong></h3><p>Dentro de la carpeta del proyecto, hay un archivo de entrada llamado “entrada.txt”, en él se muestran ejemplos de todas las funciones del lenguaje diseñado para esta aplicación, al leerlo se puede tener una idea clara de las funciones con las que el lenguaje cuenta, este archivo contiene lo siguiente:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro *</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io    *</span></span><br><span class="line"><span class="comment"> * Septiembre - 2015                      *</span></span><br><span class="line"><span class="comment"> ******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Se imprime el encabezado</span></span><br><span class="line">imprimir(<span class="string">&quot;Tablas de&quot;</span> &amp; <span class="string">&quot; multiplicar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Se declara la variable a, de tipo numero</span></span><br><span class="line">numero a;</span><br><span class="line"><span class="comment">//Se asigna a la variable a el valor 0</span></span><br><span class="line">a=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//Se declara la variable c, de tipo numero</span></span><br><span class="line">numero c;</span><br><span class="line"><span class="comment">//Se asigna a la variable c el valor 0</span></span><br><span class="line">c=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//Se imprime un separador</span></span><br><span class="line">imprimir(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Se imprimen las tablas del 1 al 5 y </span></span><br><span class="line"><span class="comment"> * para cada tabla, se imprimen los resultados</span></span><br><span class="line"><span class="comment"> * desde el uno hasta el 5, esto se hace con </span></span><br><span class="line"><span class="comment"> * dos ciclos while anidados. </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">mientras(a&lt;<span class="number">4</span>+c)&#123; </span><br><span class="line"> a=a+<span class="number">1</span>;</span><br><span class="line"> numero b;</span><br><span class="line"> b=<span class="number">0</span>;</span><br><span class="line"> mientras(b&lt;<span class="number">4</span>+c)&#123;</span><br><span class="line">  b=b+<span class="number">1</span>;</span><br><span class="line">  imprimir(a &amp; <span class="string">&quot; * &quot;</span> &amp; b &amp; <span class="string">&quot; = &quot;</span> &amp; a * b);</span><br><span class="line"> &#125;</span><br><span class="line"> imprimir(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Se asigna a la variable a el valor de 11</span></span><br><span class="line">a=<span class="number">11</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * La variable b ya había sido declarada pero </span></span><br><span class="line"><span class="comment"> * dentro del ámbito del primer ciclo while, </span></span><br><span class="line"><span class="comment"> * entonces no existe en este ámbito por lo que </span></span><br><span class="line"><span class="comment"> * debe declararse.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">numero b;</span><br><span class="line"><span class="comment">//Se asigna valor de 12 a b y valor de 13 a c</span></span><br><span class="line">b=<span class="number">12</span>;</span><br><span class="line">c=<span class="number">13</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Se evalua si el valor de la variable a es </span></span><br><span class="line"><span class="comment"> * mayor que 10, si el b es mayor que 11 y si</span></span><br><span class="line"><span class="comment"> * el de c es mayor que 12. </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">If(a&gt;<span class="number">10</span>)&#123;</span><br><span class="line"> imprimir(<span class="string">&quot;a es mayor que 10.&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(b&gt;<span class="number">11</span>)&#123;</span><br><span class="line">  imprimir(<span class="string">&quot;a es mayor que 10 y b es mayor que 11.&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(c&gt;<span class="number">12</span>)&#123;</span><br><span class="line">   imprimir(<span class="string">&quot;a es mayor que 10, b es mayor que 11 y c es mayor que 12.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> imprimir(<span class="string">&quot;a es menor o igual que 10.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Como se puede observar, el lenguaje acepta:</p>
<ul>
<li><p>Comentarios de muchas líneas (&#x2F;<em><Contenido del comentario></em>&#x2F;).</p>
</li>
<li><p>Comentarios de una línea (&#x2F;&#x2F;<Contenido del comentario>).</p>
</li>
<li><p>Concatenación de cadenas, mediante el operador “&amp;”.</p>
</li>
<li><p>Función “imprimir”: que recibe como parámetro una cadena e imprime en consola dicha cadena.</p>
</li>
<li><p>Declaración de variables: el único tipo de variables que el lenguaje soporta es “numero”, que es una variable de tipo numérico que suporta números enteros o con punto decimal (Dentro del rango del tipo Double de Java).</p>
</li>
<li><p>Asignación de variables, a cualquier variable se le puede asignar cualquier expresión que tenga como resultado un número.</p>
</li>
<li><p>Instrucción “mientras”: tiene el comportamiento clásico del ciclo while, ejecuta el ciclo mientras la expresión booleana que recibe sea verdadera. Esta instrucción soporta anidamiento.</p>
</li>
<li><p>Instrucción “if” e instrucción “if-else”: si la expresión booleana que recibe es verdadera entonces ejecuta las instrucciones contenidas en el “if”, si es falsa y la instrucción tiene un “else” entonces se ejecutan las instrucciones contenidas en el “else”. Esta instrucción soporta anidamiento.</p>
</li>
<li><p>Expresiones aritméticas: Estas expresiones soportan sumas, restas, divisiones, multiplicaciones, expresiones negativas y paréntesis para agrupar operaciones. Tiene la precedencia habitual de las expresiones aritméticas.</p>
</li>
<li><p>Expresiones booleanas: comparan dos expresiones que tengan como resultado un número y soportan únicamente los operadores mayor que y menor que (&lt;, &gt;).</p>
</li>
</ul>
<h3 id="El-resultado-de-la-ejecucion"><a href="#El-resultado-de-la-ejecucion" class="headerlink" title="El resultado de la ejecución"></a><strong>El resultado de la ejecución</strong></h3><p>Al ejecutar el archivo de entrada mostrado anteriormente se obtiene el siguiente resultado en consola:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">run:</span><br><span class="line">Tablas de multiplicar</span><br><span class="line">----------------</span><br><span class="line">1.0 * 1.0 = 1.0</span><br><span class="line">1.0 * 2.0 = 2.0</span><br><span class="line">1.0 * 3.0 = 3.0</span><br><span class="line">1.0 * 4.0 = 4.0</span><br><span class="line">1.0 * 5.0 = 5.0</span><br><span class="line">----------------</span><br><span class="line">2.0 * 1.0 = 2.0</span><br><span class="line">2.0 * 2.0 = 4.0</span><br><span class="line">2.0 * 3.0 = 6.0</span><br><span class="line">2.0 * 4.0 = 8.0</span><br><span class="line">2.0 * 5.0 = 10.0</span><br><span class="line">----------------</span><br><span class="line">3.0 * 1.0 = 3.0</span><br><span class="line">3.0 * 2.0 = 6.0</span><br><span class="line">3.0 * 3.0 = 9.0</span><br><span class="line">3.0 * 4.0 = 12.0</span><br><span class="line">3.0 * 5.0 = 15.0</span><br><span class="line">----------------</span><br><span class="line">4.0 * 1.0 = 4.0</span><br><span class="line">4.0 * 2.0 = 8.0</span><br><span class="line">4.0 * 3.0 = 12.0</span><br><span class="line">4.0 * 4.0 = 16.0</span><br><span class="line">4.0 * 5.0 = 20.0</span><br><span class="line">----------------</span><br><span class="line">5.0 * 1.0 = 5.0</span><br><span class="line">5.0 * 2.0 = 10.0</span><br><span class="line">5.0 * 3.0 = 15.0</span><br><span class="line">5.0 * 4.0 = 20.0</span><br><span class="line">5.0 * 5.0 = 25.0</span><br><span class="line">----------------</span><br><span class="line">a es mayor que 10.</span><br><span class="line">a es mayor que 10 y b es mayor que 11.</span><br><span class="line">a es mayor que 10, b es mayor que 11 y c es mayor que 12.</span><br><span class="line">BUILD SUCCESSFUL (total <span class="keyword">time</span>: 0 seconds)</span><br></pre></td></tr></table></figure>



<h3 id="Sobre-la-tabla-de-simbolos"><a href="#Sobre-la-tabla-de-simbolos" class="headerlink" title="Sobre la tabla de símbolos"></a><strong>Sobre la tabla de símbolos</strong></h3><p>La tabla de símbolos es una parte importante en el proceso de ejecución del código, es en esta estructura de datos en donde guardamos información de las variables como su tipo, identificador y valor. A esta estructura podemos pedirle el valor de una variable, o pedirle que le asigne cierto valor a una variable.</p>
<p>Es importante mencionar que en el proceso de ejecución la tabla de símbolos va cambiando de forma dinámica, esto con el objetivo de manejar los ámbitos, por ejemplo, la instrucción WHILE tiene su propio ámbito, lo que significa que su tabla de símbolos contiene información de las variables declaradas en ámbitos superiores y la información de las variables declaradas en el ámbito local de la instrucción, al terminar de ejecutar la instrucción, todas las variables declaradas en el ámbito local se eliminan de la tabla de símbolos que almacena la información de los ámbitos superiores, de tal manera que los ámbitos superiores no tendrán acceso a las variables declaradas dentro del WHILE.</p>
<h3 id="La-magia-detras-de-todo-esto-Arbol-de-sintaxis-abstracta-AST"><a href="#La-magia-detras-de-todo-esto-Arbol-de-sintaxis-abstracta-AST" class="headerlink" title="La magia detrás de todo esto: Árbol de sintaxis abstracta (AST)"></a><strong>La magia detrás de todo esto: Árbol de sintaxis abstracta (AST)</strong></h3><p>Un árbol de sintaxis abstracta (AST) es una representación simplificada de la estructura sintáctica del código fuente. A nivel de programación un AST es una estructura de datos que se genera durante el proceso de análisis sintáctico.</p>
<p>En este ejemplo el AST es la pieza más importante porque al recorrerlo pueden ejecutarse las acciones del código de entrada y ese es el principal objetivo de la aplicación.</p>
<p>En el código fuente de Cup se observa que la mayoría de las acciones se enfocan en cargar el AST, básicamente es lo único que hace el analizador, además de verificar que la sintaxis de la entrada sea correcta</p>
<p>La estructura en este caso es un tanto compleja ya que cada nodo puede tener muchos hijos, en el caso de las instrucciones IF-ELSE y WHILE, el número de hijos es incierto ya que estas instrucciones pueden contener muchas otras instrucciones dentro, lo cierto es que el árbol se acopla muy bien al lenguaje de programación porque en el árbol se tiene bien claro qué instrucciones están contenidas dentro de otras instrucciones, porque cada nodo esta directamente ligado a sus hijos, entonces la ejecución de instrucciones anidadas no representa mayor problema.</p>
<p>Hacemos análisis sintáctico una sola vez para cargar el árbol, posteriormente recorremos ese árbol para ejecutar el código.</p>
<p>El árbol es una representación exacta de lo que el código de entrada contiene. Las únicos tres paquetes del proyecto son:</p>
<ul>
<li><p>analizadores: que contiene los archivos de Cup y JLex y los analizadores que con estas herramientas se generaron.</p>
</li>
<li><p>arbol: que contiene todas las clases que forman parte del AST, que se utiliza como estructura primaria en la aplicación.</p>
</li>
<li><p>interpretesencillo: que contiene la clase principal de la aplicación.</p>
</li>
</ul>


<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:25.000Z" title="4/26/2019, 3:21:25 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/02-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Windows/">Mi primer proyecto utilizando Jlex y Cup (Windows)</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presenta como salida el resultado de dichas expresiones.</p>
<p>Las tecnologías a utilizar son:</p>
<ul>
<li><p><strong>Jlex</strong>: Generador de analizadores léxicos</p>
</li>
<li><p><strong>Cup</strong>: Generador de analizadores sintácticos</p>
</li>
<li><p><strong>Windows 10</strong>: Sistema operativo</p>
</li>
<li><p><strong>Netbeans 8.2</strong>: IDE (entorno de desarrollo integrado)</p>
</li>
</ul>
<p>El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoCupJlexWindows">Mi primer proyecto utilizando Jlex y Cup (Windows)</a></p>
<h3 id="JLex"><a href="#JLex" class="headerlink" title="JLex"></a><strong>JLex</strong></h3><p>JLex es un generador de analizadores léxicos, escrito en Java, para Java. JLex fue desarrollado por Elliot Berk en la Universidad de Princeton. Para más información visitar la <a target="_blank" rel="noopener" href="https://www.cs.princeton.edu/~appel/modern/java/JLex/">página oficial de JLex</a>.</p>
<p>La principal tarea de un analizador léxico es leer los caracteres de entrada del programa fuente, agruparlos en lexemas y producir como salida una secuencia de tokens.</p>
<ul>
<li><p>Un <em>token</em> es un par que consiste en un nombre de token y un valor de atributo opcional.</p>
</li>
<li><p>Un <em>lexema</em> es una secuencia de caracteres en el programa fuente, que coinciden con el patrón para un token y que el analizador léxico identifica como una instancia de este tóken.</p>
</li>
<li><p>Un <em>patrón</em> es una descripción de la forma que pueden tomar los lexemas de un token.</p>
</li>
</ul>
<p>En JLex se definen los patrones de los diferentes tokens que se desean reconocer, estos patrones pueden definirse a través de expresiones regulares. Además JLex cuenta con múltiples opciones, una muy imporante es su capacidad para integrarse con generadores de analizadores sintácticos como Cup.</p>
<h3 id="Cup"><a href="#Cup" class="headerlink" title="Cup"></a><strong>Cup</strong></h3><p><a target="_blank" rel="noopener" href="http://www2.cs.tum.edu/projects/cup/">Cup</a> es un generador de analizadores sintácticos de tipo LALR para Java.</p>
<p>El analizador sintáctico obtiene una cadena de tokens del analizador léxico y verifica que dicha cadena pueda generase con la gramática para el lenguaje fuente. Una gramática proporciona una especificación precisa y fácil de entender de un lenguaje de programación.</p>
<h3 id="Pre-requisitos"><a href="#Pre-requisitos" class="headerlink" title="Pre-requisitos"></a><strong>Pre-requisitos</strong></h3><p>Para este ejemplo hace falta que tengamos instalado:</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Java Development Kit (JDK)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://netbeans.org/downloads/">Netbeans</a></p>
</li>
</ul>
<p>Debemos asegurarnos que la carpeta bin del JDK haya sido agregada a nuestra variable de entorno Path, para ello vamos a la configuración de dicha variable de entorno (Clic derecho en This PC → Properties → Advanced system settings → Environment Variables → Variable Path → Edit) y si no existe agregamos la ruta a la carpeta bin del JDK, que en mi caso es: C:\Program Files\Java\jdk1.8.0_152\bin</p>


<h3 id="Descargar-JLex"><a href="#Descargar-JLex" class="headerlink" title="Descargar JLex"></a><strong>Descargar JLex</strong></h3><p> Lo primero que haremos será descargar JLex, para ello vamos a la <a target="_blank" rel="noopener" href="https://www.cs.princeton.edu/~appel/modern/java/JLex/">página oficial</a> y descargamos la versión actual del software:</p>


<p>Vamos a obtener el archivo Main.java:</p>


<h3 id="Descargar-Cup"><a href="#Descargar-Cup" class="headerlink" title="Descargar Cup"></a><strong>Descargar Cup</strong></h3><p>Para descargar Cup, vamos a la <a target="_blank" rel="noopener" href="http://www2.cs.tum.edu/projects/cup/">página oficial</a> y descargamos la última versión del software:</p>


<p>Descomprimimos el archivo descargado, para ello se recomienda la herramienta <a target="_blank" rel="noopener" href="http://www.peazip.org/">PeaZip</a> y vamos a obtener los siguientes archivos:</p>


<h3 id="Crear-nuestro-proyecto"><a href="#Crear-nuestro-proyecto" class="headerlink" title="Crear nuestro proyecto"></a><strong>Crear nuestro proyecto</strong></h3><p>Abrimos Netbeans y creamos un nuevo proyecto de Java (File → New Project).</p>




<p>Creamos un paquete llamado analizadores, este almacenará todo el código fuente relacionado con el analizador léxico y sintáctico (Clic derecho en Source Packages → New → Java Package).</p>


<p>Creamos tres archivos en el paquete analizadores, el primero “Lexico”, que almacenará el código fuente con el cual JLex generará el analizador léxico que queremos, el segundo “Sintactico”, que almacenará el código fuente con el cual Cup generará el analizador sintáctico que queremos y el tercero “compilar.sh”, que guardará los comandos que deben ejecutarse para solicitarle a JLex y a Cup que generen los analizadores. Para crear cada uno de los archivos hacemos clic derecho en el paquete analizadores → New → Other → en la ventana que despliegue, seleccionar Categories: Other y File Types: Empty File, seleccionamos siguiente, indicamos el nombre para el archivo y finalizamos. De tal modo que al final tendremos los tres archivos archivos.</p>


<h3 id="Importar-la-libreria-de-Cup-en-nuestro-proyecto-para-poder-ejecutar-el-analizador-sintactico-que-generemos"><a href="#Importar-la-libreria-de-Cup-en-nuestro-proyecto-para-poder-ejecutar-el-analizador-sintactico-que-generemos" class="headerlink" title="Importar la librería de Cup en nuestro proyecto para poder ejecutar el analizador sintáctico que generemos"></a><strong>Importar la librería de Cup en nuestro proyecto para poder ejecutar el analizador sintáctico que generemos</strong></h3><p>Para ello creamos una carpeta lib dentro de la carpeta de nuestro proyecto.</p>


<p>Dentro de la carpeta lib pegamos el archivo “java-cup-11b-runtime.jar” que descargamos anteriormente.</p>


<p>Para importar el archivo jar, vamos a Netbeans y damos clic derecho en la pestaña Libraries de nuestro proyecto → Add JAR&#x2F;Folder… luego buscamos el archivo jar en la carpeta lib que acabamos de copiar en la carpeta lib y lo seleccionamos.</p>


<h3 id="Codigo-fuente-para-el-analizador-lexico"><a href="#Codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Código fuente para el analizador léxico"></a><strong>Código fuente para el analizador léxico</strong></h3><p>En el archivo “Lexico” incluiremos todo el código que le indicará a Jlex lo que debe hacer. El código se muestra a continuación:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io</span></span><br><span class="line"><span class="comment"> * Julio - 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> analizadores;</span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.Symbol; </span><br><span class="line"></span><br><span class="line">%% </span><br><span class="line">%<span class="keyword">class</span> <span class="title class_">Lexico</span></span><br><span class="line">%<span class="keyword">public</span> </span><br><span class="line">%line </span><br><span class="line">%<span class="type">char</span> </span><br><span class="line">%cup </span><br><span class="line">%unicode</span><br><span class="line">%ignorecase</span><br><span class="line"></span><br><span class="line">%init&#123; </span><br><span class="line">    yyline = <span class="number">1</span>; </span><br><span class="line">    yychar = <span class="number">1</span>; </span><br><span class="line">%init&#125; </span><br><span class="line"></span><br><span class="line">BLANCOS=[ \r\t]+</span><br><span class="line">D=[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">DD=[<span class="number">0</span>-<span class="number">9</span>]+(<span class="string">&quot;.&quot;</span>[  |<span class="number">0</span>-<span class="number">9</span>]+)?</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Evaluar&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.REVALUAR,yyline,yychar,</span><br><span class="line">                             yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;;&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PTCOMA,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;(&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;)&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARDER,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;[&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;]&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORDER,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;+&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MAS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;-&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MENOS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;*&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.POR,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;/&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DIVIDIDO,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">\n &#123;yychar=<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#123;BLANCOS&#125; &#123;&#125; </span><br><span class="line">&#123;D&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.ENTERO,yyline,yychar, yytext());&#125; </span><br><span class="line">&#123;DD&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DECIMAL,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Este es un error lexico: &quot;</span>+yytext()+</span><br><span class="line">    <span class="string">&quot;, en la linea: &quot;</span>+yyline+<span class="string">&quot;, en la columna: &quot;</span>+yychar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-lexico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Explicación del código fuente para el analizador léxico"></a><strong>Explicación del código fuente para el analizador léxico</strong></h3><p>En las primeras líneas indicamos a Jlex que la clase estará en el paquete analizadores y que es necesario que se importe la clase Symbol.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> analizadores;</span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.Symbol;</span><br></pre></td></tr></table></figure>

<p>Posteriormente indicamos a Jlex que:</p>
<ul>
<li><p>La clase del analizador se llamará “Lexico”</p>
</li>
<li><p>La clase será pública</p>
</li>
<li><p>Debe llevar el conteo de las líneas</p>
</li>
<li><p>Debe llevar el conteo de los caracteres reconocidos</p>
</li>
<li><p>Debe integrarse con cup</p>
</li>
<li><p>El set de caracteres que debe utilizar es el unicode</p>
</li>
<li><p>El analizador no será case sensitive, es decir, no le importa si las letras son mayúsculas o minúsculas</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%% </span><br><span class="line">%<span class="keyword">class</span> <span class="title class_">Lexico</span></span><br><span class="line">%<span class="keyword">public</span> </span><br><span class="line">%line </span><br><span class="line">%<span class="type">char</span> </span><br><span class="line">%cup </span><br><span class="line">%unicode</span><br><span class="line">%ignorecase</span><br></pre></td></tr></table></figure>

<p>Luego viene el bloque init, dentro del init, se ejecutan las acciones de inicialización, es decir, lo que va dentro del constructor del analizador léxico.En este caso indicamos dentro del init que:</p>
<ul>
<li><p>La variable yyline, que lleva la cuenta del número de linea por el que va el analizador valdrá inicialmente 1.</p>
</li>
<li><p>La variable yychar, que lleva la cuenta del número de carácter por el que va el analizador valdrá inicialmente 1.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%init&#123; </span><br><span class="line">    yyline = <span class="number">1</span>; </span><br><span class="line">    yychar = <span class="number">1</span>; </span><br><span class="line">%init&#125;</span><br></pre></td></tr></table></figure>

<p>Luego se escriben algunas expresiones regulares que son almacenadas en macros, que básicamente son variables que almacenan los patrones, en este caso se definen las macros: BLANCOS, D y DD. Los patrones para cada una son los siguientes:</p>
<ul>
<li><p>BLANCOS: Expresión regular que reconoce uno o muchos espacios en blanco, retornos de carro o tabuladores.</p>
</li>
<li><p>D: Expresión regular que reconoce números enteros.</p>
</li>
<li><p>DD: Expresión regular que reconoce números con punto decimal.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BLANCOS=[ \r\t]+</span><br><span class="line">D=[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">DD=[<span class="number">0</span>-<span class="number">9</span>]+(<span class="string">&quot;.&quot;</span>[  |<span class="number">0</span>-<span class="number">9</span>]+)?</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<p>Por último se definen todas las reglas léxicas, en las que indicamos el patrón que reconocerá y dentro de llaves lo que debe hacer cuando lo reconozca. En la mayoría de los casos se retorna un objeto de tipo Symbol, que vendría siendo un token, este se instancia con el tipo, la fila en la que se encontró, la columna en la que se encontró y el lexema en específico que se reconoció, este se obtiene mediante yytext(). Dentro de las llaves podríamos incluir el código java que quisiéramos. Vemos que al reconocer el patrón BLANCOS no se hace nada porque esperamos que ignore los espacios en blanco. También vemos que al encontrar un salto de linea reinicia la variable yychar, es decir, reinicia el conteo de caracteres para que se lleve la cuenta del número de columna en cada fila.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Evaluar&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.REVALUAR,yyline,yychar,</span><br><span class="line">                             yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;;&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PTCOMA,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;(&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;)&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARDER,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;[&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;]&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORDER,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;+&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MAS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;-&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MENOS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;*&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.POR,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;/&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DIVIDIDO,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">\n &#123;yychar=<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#123;BLANCOS&#125; &#123;&#125; </span><br><span class="line">&#123;D&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.ENTERO,yyline,yychar, yytext());&#125; </span><br><span class="line">&#123;DD&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DECIMAL,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Este es un error lexico: &quot;</span>+yytext()+</span><br><span class="line">    <span class="string">&quot;, en la linea: &quot;</span>+yyline+<span class="string">&quot;, en la columna: &quot;</span>+yychar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Codigo-fuente-para-el-analizador-sintactico"><a href="#Codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Código fuente para el analizador sintáctico"></a><strong>Código fuente para el analizador sintáctico</strong></h3><p>En el archivo “Sintáctico” incluiremos todo el código que le indicará a Cup lo que debe hacer. El código se muestra a continuación:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io</span></span><br><span class="line"><span class="comment"> * Julio - 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> analizadores; </span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.*;</span><br><span class="line"></span><br><span class="line">parser code </span><br><span class="line">&#123;:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintactico.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syntax_error</span><span class="params">(Symbol s)</span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error Sintáctico en la Línea &quot;</span> + (s.left) +</span><br><span class="line">        <span class="string">&quot; Columna &quot;</span>+s.right+ <span class="string">&quot;. No se esperaba este componente: &quot;</span> +s.value+<span class="string">&quot;.&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintáctico </span></span><br><span class="line"><span class="comment">     * en el que ya no es posible una recuperación de errores.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unrecovered_syntax_error</span><span class="params">(Symbol s)</span> <span class="keyword">throws</span> java.lang.Exception&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error síntactico irrecuperable en la Línea &quot;</span> + </span><br><span class="line">        (s.left)+ <span class="string">&quot; Columna &quot;</span>+s.right+<span class="string">&quot;. Componente &quot;</span> + s.value + </span><br><span class="line">        <span class="string">&quot; no reconocido.&quot;</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">:&#125; </span><br><span class="line"></span><br><span class="line">terminal String PTCOMA,PARIZQ,PARDER,CORIZQ,CORDER;</span><br><span class="line">terminal String MAS,MENOS,POR,DIVIDIDO;</span><br><span class="line">terminal String ENTERO;</span><br><span class="line">terminal String DECIMAL;</span><br><span class="line">terminal String UMENOS;</span><br><span class="line">terminal String REVALUAR;</span><br><span class="line"></span><br><span class="line">non terminal ini;</span><br><span class="line">non terminal instrucciones;</span><br><span class="line">non terminal instruccion;</span><br><span class="line">non terminal Double expresion;</span><br><span class="line"></span><br><span class="line">precedence left MAS,MENOS;</span><br><span class="line">precedence left POR,DIVIDIDO;</span><br><span class="line">precedence right UMENOS; </span><br><span class="line"></span><br><span class="line">start with ini; </span><br><span class="line"></span><br><span class="line">ini::=instrucciones;</span><br><span class="line"></span><br><span class="line">instrucciones ::= </span><br><span class="line">   instruccion instrucciones</span><br><span class="line"> | instruccion</span><br><span class="line"> | error instrucciones</span><br><span class="line">; </span><br><span class="line"></span><br><span class="line">instruccion ::= </span><br><span class="line">   REVALUAR CORIZQ expresion:a CORDER PTCOMA&#123;:System.out.println(<span class="string">&quot;El valor de la expresión es: &quot;</span>+a);:&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expresion  ::= </span><br><span class="line">    MENOS expresion:a                      &#123;:RESULT=a*-<span class="number">1</span>;:&#125;%prec UMENOS     </span><br><span class="line"> |  expresion:a MAS        expresion:b     &#123;:RESULT=a+b;:&#125;</span><br><span class="line"> |  expresion:a MENOS      expresion:b     &#123;:RESULT=a-b;:&#125;</span><br><span class="line"> |  expresion:a POR        expresion:b     &#123;:RESULT=a*b;:&#125;</span><br><span class="line"> |  expresion:a DIVIDIDO   expresion:b     &#123;:RESULT=a/b;:&#125;</span><br><span class="line"> |  ENTERO:a                               &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  DECIMAL:a                              &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  PARIZQ expresion:a PARDER              &#123;:RESULT=a;:&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-sintactico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Explicación del código fuente para el analizador sintáctico"></a><strong>Explicación del código fuente para el analizador sintáctico</strong></h3><p>En las primeras líneas indicamos a Cup que la clase estará en el paquete analizadores y que es necesario que se importe todo el contenido de “java_cup.runtime”.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> analizadores; </span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.*;</span><br></pre></td></tr></table></figure>

<p>Luego viene la sección “parser code”, en la que se programan acciones propias del parser o analizador sintáctico que se va a generar, en este caso se programa lo que se debe hacer ante un error sintáctico y ante un error sintáctico irrecuperable.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">parser code </span><br><span class="line">&#123;:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintactico.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syntax_error</span><span class="params">(Symbol s)</span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error Sintáctico en la Línea &quot;</span> + (s.left) +</span><br><span class="line">        <span class="string">&quot; Columna &quot;</span>+s.right+ <span class="string">&quot;. No se esperaba este componente: &quot;</span> +s.value+<span class="string">&quot;.&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintáctico </span></span><br><span class="line"><span class="comment">     * en el que ya no es posible una recuperación de errores.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unrecovered_syntax_error</span><span class="params">(Symbol s)</span> <span class="keyword">throws</span> java.lang.Exception&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error síntactico irrecuperable en la Línea &quot;</span> + </span><br><span class="line">        (s.left)+ <span class="string">&quot; Columna &quot;</span>+s.right+<span class="string">&quot;. Componente &quot;</span> + s.value + </span><br><span class="line">        <span class="string">&quot; no reconocido.&quot;</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">:&#125;</span><br></pre></td></tr></table></figure>

<p>Luego se definen los terminales, a estos se les puede indicar un tipo, en este caso todos son de tipo *String, *si no se indicara un tipo, los terminales serían por defecto de tipo <em>Object</em>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">terminal String PTCOMA,PARIZQ,PARDER,CORIZQ,CORDER;</span><br><span class="line">terminal String MAS,MENOS,POR,DIVIDIDO;</span><br><span class="line">terminal String ENTERO;</span><br><span class="line">terminal String DECIMAL;</span><br><span class="line">terminal String UMENOS;</span><br><span class="line">terminal String REVALUAR;</span><br></pre></td></tr></table></figure>

<p>Existe un terminal por cada tipo de token que el analizador léxico devuelve. Todos estos tipos estarán definidos en la clase “sym”, que se genera automáticamente y de la que se hablará más adelante.</p>
<p>Luego viene la declaración de los no terminales, a los que también se les puede indicar un tipo específico, si no se les indica un tipo, estos son por defecto de tipo <em>Object</em>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">non terminal ini;</span><br><span class="line">non terminal instrucciones;</span><br><span class="line">non terminal instruccion;</span><br><span class="line">non terminal Double expresion;</span><br></pre></td></tr></table></figure>

<p>Posteriormente podemos indicar la precedencia de los operadores, ya que la gramática escrita es ambigua, es necesario definir una precedencia para que el analizador no entre en conflicto al analizar, en este caso la precedencia es la misma que la de los operadores aritméticos, la precedencia más baja la tienen la suma y la resta, luego están la multiplicación y la división que tienen una precedencia más alta y por último está el signo menos de las expresiones negativas que tendría la precedencia más alta.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">precedence left MAS,MENOS;</span><br><span class="line">precedence left POR,DIVIDIDO;</span><br><span class="line">precedence right UMENOS;</span><br></pre></td></tr></table></figure>

<p>Por último viene el conjunto de reglas de escritura de la gramática o producciones, al final de cada producción puede incluirse código java entre llaves y dos puntos “{:&lt;código java&gt;:}”. Podemos ver que en las producciones del no terminal “expresion”, se utiliza la variable RESULT, esta variable es propia de Cup y nos permite sintetizar cierto atributo para ese no terminal que se encuentra del lado izquierdo de la producción, recordemos que Cup trabaja con analizadores LALR, que son de tipo ascendente, lo que significa que nos permiten manipular atributos sintetizados. Básicamente eso es RESULT, un atributo sintetizado.</p>
<p>RESULT puede ser cualquier objeto, por ejemplo si quisiéramos que RESULT almacenara varios números enteros hacemos una clase Nodo que contenga muchas variables de tipo entero y declaramos los no terminales para que sean de tipo Nodo, entonces el RESULT que sintetizarán dichos no terminales serán de tipo Nodo.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">start with ini; </span><br><span class="line"></span><br><span class="line">ini::=instrucciones;</span><br><span class="line"></span><br><span class="line">instrucciones ::= </span><br><span class="line">   instruccion instrucciones</span><br><span class="line"> | instruccion</span><br><span class="line"> | error instrucciones</span><br><span class="line">; </span><br><span class="line"></span><br><span class="line">instruccion ::= </span><br><span class="line">   REVALUAR CORIZQ expresion:a CORDER PTCOMA&#123;:System.out.println(<span class="string">&quot;El valor de la expresión es: &quot;</span>+a);:&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expresion  ::= </span><br><span class="line">    MENOS expresion:a                      &#123;:RESULT=a*-<span class="number">1</span>;:&#125;%prec UMENOS     </span><br><span class="line"> |  expresion:a MAS        expresion:b     &#123;:RESULT=a+b;:&#125;</span><br><span class="line"> |  expresion:a MENOS      expresion:b     &#123;:RESULT=a-b;:&#125;</span><br><span class="line"> |  expresion:a POR        expresion:b     &#123;:RESULT=a*b;:&#125;</span><br><span class="line"> |  expresion:a DIVIDIDO   expresion:b     &#123;:RESULT=a/b;:&#125;</span><br><span class="line"> |  ENTERO:a                               &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  DECIMAL:a                              &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  PARIZQ expresion:a PARDER              &#123;:RESULT=a;:&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="Incluir-JLex-para-generar-el-analizador-lexico-de-nuestro-proyecto"><a href="#Incluir-JLex-para-generar-el-analizador-lexico-de-nuestro-proyecto" class="headerlink" title="Incluír JLex para generar el analizador léxico de nuestro proyecto"></a><strong>Incluír JLex para generar el analizador léxico de nuestro proyecto</strong></h3><p>Creamos un paquete llamado JLex dentro del paquete analizadores, este almacenará la herramienta JLex (Clic derecho en el paquete analizadores → New → Java Package).</p>


<p>En la carpeta del paquete JLex copiamos el archivo Main.java que descargamos de la página oficial de JLex.</p>




<h3 id="Incluir-Cup-para-generar-el-analizador-sintactico-de-nuestro-proyecto"><a href="#Incluir-Cup-para-generar-el-analizador-sintactico-de-nuestro-proyecto" class="headerlink" title="Incluír Cup para generar el analizador sintáctico de nuestro proyecto"></a><strong>Incluír Cup para generar el analizador sintáctico de nuestro proyecto</strong></h3><p>Creamos un paquete llamado Cup dentro del paquete analizadores, este almacenará la herramienta Cup (Clic derecho en el paquete analizadores → New → Java Package).</p>


<p>En la carpeta del paquete Cup copiamos el archivo “java-cup-11b-runtime.jar” que descargamos de la página oficial de Cup.</p>




<h3 id="El-archivo-de-compilacion"><a href="#El-archivo-de-compilacion" class="headerlink" title="El archivo de compilación"></a><strong>El archivo de compilación</strong></h3><p>En el archivo “compilar.bat”, ejecutamos tres líneas, la primera indica a compila Main.java para poder disponer de la herramienta para generar nuestro analizador léxico, la segunda le indica a la herramienta Jlex que debe generar un analizador léxico en base al código fuente que se encuentra en el archivo “Lexico”, la tercera indica a Cup que la clase que debe generar para el analizador sintáctico se llamará “Sintactico” y que debe generarse en base al código fuente que se encuentra en el archivo “Sintactico”.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac JLex/Main.java</span><br><span class="line">java JLex.Main Lexico</span><br><span class="line">java -jar Cup/java-cup-11b.jar -parser Sintactico Sintactico</span><br></pre></td></tr></table></figure>

<p>Para ejecutarlo solo vamos a Netbeans, damos clic derecho sobre el archivo y seleccionamos la opción Run. Al finalizar la ejecución del archivo, veremos en la consola de Netbeans una salida como la siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">&#x27;C:/Users/erick/OneDrive/Documentos/NetBeansProjects/ProyectoCupJlexWindows/src/analizadores&#x27;</span></span><br><span class="line">C:/Users/erick/OneDrive/Documentos/NetBeansProjects/ProyectoCupJlexWindows/src/analizadores/compilar.bat </span><br><span class="line"></span><br><span class="line">C:\Users\erick\OneDrive\Documentos\NetBeansProjects\ProyectoCupJlexWindows\src\analizadores&gt;javac JLex/Main.java </span><br><span class="line">Note: JLex\Main.java uses unchecked or unsafe operations.</span><br><span class="line">Note: Recompile with -Xlint:unchecked <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">C:\Users\erick\OneDrive\Documentos\NetBeansProjects\ProyectoCupJlexWindows\src\analizadores&gt;java JLex.Main Lexico </span><br><span class="line">Processing first section -- user code.</span><br><span class="line">Processing second section -- JLex declarations.</span><br><span class="line">Processing third section -- lexical rules.</span><br><span class="line">Creating NFA machine representation.</span><br><span class="line">NFA comprised of 67 states.</span><br><span class="line">Working on character classes.:::::.:::::::::::::.:::.</span><br><span class="line">NFA has 24 distinct character classes.</span><br><span class="line">Creating DFA transition table.</span><br><span class="line">Working on DFA states...........................</span><br><span class="line">Minimizing DFA transition table.</span><br><span class="line">24 states after removal of redundant states.</span><br><span class="line">Outputting lexical analyzer code.</span><br><span class="line"></span><br><span class="line">C:\Users\erick\OneDrive\Documentos\NetBeansProjects\ProyectoCupJlexWindows\src\analizadores&gt;java -jar Cup/java-cup-11b.jar -parser Sintactico Sintactico </span><br><span class="line">------- CUP v0.11b 20160615 (GIT 4ac7450) Parser Generation Summary -------</span><br><span class="line">  0 errors and 0 warnings</span><br><span class="line">  15 terminals, 4 non-terminals, and 14 productions declared, </span><br><span class="line">  producing 28 unique parse states.</span><br><span class="line">  0 terminals declared but not used.</span><br><span class="line">  0 non-terminals declared but not used.</span><br><span class="line">  0 productions never reduced.</span><br><span class="line">  0 conflicts detected (0 expected).</span><br><span class="line">  Code written to <span class="string">&quot;Sintactico.java&quot;</span>, and <span class="string">&quot;sym.java&quot;</span>.</span><br><span class="line">---------------------------------------------------- (CUP v0.11b 20160615 (GIT 4ac7450))</span><br><span class="line"></span><br><span class="line">RUN SUCCESSFUL (total <span class="keyword">time</span>: 3s)</span><br></pre></td></tr></table></figure>

<p>Que nos confirma que la generación del analizador léxico fue exitosa y que la del analizador sintáctico también. Veremos que se han creado tres nuevos archivos en el paquete analizadores. Estos archivos son las clases: Lexico.java, Sintactico.java y sym.java.</p>


<p>La clase sym.java, sirve como puente entre la clase Lexico.java y Sintactico.java, por ejemplo, cuando el analizador léxico reconoce un número entero, instancia un objeto de la clase Symbol e indica que es de tipo número entero por medio de la constante “sym.ENTERO”, que se genera dentro de la clase sym.java y esta constante se genera porque en el archivo de entrada para Cup se indicó que existe un terminal llamado ENTERO. Entonces tanto el analizador léxico como el sintáctico hacen referencia a los tokens de tipo número entero con la constante “sym.ENTERO”. Básicamente eso es sym.java, una clase con muchas constantes estáticas a las que acceden ambos analizadores para poder integrarse y ejecutar sus tareas exitosamente.</p>
<h3 id="Creando-un-archivo-de-entrada-para-nuestros-analizadores"><a href="#Creando-un-archivo-de-entrada-para-nuestros-analizadores" class="headerlink" title="Creando un archivo de entrada para nuestros analizadores"></a><strong>Creando un archivo de entrada para nuestros analizadores</strong></h3><p>Dentro de la carpeta del proyecto crearé un archivo de entrada llamado “entrada.txt”. Que contendrá el archivo de entrada que reconocerán nuestros analizadores.</p>


<p>El archivo de “entrada.txt” contiene lo siguiente:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[<span class="number">1</span>+<span class="number">1</span>];</span><br><span class="line">Evaluar[<span class="number">1</span>+<span class="number">1</span>*<span class="number">2</span>];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>*<span class="number">6</span>/<span class="number">3</span>-<span class="number">5</span>+<span class="number">7</span>)];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>*<span class="number">6</span>/<span class="number">3</span>-<span class="number">5</span>+<span class="number">1</span>*-<span class="number">2</span>)];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>)];</span><br></pre></td></tr></table></figure>

<h3 id="Clase-principal"><a href="#Clase-principal" class="headerlink" title="Clase principal"></a><strong>Clase principal</strong></h3><p>Dentro de la clase principal solo tenemos el método <em>main</em> y el método interpretar que lee el contenido del archivo que se encuentra en el path que se le indica y ejecuta análisis léxico y análisis sintáctico, en el transcurso del analisis sintáctico se mandan a imprimir en consola los resultados de las expresiones aritméticas analizadas, por lo que al final del análisis tendremos todos los resultados de las operaciones en consola. A continuación se muestra el código de la clase principal.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io</span></span><br><span class="line"><span class="comment"> * Julio - 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> proyectocupjlexwindows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clase principal de la aplicación</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Erick</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProyectoCupJlexWindows</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args argumentos de la linea de comando</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        interpretar(<span class="string">&quot;entrada.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método que interpreta el contenido del archivo que se encuentra en el path</span></span><br><span class="line"><span class="comment">     * que recibe como parámentro</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path ruta del archivo a interpretar</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">interpretar</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        analizadores.Sintactico pars;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pars=<span class="keyword">new</span> <span class="title class_">analizadores</span>.Sintactico(<span class="keyword">new</span> <span class="title class_">analizadores</span>.Lexico(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path)));</span><br><span class="line">            pars.parse();        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error fatal en compilación de entrada.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Causa: &quot;</span>+ex.getCause());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ejecutando-nuestra-aplicacion"><a href="#Ejecutando-nuestra-aplicacion" class="headerlink" title="Ejecutando nuestra aplicación"></a><strong>Ejecutando nuestra aplicación</strong></h3><p>Al ejecutar la aplicación obtenemos los resultados de las operaciones evaluadas en consola.</p>


<p>Si les gusto este tutorial, puede que también estén interesados en este otro: <a href="/2019/04/26/05-Interprete-sencillo-utilizando-Java-Jlex-y-Cup/" title="Intérprete sencillo utilizando Java, Jlex y Cup">Intérprete sencillo utilizando Java, Jlex y Cup</a>.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-25T21:32:08.000Z" title="4/25/2019, 3:32:08 PM">2019-04-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/25/01-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Linux/">Mi primer proyecto utilizando Jlex y Cup (Linux)</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presenta como salida el resultado de dichas expresiones.</p>
<p>Las tecnologías a utilizar son:</p>
<ul>
<li><p><strong>Jlex</strong>: Generador de analizadores léxicos</p>
</li>
<li><p><strong>Cup</strong>: Generador de analizadores sintácticos</p>
</li>
<li><p><strong>Ubuntu 14.04</strong>: Sistema operativo basado en GNU&#x2F;Linux</p>
</li>
<li><p><strong>Netbeans 8.0</strong>: IDE (entorno de desarrollo integrado)</p>
</li>
</ul>
<p>El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoCupJlex">Mi primer proyecto utilizando Jlex y Cup (Linux)</a></li>
</ul>
<h3 id="JLex"><a href="#JLex" class="headerlink" title="JLex"></a><strong>JLex</strong></h3><p>JLex es un generador de analizadores léxicos, escrito en Java, para Java. JLex fue desarrollado por Elliot Berk en la Universidad de Princeton. Para más información visitar la <a target="_blank" rel="noopener" href="https://www.cs.princeton.edu/~appel/modern/java/JLex/">página oficial de JLex</a>.<br>La principal tarea de un analizador léxico es leer los caracteres de entrada del programa fuente, agruparlos en lexemas y producir como salida una secuencia de tokens.</p>
<ul>
<li><p>Un <em>token</em> es un par que consiste en un nombre de token y un valor de atributo opcional.</p>
</li>
<li><p>Un <em>lexema</em> es una secuencia de caracteres en el programa fuente, que coinciden con el patrón para un token y que el analizador léxico identifica como una instancia de este tóken.</p>
</li>
<li><p>Un <em>patrón</em> es una descripción de la forma que pueden tomar los lexemas de un token.</p>
</li>
</ul>
<p>En JLex se definen los patrones de los diferentes tokens que se desean reconocer, estos patrones pueden definirse a través de expresiones regulares. Además JLex cuenta con múltiples opciones, una muy imporante es su capacidad para integrarse con generadores de analizadores sintácticos como Cup.</p>
<h3 id="Cup"><a href="#Cup" class="headerlink" title="Cup"></a><strong>Cup</strong></h3><p><a target="_blank" rel="noopener" href="http://www2.cs.tum.edu/projects/cup/">Cup</a> es un generador de analizadores sintácticos de tipo LALR para Java.</p>
<p>El analizador sintáctico obtiene una cadena de tokens del analizador léxico y verifica que dicha cadena pueda generase con la gramática para el lenguaje fuente. Una gramática proporciona una especificación precisa y fácil de entender de un lenguaje de programación.</p>
<h3 id="Pre-requisitos"><a href="#Pre-requisitos" class="headerlink" title="Pre-requisitos"></a><strong>Pre-requisitos</strong></h3><p>Para este ejemplo hace falta que tengamos instalado:</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Java Development Kit (JDK)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://netbeans.org/downloads/">Netbeans</a></p>
</li>
</ul>
<h3 id="Instalacion-y-configuracion-de-las-herramientas"><a href="#Instalacion-y-configuracion-de-las-herramientas" class="headerlink" title="Instalación y configuración de las herramientas"></a><strong>Instalación y configuración de las herramientas</strong></h3><p>Lo primero que haremos será instalar JLex, para ello abrimos una terminal, en Ubuntu puede hacerse con la combinación de teclas Ctrl+Alt+t o en Aplicaciones → Accesorios → Terminal, una vez abierta la terminal ingresamos el comando “sudo apt-get install jlex”, autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado JLex.</p>


<p>Luego instalamos cup, ejecutando en la terminal el comando “sudo apt-get install cup”, autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado Cup.</p>


<p>Abrimos Netbeans y creamos un nuevo proyecto de Java (File → New Project).</p>




<p>Creamos un paquete llamado analizadores, este almacenará todo el código fuente relacionado con el analizador léxico y sintáctico (Clic derecho en Source Packages → New → Java Package).</p>




<p>Creamos tres archivos en el paquete analizadores, el primero “Lexico”, que almacenará el código fuente con el cual JLex generará el analizador léxico que queremos, el segundo “Sintactico”, que almacenará el código fuente con el cual Cup generará el analizador sintáctico que queremos y el tercero “compilar.sh”, que guardará los comandos que deben ejecutarse para solicitarle a JLex y a Cup que generen los analizadores. Para crear cada uno de los archivos hacemos clic derecho en el paquete analizadores → New → Other → en la ventana que despliegue, seleccionar Categories: Other y File Types: Empty File, seleccionamos siguiente, indicamos el nombre para el archivo y finalizamos. De tal modo que al final tendremos los tres archivos archivos.</p>


<p>Ahora importaremos la llibrería de Cup a nuestro proyecto de netbeans, para ello descargamos el archivo “java-cup-bin-11b-&lt;versión&gt;.tar.gz” de la <a target="_blank" rel="noopener" href="http://www2.cs.tum.edu/projects/cup/">página oficial de Cup</a>. En este caso el archivo descargado fue el “java-cup-bin-11b-20150326.tar.gz”.</p>


<p>Lo descomprimimos y veremos que contiene dos archivos .jar, el que nos interesa es el archivo “java-cup-11b-runtime.jar”.</p>


<p>Creamos una carpeta lib dentro de la carpeta de nuestro proyecto.</p>


<p>Dentro de la carpeta lib pegamos el archivo “java-cup-11b-runtime.jar”.</p>


<p>Para importar el archivo jar, vamos a Netbeans y damos clic derecho en la pestaña Libraries de nuestro proyecto → Add JAR&#x2F;Folder… luego buscamos el archivo jar en la carpeta lib que acabamos de crear y lo seleccionamos.</p>


<h3 id="Codigo-fuente-para-el-analizador-lexico"><a href="#Codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Código fuente para el analizador léxico"></a><strong>Código fuente para el analizador léxico</strong></h3><p>En el archivo “Lexico” incluiremos todo el código que le indicará a Jlex lo que debe hacer. El código se muestra a continuación:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io</span></span><br><span class="line"><span class="comment"> * Septiembre - 2015</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> analizadores;</span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.Symbol; </span><br><span class="line"></span><br><span class="line">%% </span><br><span class="line">%<span class="keyword">class</span> <span class="title class_">Lexico</span></span><br><span class="line">%<span class="keyword">public</span> </span><br><span class="line">%line </span><br><span class="line">%<span class="type">char</span> </span><br><span class="line">%cup </span><br><span class="line">%unicode</span><br><span class="line">%ignorecase</span><br><span class="line"></span><br><span class="line">%init&#123; </span><br><span class="line">	yyline = <span class="number">1</span>; </span><br><span class="line">	yychar = <span class="number">1</span>; </span><br><span class="line">%init&#125; </span><br><span class="line"></span><br><span class="line">BLANCOS=[ \r\t]+</span><br><span class="line">D=[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">DD=[<span class="number">0</span>-<span class="number">9</span>]+(<span class="string">&quot;.&quot;</span>[  |<span class="number">0</span>-<span class="number">9</span>]+)?</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Evaluar&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.REVALUAR,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;;&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PTCOMA,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;(&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;)&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARDER,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;[&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;]&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORDER,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;+&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MAS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;-&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MENOS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;*&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.POR,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;/&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DIVIDIDO,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">\n &#123;yychar=<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#123;BLANCOS&#125; &#123;&#125; </span><br><span class="line">&#123;D&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.ENTERO,yyline,yychar, yytext());&#125; </span><br><span class="line">&#123;DD&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DECIMAL,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Este es un error lexico: &quot;</span>+yytext()+</span><br><span class="line">	<span class="string">&quot;, en la linea: &quot;</span>+yyline+<span class="string">&quot;, en la columna: &quot;</span>+yychar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-lexico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Explicación del código fuente para el analizador léxico"></a><strong>Explicación del código fuente para el analizador léxico</strong></h3><p>En las primeras líneas indicamos a Jlex que la clase estará en el paquete analizadores y que es necesario que se importe la clase Symbol.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> analizadores;</span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.Symbol;</span><br></pre></td></tr></table></figure>
<p>Posteriormente indicamos a Jlex que:</p>
<ul>
<li><p>La clase del analizador se llamará “Lexico”</p>
</li>
<li><p>La clase será pública</p>
</li>
<li><p>Debe llevar el conteo de las líneas</p>
</li>
<li><p>Debe llevar el conteo de los caracteres reconocidos</p>
</li>
<li><p>Debe integrarse con cup</p>
</li>
<li><p>El set de caracteres que debe utilizar es el unicode</p>
</li>
<li><p>El analizador no será case sensitive, es decir, no le importa si las letras son mayúsculas o minúsculas</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%% </span><br><span class="line">%<span class="keyword">class</span> <span class="title class_">Lexico</span></span><br><span class="line">%<span class="keyword">public</span> </span><br><span class="line">%line </span><br><span class="line">%<span class="type">char</span> </span><br><span class="line">%cup </span><br><span class="line">%unicode</span><br><span class="line">%ignorecase</span><br></pre></td></tr></table></figure>

<p>Luego viene el bloque init, dentro del init, se ejecutan las acciones de inicialización, es decir, lo que va dentro del constructor del analizador léxico.En este caso indicamos dentro del init que:</p>
<ul>
<li><p>La variable yyline, que lleva la cuenta del número de linea por el que va el analizador valdrá inicialmente 1.</p>
</li>
<li><p>La variable yychar, que lleva la cuenta del número de carácter por el que va el analizador valdrá inicialmente 1.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%init&#123; </span><br><span class="line">	yyline = <span class="number">1</span>; </span><br><span class="line">	yychar = <span class="number">1</span>; </span><br><span class="line">%init&#125;</span><br></pre></td></tr></table></figure>

<p>Luego se escriben algunas expresiones regulares que son almacenadas en macros, que básicamente son variables que almacenan los patrones, en este caso se definen las macros: BLANCOS, D y DD. Los patrones para cada una son los siguientes:</p>
<ul>
<li><p>BLANCOS: Expresión regular que reconoce uno o muchos espacios en blanco, retornos de carro o tabuladores.</p>
</li>
<li><p>D: Expresión regular que reconoce números enteros.</p>
</li>
<li><p>DD: Expresión regular que reconoce números con punto decimal.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BLANCOS=[ \r\t]+</span><br><span class="line">D=[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">DD=[<span class="number">0</span>-<span class="number">9</span>]+(<span class="string">&quot;.&quot;</span>[  |<span class="number">0</span>-<span class="number">9</span>]+)?</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<p>Por último se definen todas las reglas léxicas, en las que indicamos los patrones que reconocerá y dentro de llaves lo que debe hacer cuando los reconozca. En la mayoría de los casos se retorna un objeto de tipo Symbol, que vendría siendo un token, este se instancia con el tipo, la fila en la que se encontró, la columna en la que se encontró y el lexema en específico que se reconoció, este se obtiene mediante yytext(). Dentro de las llaves podríamos incluir el código java que quisiéramos. Vemos que al reconocer el patrón BLANCOS no se hace nada porque esperamos que ignore los espacios en blanco. También vemos que al encontrar un salto de linea reinicia la variable yychar, es decir, reinicia el conteo de caracteres para que se lleve la cuenta del número de columna en cada fila.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Evaluar&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.REVALUAR,yyline,yychar,</span><br><span class="line">                             yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;;&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PTCOMA,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;(&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;)&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARDER,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;[&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;]&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORDER,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;+&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MAS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;-&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MENOS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;*&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.POR,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;/&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DIVIDIDO,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">\n &#123;yychar=<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#123;BLANCOS&#125; &#123;&#125; </span><br><span class="line">&#123;D&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.ENTERO,yyline,yychar, yytext());&#125; </span><br><span class="line">&#123;DD&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DECIMAL,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Este es un error lexico: &quot;</span>+yytext()+</span><br><span class="line">    <span class="string">&quot;, en la linea: &quot;</span>+yyline+<span class="string">&quot;, en la columna: &quot;</span>+yychar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Codigo-fuente-para-el-analizador-sintactico"><a href="#Codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Código fuente para el analizador sintáctico"></a><strong>Código fuente para el analizador sintáctico</strong></h3><p>En el archivo “Sintáctico” incluiremos todo el código que le indicará a Cup lo que debe hacer. El código se muestra a continuación:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io</span></span><br><span class="line"><span class="comment"> * Septiembre - 2015</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> analizadores; </span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.*;</span><br><span class="line"></span><br><span class="line">parser code </span><br><span class="line">&#123;:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintactico.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syntax_error</span><span class="params">(Symbol s)</span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error Sintáctico en la Línea &quot;</span> + (s.left) +</span><br><span class="line">        <span class="string">&quot; Columna &quot;</span>+s.right+ <span class="string">&quot;. No se esperaba este componente: &quot;</span> +s.value+<span class="string">&quot;.&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintáctico </span></span><br><span class="line"><span class="comment">     * en el que ya no es posible una recuperación de errores.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unrecovered_syntax_error</span><span class="params">(Symbol s)</span> <span class="keyword">throws</span> java.lang.Exception&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error síntactico irrecuperable en la Línea &quot;</span> + </span><br><span class="line">        (s.left)+ <span class="string">&quot; Columna &quot;</span>+s.right+<span class="string">&quot;. Componente &quot;</span> + s.value + </span><br><span class="line">        <span class="string">&quot; no reconocido.&quot;</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">:&#125; </span><br><span class="line"></span><br><span class="line">terminal String PTCOMA,PARIZQ,PARDER,CORIZQ,CORDER;</span><br><span class="line">terminal String MAS,MENOS,POR,DIVIDIDO;</span><br><span class="line">terminal String ENTERO;</span><br><span class="line">terminal String DECIMAL;</span><br><span class="line">terminal String UMENOS;</span><br><span class="line">terminal String REVALUAR;</span><br><span class="line"></span><br><span class="line">non terminal ini;</span><br><span class="line">non terminal instrucciones;</span><br><span class="line">non terminal instruccion;</span><br><span class="line">non terminal Double expresion;</span><br><span class="line"></span><br><span class="line">precedence left MAS,MENOS;</span><br><span class="line">precedence left POR,DIVIDIDO;</span><br><span class="line">precedence right UMENOS; </span><br><span class="line"></span><br><span class="line">start with ini; </span><br><span class="line"></span><br><span class="line">ini::=instrucciones;</span><br><span class="line"></span><br><span class="line">instrucciones ::= </span><br><span class="line">   instruccion instrucciones</span><br><span class="line"> | instruccion</span><br><span class="line"> | error instrucciones</span><br><span class="line">; </span><br><span class="line"></span><br><span class="line">instruccion ::= </span><br><span class="line">   REVALUAR CORIZQ expresion:a CORDER PTCOMA&#123;:System.out.println(<span class="string">&quot;El valor de la expresión es: &quot;</span>+a);:&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expresion  ::= </span><br><span class="line">    MENOS expresion:a                      &#123;:RESULT=a*-<span class="number">1</span>;:&#125;%prec UMENOS     </span><br><span class="line"> |  expresion:a MAS        expresion:b     &#123;:RESULT=a+b;:&#125;</span><br><span class="line"> |  expresion:a MENOS      expresion:b     &#123;:RESULT=a-b;:&#125;</span><br><span class="line"> |  expresion:a POR        expresion:b     &#123;:RESULT=a*b;:&#125;</span><br><span class="line"> |  expresion:a DIVIDIDO   expresion:b     &#123;:RESULT=a/b;:&#125;</span><br><span class="line"> |  ENTERO:a                               &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  DECIMAL:a                              &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  PARIZQ expresion:a PARDER              &#123;:RESULT=a;:&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-sintactico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Explicación del código fuente para el analizador sintáctico"></a><strong>Explicación del código fuente para el analizador sintáctico</strong></h3><p>En las primeras líneas indicamos a Cup que la clase estará en el paquete analizadores y que es necesario que se importe todo el contenido de “java_cup.runtime”.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> analizadores; </span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.*;</span><br></pre></td></tr></table></figure>
<p>Luego viene la sección “parser code”, en la que se programan acciones propias del parser o analizador sintáctico que se va a generar, en este caso se programa lo que se debe hacer ante un error sintáctico y ante un error sintáctico irrecuperable.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">parser code </span><br><span class="line">&#123;:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintactico.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syntax_error</span><span class="params">(Symbol s)</span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error Sintáctico en la Línea &quot;</span> + (s.left) +</span><br><span class="line">        <span class="string">&quot; Columna &quot;</span>+s.right+ <span class="string">&quot;. No se esperaba este componente: &quot;</span> +s.value+<span class="string">&quot;.&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintáctico </span></span><br><span class="line"><span class="comment">     * en el que ya no es posible una recuperación de errores.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unrecovered_syntax_error</span><span class="params">(Symbol s)</span> <span class="keyword">throws</span> java.lang.Exception&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error síntactico irrecuperable en la Línea &quot;</span> + </span><br><span class="line">        (s.left)+ <span class="string">&quot; Columna &quot;</span>+s.right+<span class="string">&quot;. Componente &quot;</span> + s.value + </span><br><span class="line">        <span class="string">&quot; no reconocido.&quot;</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">:&#125;</span><br></pre></td></tr></table></figure>

<p>Luego se definen los terminales, a estos se les puede indicar un tipo, en este caso todos son de tipo *String, *si no se indicara un tipo, los terminales serían por defecto de tipo <em>Object</em>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">terminal String PTCOMA,PARIZQ,PARDER,CORIZQ,CORDER;</span><br><span class="line">terminal String MAS,MENOS,POR,DIVIDIDO;</span><br><span class="line">terminal String ENTERO;</span><br><span class="line">terminal String DECIMAL;</span><br><span class="line">terminal String UMENOS;</span><br><span class="line">terminal String REVALUAR;</span><br></pre></td></tr></table></figure>

<p>Existe un terminal por cada tipo de token que el analizador léxico devuelve. Todos estos tipos estarán definidos en la clase “sym”, que se genera automáticamente y de la que se hablará más adelante.</p>
<p>Luego viene la declaración de los no terminales, a los que también se les puede indicar un tipo específico, si no se les indica un tipo, estos son por defecto de tipo <em>Object</em>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">non terminal ini;</span><br><span class="line">non terminal instrucciones;</span><br><span class="line">non terminal instruccion;</span><br><span class="line">non terminal Double expresion;</span><br></pre></td></tr></table></figure>

<p>Posteriormente, podemos indicar la precedencia de los operadores, ya que la gramática escrita es ambigua, es necesario definir una precedencia para que el analizador no entre en conflicto al analizar, en este caso la precedencia es la misma que la de los operadores aritméticos, la precedencia más baja la tienen la suma y la resta, luego están la multiplicación y la división que tienen una precedencia más alta y por último está el signo menos de las expresiones negativas que tendría la precedencia más alta.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">precedence left MAS,MENOS;</span><br><span class="line">precedence left POR,DIVIDIDO;</span><br><span class="line">precedence right UMENOS;</span><br></pre></td></tr></table></figure>

<p>Por último viene el conjunto de reglas de escritura de la gramática o producciones, al final de cada producción puede incluirse código java entre llaves y dos puntos “{:&lt;código java&gt;:}”. Podemos ver que en las producciones del no terminal “expresion”, se utiliza la variable RESULT, esta variable es propia de Cup y nos permite sintetizar cierto atributo para ese no terminal que se encuentra del lado izquierdo de la producción, recordemos que Cup trabaja con analizadores LALR, que son de tipo ascendente, lo que significa que nos permiten manipular atributos sintetizados. Básicamente eso es RESULT, un atributo sintetizado.</p>
<p>RESULT puede ser cualquier objeto, por ejemplo si quisiéramos que RESULT almacenara varios números enteros hacemos una clase Nodo que contenga muchas variables de tipo entero y declaramos los no terminales para que sean de tipo Nodo, entonces el RESULT que sintetizarán dichos no terminales serán de tipo Nodo.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">start with ini; </span><br><span class="line"></span><br><span class="line">ini::=instrucciones;</span><br><span class="line"></span><br><span class="line">instrucciones ::= </span><br><span class="line">   instruccion instrucciones</span><br><span class="line"> | instruccion</span><br><span class="line"> | error instrucciones</span><br><span class="line">; </span><br><span class="line"></span><br><span class="line">instruccion ::= </span><br><span class="line">   REVALUAR CORIZQ expresion:a CORDER PTCOMA&#123;:System.out.println(<span class="string">&quot;El valor de la expresión es: &quot;</span>+a);:&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expresion  ::= </span><br><span class="line">    MENOS expresion:a                      &#123;:RESULT=a*-<span class="number">1</span>;:&#125;%prec UMENOS     </span><br><span class="line"> |  expresion:a MAS        expresion:b     &#123;:RESULT=a+b;:&#125;</span><br><span class="line"> |  expresion:a MENOS      expresion:b     &#123;:RESULT=a-b;:&#125;</span><br><span class="line"> |  expresion:a POR        expresion:b     &#123;:RESULT=a*b;:&#125;</span><br><span class="line"> |  expresion:a DIVIDIDO   expresion:b     &#123;:RESULT=a/b;:&#125;</span><br><span class="line"> |  ENTERO:a                               &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  DECIMAL:a                              &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  PARIZQ expresion:a PARDER              &#123;:RESULT=a;:&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="El-archivo-de-compilacion"><a href="#El-archivo-de-compilacion" class="headerlink" title="El archivo de compilación"></a><strong>El archivo de compilación</strong></h3><p>En el archivo “compilar.sh”, ejecutamos dos líneas, la primera indica a Jlex que debe generar un analizador léxico en base al código fuente que se encuentra en el archivo “Lexico”, la segunda indica a Cup que la clase que debe generar para el analizador sintáctico se llamará “Sintactico” y que debe generarse en base al código fuente que se encuentra en el archivo “Sintactico”.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jlex Lexico</span><br><span class="line">cup -parser Sintactico Sintactico</span><br></pre></td></tr></table></figure>

<p>Para ejecutarlo solo vamos a Netbeans, damos clic derecho sobre el archivo y seleccionamos la opción Run. Al finalizar la ejecución del archivo, veremos en la consola de Netbeans una salida como la siguiente:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Processing first section -- user code.</span><br><span class="line">Processing second section -- JLex declarations.</span><br><span class="line">Processing third section -- lexical rules.</span><br><span class="line">Creating NFA machine representation.</span><br><span class="line">NFA comprised of <span class="number">67</span> states.</span><br><span class="line">Working on character classes.:::::.:::::::::::::.:::.</span><br><span class="line">NFA has <span class="number">24</span> distinct character classes.</span><br><span class="line">Creating DFA transition table.</span><br><span class="line">Working on DFA states...........................</span><br><span class="line">Minimizing DFA transition table.</span><br><span class="line"><span class="number">24</span> states after removal of redundant states.</span><br><span class="line">Outputting lexical analyzer code.</span><br><span class="line">------- CUP v0.11a beta <span class="number">20060608</span> Parser Generation Summary -------</span><br><span class="line">  <span class="number">0</span> errors and <span class="number">0</span> warnings</span><br><span class="line">  <span class="number">15</span> terminals, <span class="number">4</span> non-terminals, and <span class="number">14</span> productions declared, </span><br><span class="line">  producing <span class="number">28</span> unique parse states.</span><br><span class="line">  <span class="number">0</span> terminals declared but not used.</span><br><span class="line">  <span class="number">0</span> non-terminals declared but not used.</span><br><span class="line">  <span class="number">0</span> productions never reduced.</span><br><span class="line">  <span class="number">0</span> conflicts <span class="title function_">detected</span> <span class="params">(<span class="number">0</span> expected)</span>.</span><br><span class="line">  Code written to <span class="string">&quot;Sintactico.java&quot;</span>, and <span class="string">&quot;sym.java&quot;</span>.</span><br><span class="line">---------------------------------------------------- (v0.11a beta <span class="number">20060608</span>)</span><br><span class="line"></span><br><span class="line">RUN <span class="title function_">SUCCESSFUL</span> <span class="params">(total time: 757ms)</span></span><br></pre></td></tr></table></figure>

<p>Que nos confirma que la generación del analizador léxico fue exitosa y que la del analizador sintáctico también. Veremos que se han creado tres nuevos archivos en el paquete analizadores. Estos archivos son las clases: Lexico.java, Sintactico.java y sym.java.</p>


<p>La clase sym.java, sirve como puente entre la clase Lexico.java y Sintactico.java, por ejemplo, cuando el analizador léxico reconoce un número entero, instancia un objeto de la clase Symbol e indica que es de tipo número entero por medio de la constante “sym.ENTERO”, que se genera dentro de la clase sym.java y esta constante se genera porque en el archivo de entrada para Cup se indicó que existe un terminal llamado ENTERO. Entonces tanto el analizador léxico como el sintáctico hacen referencia a los tokens de tipo número entero con la constante “sym.ENTERO”. Básicamente eso es sym.java, una clase con muchas constantes estáticas a las que acceden ambos analizadores para poder integrarse y ejecutar sus tareas exitosamente.</p>
<h3 id="Archivo-de-entrada"><a href="#Archivo-de-entrada" class="headerlink" title="Archivo de entrada"></a><strong>Archivo de entrada</strong></h3><p>Dentro de la carpeta del proyecto crearé un archivo de entrada llamado “entrada.txt”. Que contendrá el archivo de entrada que reconocerán nuestros analizadores.</p>


<p>El archivo de “entrada.txt” contiene lo siguiente:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[<span class="number">1</span>+<span class="number">1</span>];</span><br><span class="line">Evaluar[<span class="number">1</span>+<span class="number">1</span>*<span class="number">2</span>];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>*<span class="number">6</span>/<span class="number">3</span>-<span class="number">5</span>+<span class="number">7</span>)];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>*<span class="number">6</span>/<span class="number">3</span>-<span class="number">5</span>+<span class="number">1</span>*-<span class="number">2</span>)];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>)];</span><br></pre></td></tr></table></figure>

<h3 id="Clase-principal"><a href="#Clase-principal" class="headerlink" title="Clase principal"></a><strong>Clase principal</strong></h3><p>Dentro de la clase principal solo tenemos el método <em>main</em> y el método interpretar que lee el contenido del archivo que se encuentra en el path que se le indica y ejecuta análisis léxico y análisis sintáctico, en el transcurso del analisis sintáctico se mandan a imprimir en consola los resultados de las expresiones aritméticas analizadas, por lo que al final del análisis tendremos todos los resultados de las operaciones en consola. A continuación se muestra el código de la clase principal.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io</span></span><br><span class="line"><span class="comment"> * Septiembre - 2015</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> proyectocupjlex;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clase principal de la aplicación</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Erick</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProyectoCupJlex</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args argumentos de la linea de comando</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        interpretar(<span class="string">&quot;entrada.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método que interpreta el contenido del archivo que se encuentra en el path</span></span><br><span class="line"><span class="comment">     * que recibe como parámentro</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path ruta del archivo a interpretar</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">interpretar</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        analizadores.Sintactico pars;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pars=<span class="keyword">new</span> <span class="title class_">analizadores</span>.Sintactico(<span class="keyword">new</span> <span class="title class_">analizadores</span>.Lexico(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path)));</span><br><span class="line">            pars.parse();        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error fatal en compilación de entrada.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Causa: &quot;</span>+ex.getCause());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ejecutando-nuestra-aplicacion"><a href="#Ejecutando-nuestra-aplicacion" class="headerlink" title="Ejecutando nuestra aplicación"></a><strong>Ejecutando nuestra aplicación</strong></h3><p>Al ejecutar la aplicación obtenemos los resultados de las operaciones evaluadas en consola.</p>


<p>Si les gusto este tutorial, puede que también estén interesados en este otro: <a href="/2019/04/26/05-Interprete-sencillo-utilizando-Java-Jlex-y-Cup/" title="Intérprete sencillo utilizando Java, Jlex y Cup">Intérprete sencillo utilizando Java, Jlex y Cup</a>.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Erick Navarro"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Erick Navarro</p><p class="is-size-6 is-block">Data Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Guatemala</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.linkedin.com/in/ericknd/" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ericknavarro"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LinkedIn" href="https://www.linkedin.com/in/ericknd/"><i class="fab fa-linkedin"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AWS/"><span class="level-start"><span class="level-item">AWS</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/AWS/Alexa-Skills/"><span class="level-start"><span class="level-item">Alexa Skills</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/CloudFront/"><span class="level-start"><span class="level-item">CloudFront</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/EC2/"><span class="level-start"><span class="level-item">EC2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/Lambda/"><span class="level-start"><span class="level-item">Lambda</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/Route-53/"><span class="level-start"><span class="level-item">Route 53</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/S3/"><span class="level-start"><span class="level-item">S3</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Computer-Science/"><span class="level-start"><span class="level-item">Computer Science</span></span><span class="level-end"><span class="level-item tag">19</span></span></a><ul><li><a class="level is-mobile" href="/categories/Computer-Science/Compilers/"><span class="level-start"><span class="level-item">Compilers</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Computer-Science/Data-Structures/"><span class="level-start"><span class="level-item">Data Structures</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Programming/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/2020/10/01/27-Mi-primer-proyecto-utilizando-Yacc-y-Lex/"><img src="/gallery/thumbnails/27.png" alt="Mi primer proyecto utilizando Yacc y Lex"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-10-01T21:03:28.000Z">2020-10-01</time></p><p class="title"><a href="/2020/10/01/27-Mi-primer-proyecto-utilizando-Yacc-y-Lex/">Mi primer proyecto utilizando Yacc y Lex</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/03/15/26-Interprete-sencillo-utilizando-PLY/"><img src="/gallery/thumbnails/26.png" alt="Intérprete sencillo utilizando PLY con Python 3"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-03-16T01:09:28.000Z">2020-03-15</time></p><p class="title"><a href="/2020/03/15/26-Interprete-sencillo-utilizando-PLY/">Intérprete sencillo utilizando PLY con Python 3</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/03/07/25-Interprete-sencillo-utilizando-Javacc/"><img src="/gallery/thumbnails/25.png" alt="Intérprete sencillo utilizando JavaCC"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-03-07T19:53:33.000Z">2020-03-07</time></p><p class="title"><a href="/2020/03/07/25-Interprete-sencillo-utilizando-Javacc/">Intérprete sencillo utilizando JavaCC</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/02/10/24-Mi-primer-proyecto-utilizando-PLY/"><img src="/gallery/thumbnails/24.png" alt="Mi primer proyecto utilizando PLY con Python 3"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-02-10T22:17:25.000Z">2020-02-10</time></p><p class="title"><a href="/2020/02/10/24-Mi-primer-proyecto-utilizando-PLY/">Mi primer proyecto utilizando PLY con Python 3</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/02/10/23-Mi-primer-proyecto-utilizando-JavaCC/"><img src="/gallery/thumbnails/23.png" alt="Mi primer proyecto utilizando JavaCC"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-02-10T22:14:34.000Z">2020-02-10</time></p><p class="title"><a href="/2020/02/10/23-Mi-primer-proyecto-utilizando-JavaCC/">Mi primer proyecto utilizando JavaCC</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">October 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">August 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">May 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">April 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Alexa-Skills/"><span class="tag">Alexa Skills</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C#</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CloudFront/"><span class="tag">CloudFront</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compilers/"><span class="tag">Compilers</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Data-Structures/"><span class="tag">Data Structures</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EC2/"><span class="tag">EC2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lambda/"><span class="tag">Lambda</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Route-53/"><span class="tag">Route 53</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/S3/"><span class="tag">S3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Visual-Basic/"><span class="tag">Visual Basic</span><span class="tag">4</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Erick Navarro" height="28"></a><p class="is-size-7"><span>&copy; 2025 Erick Navarro</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>