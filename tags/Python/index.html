<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: Python - Erick Navarro</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Erick Navarro"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Erick Navarro"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Erick Navarro"><meta property="og:url" content="https://ericknavarro.github.io/"><meta property="og:site_name" content="Erick Navarro"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://ericknavarro.github.io/img/og_image.png"><meta property="article:author" content="Erick Navarro"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ericknavarro.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ericknavarro.github.io"},"headline":"Erick Navarro","image":["https://ericknavarro.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Erick Navarro"},"publisher":{"@type":"Organization","name":"Erick Navarro","logo":{"@type":"ImageObject","url":"https://ericknavarro.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-145306707-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-145306707-1');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Erick Navarro" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Connect on LinkedIn" href="https://www.linkedin.com/in/ericknd/"><i class="fab fa-linkedin"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags/">Tags</a></li><li class="is-active"><a href="#" aria-current="page">Python</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-10-01T21:03:28.000Z" title="10/1/2020, 3:03:28 PM">2020-10-01</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/01/27-Mi-primer-proyecto-utilizando-Yacc-y-Lex/">Mi primer proyecto utilizando Yacc y Lex</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presenta como salida el resultado de dichas expresiones.</p>
<p>Las tecnologías a utilizar son:</p>
<ul>
<li><strong>Lex</strong>: Generador de analizadores léxicos</li>
<li><strong>Yacc</strong>: Generador de analizadores sintácticos</li>
<li><strong>Ubuntu 20.04</strong>: Sistema operativo</li>
<li><strong>Visual Studio Code</strong>: Editor de código fuente</li>
<li><strong>C</strong>: Lenguaje de programación</li>
</ul>
<p>El proyecto completo del ejemplo puede descargarse en el siguient enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC">Mi primer proyecto utilizando Yacc y Lex</a></li>
</ul>
<h3 id="Lex"><a href="#Lex" class="headerlink" title="Lex"></a><strong>Lex</strong></h3><p>Lex es una herramienta que permite generar analizadore léxicos a partir de un conjunto de reglas y expresiones regulares. Desarrollado por Eric Schmidt y Mike Lesk para los sistemas Unix. Escrito en C para C, su implementación para C++ es posible, aunque no es segura ya que está mas enfocado en el trabajo con C.<br>La principal tarea de un analizador léxico es leer los caracteres de entrada del programa fuente, agruparlos en lexemas y producir como salida una secuencia de tokens.</p>
<ul>
<li>Un <em>token</em> es un par que consiste en un nombre de token y un valor de atributo opcional.</li>
<li>Un <em>lexema</em> es una secuencia de caracteres en el programa fuente, que coinciden con el patrón para un token y que el analizador léxico identifica como una instancia de este token.</li>
<li>Un <em>patrón</em> es una descripción de la forma que pueden tomar los lexemas de un token.</li>
</ul>
<p>Para obtener más información de Lex, es recomendable visitar su <a target="_blank" rel="noopener" href="http://dinosaur.compilertools.net/lex">página oficial</a>.</p>
<h3 id="Yacc"><a href="#Yacc" class="headerlink" title="Yacc"></a><strong>Yacc</strong></h3><p>Yacc es un generador de analizadores sintácticos ascendentes escrito en C para C. Las siglas Yacc significan <em>Yet Another Compiler-Compiler</em>. Desarrollado por Stephen C. Jhonson en AT&amp;T para el sistema operativo Unix. </p>
<p>El analizador sintáctico obtiene una cadena de tokens del analizador léxico y verifica que dicha cadena pueda generase con la gramática para el lenguaje fuente. Una gramática proporciona una especificación precisa y fácil de entender de un lenguaje de programación.</p>
<p>Para obtener más información de Lex, es recomendable visitar su <a target="_blank" rel="noopener" href="http://dinosaur.compilertools.net/yacc">página oficial</a>.</p>
<h3 id="Pre-requisitos"><a href="#Pre-requisitos" class="headerlink" title="Pre-requisitos"></a><strong>Pre-requisitos</strong></h3><p>Para este ejemplo neceistamos las siguientes herramientas:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/">Compilador GCC</a></li>
<li><a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a> (o cualquier editor de texto de nuestro agrado)</li>
</ul>
<h3 id="Instalacion-y-configuracion-de-las-herramientas"><a href="#Instalacion-y-configuracion-de-las-herramientas" class="headerlink" title="Instalación y configuración de las herramientas"></a><strong>Instalación y configuración de las herramientas</strong></h3><p>Lo primero que haremos será instalar Lex, para ello abrimos una terminal, en Ubuntu puede hacerse con la combinación de teclas <strong>Ctrl + Alt + t</strong> o en <strong>Aplicaciones → Accesorios → Terminal</strong>, una vez abierta la terminal ingresamos el comando:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install flex</span><br></pre></td></tr></table></figure>
<p>Autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado <strong>Lex</strong>. Como nos pudimos dar cuenta, la instalación de Lex se hace a través Flex que es otra herramienta de analisis léxico. </p>


<p>Luego instalamos Yacc, ejecutando el comando: </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install bison</span><br></pre></td></tr></table></figure>
<p>Autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado <strong>Yacc</strong>. Como nos pudimos dar cuenta, la instalación de Yacc se hace a través de Bison que es otra herramienta de análisis sintáctico.</p>


<h3 id="Crear-nuestro-proyecto"><a href="#Crear-nuestro-proyecto" class="headerlink" title="Crear nuestro proyecto"></a><strong>Crear nuestro proyecto</strong></h3><p>Creamos un nuevo folder el cual será nuestro espacio de trabajo, para crearlo abrimos una terminal y ejecutamos el comando:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ProyectoLexYacc</span><br></pre></td></tr></table></figure>
<p>Luego ingresamos a nuestro folder con el comando:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ProyectoLexYacc</span><br></pre></td></tr></table></figure>




<p>Ahora nos pasamos a el editor de código, en este caso usaremos Visual Studio Code. Para abrir nuestro directorio de trabajo en Visual Studio Code ejecutamos desde la terminal el comando: </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure>
<p>El punto al final es importante, ya que le indica a Visual Studio Code que abra una nueva ventana en el directorio actual.</p>


<p>Esto desplegará una ventana de Visual Studio Code, con nuestro proyecto llamado <strong>ProyectoLexYacc</strong>.</p>


<p>Definimos la estructura de nuestro espacio de trabajo creando un directorio llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/tree/master/src">src</a> en donde estará todo nuestro código fuente. Dentro del directorio <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/tree/master/src">src</a> creamos un directorio <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/tree/master/src/analizador">analizador</a>, en este directorio estará todo el código relacionado con Yacc y Lex.</p>
<h3 id="Codigo-fuente-para-el-analizador-lexico"><a href="#Codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Código fuente para el analizador léxico"></a>Código fuente para el analizador léxico</h3><p>En el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/blob/master/src/analizador/lexer.l">lexer.l</a> incluiremos todo el código que le indicará a Lex lo que debe de hacer. El código se muestra a continuación:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%&#123; </span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;y.tab.h&quot;</span> </span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">yyerror</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line">%&#125; </span><br><span class="line"></span><br><span class="line">%option noyywrap</span><br><span class="line">  </span><br><span class="line">DIGIT   [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">NUM     &#123;DIGIT&#125;+(<span class="string">&quot;.&quot;</span>&#123;DIGIT&#125;+)?</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rule Section */</span></span><br><span class="line">%% </span><br><span class="line">&#123;NUM&#125;               &#123; yylval=atoi(yytext); <span class="keyword">return</span> NUMBER; &#125; </span><br><span class="line">[-()+*/;]            &#123; <span class="keyword">return</span> *yytext; &#125;</span><br><span class="line"><span class="string">&quot;evaluar&quot;</span>            &#123; <span class="keyword">return</span> EVALUAR; &#125;</span><br><span class="line">[[:blank:]] ;</span><br><span class="line">.                     yyerror(<span class="string">&quot;Unknown character&quot;</span>);</span><br><span class="line">%% </span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-codigo-fuente-para-el-analizador-lexico"><a href="#Explicacion-codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Explicación código fuente para el analizador léxico"></a>Explicación código fuente para el analizador léxico</h3><p>En las primeras lineas incluimos <code>stdio.h</code> para la lectura de archivos, luego incluimos la cabecera <code>y.tab.h</code> que es el archivo que genera Yacc para nuestro analizador sintáctico. Por último declaramos la función <code>yyerror</code>, función propia de Lex y Yacc para el manejo de errores léxicos.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%&#123; </span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;y.tab.h&quot;</span> </span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">yyerror</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line">%&#125; </span><br></pre></td></tr></table></figure>

<p>Establecemos una lista de directivas propias de Lex:</p>
<ul>
<li>La directiva <code>noyywrap</code> le indica a Lex que unicamente leera un archivo de entrada.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%option noyywrap</span><br></pre></td></tr></table></figure>

<ul>
<li>Luego se escriben algunas expresiones regulares para identificar enteros y decimales.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DIGIT   [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">NUM     &#123;DIGIT&#125;+(<span class="string">&quot;.&quot;</span>&#123;DIGIT&#125;+)?</span><br></pre></td></tr></table></figure>

<ul>
<li>Por último definimos todas las reglas léxicas, en las que indicamos los patrones que reconocerá y dentro de llaves lo que debe hacer cuando los reconozca. Para retornar nuestras reglas como tokens y que puedan ser utilizadas en el analizador sintáctico retornamos un id que le asignaremos a cada token, para los tokens de tipo símbolo retornamos la variable <code>yytext</code> para tener una definición más limpia y corta. En el caso de <code>NUM</code> adicional al token debemos regresar el valor numérico reconocido, por lo que es necesario hacer una conversión con la función <code>atoi</code> que convierte una cadena a un número y lo almacenamos en yyval. Para los espacios en blanco, Lex cuenta con una directiva <code>[[:blank]]</code> donde podemos ver que no retornamos ningún simbolo, ya que ignoramos los espacios en blanco. Luego indicamos con un punto que todo lo que no fue reconocido en las reglas anteriores será un error léxico.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Rule Section */</span></span><br><span class="line">%% </span><br><span class="line">&#123;NUM&#125;               &#123; yylval=<span class="built_in">atoi</span>(yytext); <span class="keyword">return</span> NUMBER; &#125; </span><br><span class="line">[-()+*/;]            &#123; <span class="keyword">return</span> *yytext; &#125;</span><br><span class="line"><span class="string">&quot;evaluar&quot;</span>            &#123; <span class="keyword">return</span> EVALUAR; &#125;</span><br><span class="line">[[:blank:]] ;</span><br><span class="line">.                     <span class="built_in">yyerror</span>(<span class="string">&quot;Unknown character&quot;</span>);</span><br><span class="line">%% </span><br></pre></td></tr></table></figure>

<h3 id="Codigo-fuente-para-el-analizador-sintactico"><a href="#Codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Código fuente para el analizador sintáctico"></a>Código fuente para el analizador sintáctico</h3><p>En el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/blob/master/src/analizador/parser.y">parser.y</a> incluiremos todo el código que le indicará a Yacc lo que debe de hacer. El código se muestra a continuación:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">%&#123; </span><br><span class="line">   <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">yylex</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="type">void</span> <span class="title function_">yyerror</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line">   FILE *yyin;</span><br><span class="line">%&#125; </span><br><span class="line">  </span><br><span class="line">%token NUMBER EVALUAR</span><br><span class="line">  </span><br><span class="line">%left <span class="string">&#x27;+&#x27;</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">%left <span class="string">&#x27;*&#x27;</span> <span class="string">&#x27;/&#x27;</span></span><br><span class="line">%left NEG</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Rule Section */</span></span><br><span class="line">%% </span><br><span class="line">  </span><br><span class="line">Init </span><br><span class="line">   : Lista &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">Lista </span><br><span class="line">   : Lista EVALUAR <span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\nResult=%d\n&quot;</span>, $<span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   | EVALUAR <span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">   &#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\nResult=%d\n&quot;</span>, $<span class="number">3</span>); </span><br><span class="line">   &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">Expr </span><br><span class="line">   : Expr <span class="string">&#x27;+&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span> + $<span class="number">3</span>; </span><br><span class="line">   &#125; </span><br><span class="line">   | Expr <span class="string">&#x27;-&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span> - $<span class="number">3</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   | Expr <span class="string">&#x27;*&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span> * $<span class="number">3</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   | Expr <span class="string">&#x27;/&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span>/$<span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   | <span class="string">&#x27;-&#x27;</span> Expr %prec NEG &#123;</span><br><span class="line">      $$ = -$<span class="number">2</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   |<span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span> </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">2</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   | NUMBER </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span>;</span><br><span class="line">   &#125; </span><br><span class="line">; </span><br><span class="line">  </span><br><span class="line">%% </span><br><span class="line">  </span><br><span class="line"><span class="comment">//driver code </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse</span><span class="params">(FILE *file)</span> &#123; </span><br><span class="line">   yyin = file;</span><br><span class="line">   yyparse();</span><br><span class="line">   fclose(yyin);</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">yyerror</span><span class="params">(<span class="type">char</span> *s)</span> &#123; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n&quot;</span>, s); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-codigo-fuente-para-el-analizador-sintactico"><a href="#Explicacion-codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Explicación código fuente para el analizador sintáctico"></a>Explicación código fuente para el analizador sintáctico</h3><p>En las primeras lineas incluimos el ficherio <code>stdio.h</code> para la lectura de archivos, luego declarramos la función <strong>yylex</strong>, que es la encargada del analizador léxico, también declaramos la función <strong>yyerror</strong>, que utiliza Yacc para el manejo de errores sintácticos. Por último declaramos una variable de tipo FILE llamada <strong>yyin</strong>, en esta indicaremos el archivo de entrada que será analizado.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%&#123; </span><br><span class="line">   <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">yylex</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="type">void</span> <span class="title function_">yyerror</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line">   FILE *yyin;</span><br><span class="line">%&#125; </span><br></pre></td></tr></table></figure>

<p>Luego se definen los no terminales, a estos se les puede indicar o no un tipo, por defecto es de tipo int. Los terminales que son símbolos y no retornan ningún identificador asociado al token en el analizador léxico no se agregan en esta sección.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******* TERMINALES ********/</span></span><br><span class="line">%token NUMBER EVALUAR</span><br></pre></td></tr></table></figure>

<p>Posteriormente podemos indicar la precedencia de operadores, ya que la gramática escrita es ambigua, es necesario definir una precedencia para que el analizador no entre en conflicto. El nivel de precendencia se define del mas bajo al mas alto. La precendencia mas baja la tienen la suma y la resta, seguido por la multiplicación y división y por último tenemos el signo menos de las expresiones negativas.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%left <span class="string">&#x27;+&#x27;</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">%left <span class="string">&#x27;*&#x27;</span> <span class="string">&#x27;/&#x27;</span></span><br><span class="line">%left NEG</span><br></pre></td></tr></table></figure>

<p>A continuación tenemos el conjunto de reglas de escritura de la gramática o producciones. Escribimos nuestras producciones, para asignar reglas de producción lo hacemos mediante llaves “{ }”, en esta sección podemos escribir código de C. Ya que los analizadores que utiliza Yacc son ascenentes, nos permiten sintetizar atributos, para sintentizar un atributo lo hacemos a traves del identificador “$$”.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line">Init </span><br><span class="line">   : Lista &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">Lista </span><br><span class="line">   : Lista EVALUAR <span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\nResult=%d\n&quot;</span>, $<span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   | EVALUAR <span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">   &#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\nResult=%d\n&quot;</span>, $<span class="number">3</span>); </span><br><span class="line">   &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">Expr </span><br><span class="line">   : Expr <span class="string">&#x27;+&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span> + $<span class="number">3</span>; </span><br><span class="line">   &#125; </span><br><span class="line">   | Expr <span class="string">&#x27;-&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span> - $<span class="number">3</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   | Expr <span class="string">&#x27;*&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span> * $<span class="number">3</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   | Expr <span class="string">&#x27;/&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span>/$<span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   | <span class="string">&#x27;-&#x27;</span> Expr %prec NEG &#123;</span><br><span class="line">      $$ = -$<span class="number">2</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   |<span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span> </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">2</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   | NUMBER </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span>;</span><br><span class="line">   &#125; </span><br><span class="line">;  </span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<p>Como último paso, definimos la función que será llamada para inciar el análisis sintáctico, que en este caso es la función <strong>parse</strong>, esta recibe como parámetro un FILE, que será nuestro archivo de entrada a ser analizado. Por último definimos la función <strong>yyerror</strong>, la cúal será llamada si existiera un error sintáctico, esta función es propia de Yacc.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse</span><span class="params">(FILE *file)</span> </span>&#123; </span><br><span class="line">   yyin = file;</span><br><span class="line">   <span class="built_in">yyparse</span>();</span><br><span class="line">   <span class="built_in">fclose</span>(yyin);</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n&quot;</span>, s); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="El-archivo-de-compilacion"><a href="#El-archivo-de-compilacion" class="headerlink" title="El archivo de compilación"></a>El archivo de compilación</h3><p>En el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/blob/master/src/analizador/compilar.sh">compilar.sh</a>, ejecutamos dos lineas, la primera indica a Lex que debe generar un analizador léxico en base al código fuente que se encuentra en el archivo Léxico. La segunda linea le indica a Yacc que genere los archivos de compilación para el analizador sintáctico en base al archvio Parser.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lex lexer.l</span><br><span class="line">yacc parser.y -d</span><br></pre></td></tr></table></figure>

<p>Para ejecutar abrimos una terminal sobre el directorio <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/tree/master/src/analizador">analizador</a> y ejecutamos lo siguiente:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./compilar.sh</span><br></pre></td></tr></table></figure>

<p><strong>Nota:</strong> Si el comando genera error, asegurese de que el archivo tenga permisos de ejecución.</p>
<p>Este comando genera una serie de archivos que se han mencionado ya anteriormente. Los archivos que genera son los siguientes:</p>
<ul>
<li>y.tab.c</li>
<li>y.tab.h</li>
<li>lex.yy.c</li>
</ul>
<h3 id="Archivo-de-entrada"><a href="#Archivo-de-entrada" class="headerlink" title="Archivo de entrada"></a>Archivo de entrada</h3><p>Dentro de la carpeta src del proyecto, creamos un archivo de entrada llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/blob/master/src/entrada.txt">entrada.txt</a>, que contendrá el archivo de enetrada que reconocerán nuestros analizadores.</p>
<p>El archivo contiene lo siguiente:</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">evaluar(1+1);</span><br><span class="line">evaluar(1+1*2);</span><br><span class="line">evaluar(-(1+1*6/3-5+7));</span><br><span class="line">evaluar(-(1+1*6/3-5+1*-2));</span><br><span class="line">evaluar(-(1+1));</span><br></pre></td></tr></table></figure>

<h3 id="Archivo-Principal"><a href="#Archivo-Principal" class="headerlink" title="Archivo Principal"></a>Archivo Principal</h3><p>Dentro del archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/blob/master/src/main.c">main.c</a>, declaramos el método <em>parse</em>, el cúal fue definido en el analizador sintáctico. Definimos nuestro método <em>main</em>, en este creamos abrimos un archivo a través de FILE, indicamos la ruta del archivo de entrada y por último llamamos a nuestro método parse y le pasamos como parámetro el archivo de entrada. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;analizador/y.tab.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse</span><span class="params">(FILE *file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;entrada.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    parse(file);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ejecutando-nuestra-aplicacion"><a href="#Ejecutando-nuestra-aplicacion" class="headerlink" title="Ejecutando nuestra aplicación"></a>Ejecutando nuestra aplicación</h3><p>Para ejecutar nuestra aplicación necesitamos compilar todos los archivos y generar el ejecutable. Esto lo realizamos con el compilador GCC ejecutando desde consola el siguiente comando:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c ./analizador/*.c</span><br></pre></td></tr></table></figure>

<p>Este nos genera un archivo <code>a.out</code>, que es el binario resultante de la compilación, este archivo lo ejecutamos desde consola y obtenemos la salida de nuestro proyecto.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure>



<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/erflod5">Erik Flores</a> y revisado por el Catedrático <a target="_blank" rel="noopener" href="https://github.com/ericknavarro">Erick Navarro</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h2 id="Fuentes-Consultadas"><a href="#Fuentes-Consultadas" class="headerlink" title="Fuentes Consultadas"></a>Fuentes Consultadas</h2><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-03-16T01:09:28.000Z" title="3/15/2020, 7:09:28 PM">2020-03-15</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/15/26-Interprete-sencillo-utilizando-PLY/">Intérprete sencillo utilizando PLY con Python 3</a></p><div class="content"><h3 id="Funcionamiento-de-la-aplicacion"><a href="#Funcionamiento-de-la-aplicacion" class="headerlink" title="Funcionamiento de la aplicación"></a><strong>Funcionamiento de la aplicación</strong></h3><p>En este tutorial se desarrolla un intérprete que recibe como entrada un archivo de texto que contiene varias sentencias de un lenguaje de programación diseñado especialmente para esta aplicación. Primero se hace análisis léxico y sintáctico de dicha entrada, durante el análisis sintáctico se carga en memoria un Árbol de Sintaxis Abstracta (AST) que se utiliza posteriormente para ejecutar las sentencias. El analizador se genera con PLY utilizando Python 3 en Ubuntu 18.04. El proyecto completo puede descargarse del siguiente enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly">Intérpete sencillo utilizando PLY con Python 3</a></li>
</ul>
<p>Todo el código del proyecto está documentado con comentarios que contienen los detalles de su funcionamiento.</p>
<p>Si se desea una introducción sobre el uso de PLY con Python pueden visitar el post: <a href="/2020/02/10/24-Mi-primer-proyecto-utilizando-PLY/" title="Mi primer proyecto utilizando PLY con Python 3">Mi primer proyecto utilizando PLY con Python 3</a>, en el cual se describen los pre-requisitos y los pasos para la creación del proyecto.</p>
<h3 id="El-lenguaje-de-entrada"><a href="#El-lenguaje-de-entrada" class="headerlink" title="El lenguaje de entrada"></a><strong>El lenguaje de entrada</strong></h3><p>Dentro de la carpeta del proyecto, hay un archivo de entrada llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/entrada.txt">entrada.txt</a> en el cual se muestran ejemplos de todas las funciones del lenguaje diseñado para esta aplicación, al leerlo se puede tener una idea clara de las funciones con las que el lenguaje cuenta, este archivo contiene lo siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//Se imprime el encabezado</span><br><span class="line">imprimir(<span class="string">&quot;Tablas de&quot;</span> &amp; <span class="string">&quot; multiplicar&quot;</span>);</span><br><span class="line"></span><br><span class="line">//Se declara la variable a, de tipo numero</span><br><span class="line">numero a;</span><br><span class="line">//Se asigna a la variable a el valor 0</span><br><span class="line">a=0;</span><br><span class="line">//Se declara la variable c, de tipo numero</span><br><span class="line">numero c;</span><br><span class="line">//Se asigna a la variable c el valor 0</span><br><span class="line">c=1;</span><br><span class="line">//Se imprime un separador</span><br><span class="line">imprimir(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">/**</span><br><span class="line"> * Se imprimen las tablas del 1 al 5 y </span><br><span class="line"> * para cada tabla, se imprimen los resultados</span><br><span class="line"> * desde el uno hasta el 5, esto se hace con </span><br><span class="line"> * dos ciclos <span class="keyword">while</span> anidados. </span><br><span class="line"> **/</span><br><span class="line">mientras(a&lt;4+c)&#123;	</span><br><span class="line">	a=a+1;</span><br><span class="line">	numero b;</span><br><span class="line">	b=0;</span><br><span class="line">	mientras(b&lt;4+c)&#123;</span><br><span class="line">		b=b+1;</span><br><span class="line">		imprimir(a &amp; <span class="string">&quot; * &quot;</span> &amp; b &amp; <span class="string">&quot; = &quot;</span> &amp; a * b);</span><br><span class="line">	&#125;</span><br><span class="line">	imprimir(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Se asigna a la variable a el valor de 11</span><br><span class="line">a=11;</span><br><span class="line">/**</span><br><span class="line"> * La variable b ya había sido declarada pero </span><br><span class="line"> * dentro del ámbito del primer ciclo <span class="keyword">while</span>, </span><br><span class="line"> * entonces no existe en este ámbito por lo que </span><br><span class="line"> * debe declararse.</span><br><span class="line"> **/</span><br><span class="line">numero b;</span><br><span class="line">//Se asigna valor de 12 a b y valor de 13 a c</span><br><span class="line">b=12;</span><br><span class="line">c=13;</span><br><span class="line">/**</span><br><span class="line"> * Se evalua si el valor de la variable a es </span><br><span class="line"> * mayor que 10, si el b es mayor que 11 y si</span><br><span class="line"> * el de c es mayor que 12. </span><br><span class="line"> **/</span><br><span class="line">If(a&gt;10)&#123;</span><br><span class="line">	imprimir(<span class="string">&quot;a es mayor que 10.&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(b&gt;11)&#123;</span><br><span class="line">		imprimir(<span class="string">&quot;a es mayor que 10 y b es mayor que 11.&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(c&gt;12)&#123;</span><br><span class="line">			imprimir(<span class="string">&quot;a es mayor que 10, b es mayor que 11 y c es mayor que 12.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	imprimir(<span class="string">&quot;a es menor o igual que 10.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Como se puede observar, el lenguaje acepta:</p>
<ul>
<li>Comentarios simples, es decir de una sola línea (&#x2F;&#x2F;)</li>
<li>Comentarios múltiples, es decir de más de una línea (&#x2F;* *&#x2F;)</li>
<li>Concatenación de cadenas mediante el operador <code>&amp;</code></li>
<li>Función Imprimir. Recibe como parámetro una cadena e imprime su valor en consola.</li>
<li>Declaración de variables. Únicamente se acepta definición de variables de tipo <code>numero</code> incluyendo enteros y decimales.</li>
<li>Asignación de variables. A cualquier variable se le puede asignar cualquier expresión que tenga como resultado un número.</li>
<li>Instrucción Mientras. Tiene el comportamiento clásico del ciclo while, ejecuta el ciclo mientras la expresión booleana que recibe sea verdadera. Esta instrucción soporta anidamiento. </li>
<li>Instrucción If e If-Else. Tiene el comportamiento clásico de las sentencias de selección If e If-Else, evalúa la expresión booleana y ejecuta el bloque de instrucciones en If si es verdadera. En caso contrario y si existe un bloque Else se ejecuta este bloque de instrucciones. Estas instrucciones también soportan anidamiento.</li>
<li>Expresiones aritméticas. Se soportan las expresiones aritméticas binarias: suma, resta, multiplicación y división. También la expresión unaria: negación. Adicionalmente se soporta expresiones agrupadas en paréntesis. Se maneja la precedencia habitual de las expresiones aritméticas.</li>
<li>Expresiones booleanas. Comparan dos expresiones que tengan como resultado un número y soportan unicamente los operados Mayor Que y Menor que (&lt;, &gt;).</li>
</ul>
<h3 id="El-analizador-lexico-y-sintactico"><a href="#El-analizador-lexico-y-sintactico" class="headerlink" title="El analizador léxico y sintáctico"></a><strong>El analizador léxico y sintáctico</strong></h3><p>En el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/gramatica.py">gramatica.py</a> detallamos la estructura del lenguaje utilizando PLY. A continuación detallaremos los aspectos más relevantes.</p>
<h3 id="Sobre-el-analizador-lexico"><a href="#Sobre-el-analizador-lexico" class="headerlink" title="Sobre el analizador léxico"></a><strong>Sobre el analizador léxico</strong></h3><p>El analizador léxico define los patrones para los tokens que deseamos reconocer. Hacemos uso de expresiones regulares para identificar números, cadenas y comentarios. Para esto hacemos uso del módulo <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/re.html">re</a> de Python</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">reservadas = &#123;</span><br><span class="line">    <span class="string">&#x27;numero&#x27;</span> : <span class="string">&#x27;NUMERO&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;imprimir&#x27;</span> : <span class="string">&#x27;IMPRIMIR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mientras&#x27;</span> : <span class="string">&#x27;MIENTRAS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;if&#x27;</span> : <span class="string">&#x27;IF&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;else&#x27;</span> : <span class="string">&#x27;ELSE&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tokens  = [</span><br><span class="line">    <span class="string">&#x27;PTCOMA&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;LLAVIZQ&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;LLAVDER&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PARIZQ&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PARDER&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;IGUAL&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MAS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MENOS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;POR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;DIVIDIDO&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;CONCAT&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MENQUE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MAYQUE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;IGUALQUE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;NIGUALQUE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;DECIMAL&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ENTERO&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;CADENA&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ID&#x27;</span></span><br><span class="line">] + list(reservadas.values())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tokens</span></span><br><span class="line">t_PTCOMA    = r<span class="string">&#x27;;&#x27;</span></span><br><span class="line">t_LLAVIZQ   = r<span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line">t_LLAVDER   = r<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">t_PARIZQ    = r<span class="string">&#x27;\(&#x27;</span></span><br><span class="line">t_PARDER    = r<span class="string">&#x27;\)&#x27;</span></span><br><span class="line">t_IGUAL     = r<span class="string">&#x27;=&#x27;</span></span><br><span class="line">t_MAS       = r<span class="string">&#x27;\+&#x27;</span></span><br><span class="line">t_MENOS     = r<span class="string">&#x27;-&#x27;</span></span><br><span class="line">t_POR       = r<span class="string">&#x27;\*&#x27;</span></span><br><span class="line">t_DIVIDIDO  = r<span class="string">&#x27;/&#x27;</span></span><br><span class="line">t_CONCAT    = r<span class="string">&#x27;&amp;&#x27;</span></span><br><span class="line">t_MENQUE    = r<span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">t_MAYQUE    = r<span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">t_IGUALQUE  = r<span class="string">&#x27;==&#x27;</span></span><br><span class="line">t_NIGUALQUE = r<span class="string">&#x27;!=&#x27;</span></span><br><span class="line"></span><br><span class="line">def t_DECIMAL(t):</span><br><span class="line">    r<span class="string">&#x27;\d+\.\d+&#x27;</span></span><br><span class="line">    try:</span><br><span class="line">        t.value = <span class="built_in">float</span>(t.value)</span><br><span class="line">    except ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Float value too large %d&quot;</span>, t.value)</span><br><span class="line">        t.value = 0</span><br><span class="line">    <span class="built_in">return</span> t</span><br><span class="line"></span><br><span class="line">def t_ENTERO(t):</span><br><span class="line">    r<span class="string">&#x27;\d+&#x27;</span></span><br><span class="line">    try:</span><br><span class="line">        t.value = int(t.value)</span><br><span class="line">    except ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Integer value too large %d&quot;</span>, t.value)</span><br><span class="line">        t.value = 0</span><br><span class="line">    <span class="built_in">return</span> t</span><br><span class="line"></span><br><span class="line">def t_ID(t):</span><br><span class="line">     r<span class="string">&#x27;[a-zA-Z_][a-zA-Z_0-9]*&#x27;</span></span><br><span class="line">     t.type = reservadas.get(t.value.lower(),<span class="string">&#x27;ID&#x27;</span>)    <span class="comment"># Check for reserved words</span></span><br><span class="line">     <span class="built_in">return</span> t</span><br><span class="line"></span><br><span class="line">def t_CADENA(t):</span><br><span class="line">    r<span class="string">&#x27;\&quot;.*?\&quot;&#x27;</span></span><br><span class="line">    t.value = t.value[1:-1] <span class="comment"># remuevo las comillas</span></span><br><span class="line">    <span class="built_in">return</span> t </span><br><span class="line"></span><br><span class="line"><span class="comment"># Comentario de múltiples líneas /* .. */</span></span><br><span class="line">def t_COMENTARIO_MULTILINEA(t):</span><br><span class="line">    r<span class="string">&#x27;/\*(.|\n)*?\*/&#x27;</span></span><br><span class="line">    t.lexer.lineno += t.value.count(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Comentario simple // ...</span></span><br><span class="line">def t_COMENTARIO_SIMPLE(t):</span><br><span class="line">    r<span class="string">&#x27;//.*\n&#x27;</span></span><br><span class="line">    t.lexer.lineno += 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Caracteres ignorados</span></span><br><span class="line">t_ignore = <span class="string">&quot; \t&quot;</span></span><br><span class="line"></span><br><span class="line">def t_newline(t):</span><br><span class="line">    r<span class="string">&#x27;\n+&#x27;</span></span><br><span class="line">    t.lexer.lineno += t.value.count(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line">def t_error(t):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Illegal character &#x27;%s&#x27;&quot;</span> % t.value[0])</span><br><span class="line">    t.lexer.skip(1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construyendo el analizador léxico</span></span><br><span class="line">import ply.lex as lex</span><br><span class="line">lexer = lex.lex()</span><br></pre></td></tr></table></figure>

<p>Nótese que los comentarios, saltos de líneas y espacios en blanco son ignorados (no retornan ningún valor). </p>
<p>Otro aspecto importante a destacar es que las palabras reservadas son tratadas como <code>Identificadores</code>, esto se debe a que PLY da precedencia a las expresiones regulares más generales. Por ejemplo, la palabra reservada “Imprimir” siempre hará match con la expresión regular de Identificador, por lo que si se define de la forma <code>t_IMPRIMIR = r&#39;imprimir&#39;</code> nunca será alcanzado. Esto lo hace con la finalidad de hacer el proceso de parsing más eficiente al tener menos expresiones regulares que evaluar.</p>
<h3 id="Sobre-el-analizador-sintactico"><a href="#Sobre-el-analizador-sintactico" class="headerlink" title="Sobre el analizador sintáctico"></a><strong>Sobre el analizador sintáctico</strong></h3><p>El objetivo principal de nuestro analizador sintáctico es validar que la entrada sea válida y, si lo es, construir el AST. Para lograr esto hacemos uso de la programación orientada a objetos. Específicamente haremos uso del polimorfismo para la construcción de nuestro árbol. Las clases utilizadas para construir las diferentes instrucciones que componen nuestro AST, están definidas en el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/instrucciones.py">instrucciones.py</a>.</p>
<p><strong>Clases para Instrucciones</strong></p>
<p>Primero definimos una clase abstracta <code>Instruccion</code>, esto nos permitirá abstraer las Instrucciones que soporta nuestro lenguaje:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Instruccion:</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;This is an abstract class&#x27;</span><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Seguidamente, definimos una clase concreta para cada una de las formas posibles que puede tomar <code>Instruccion</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Imprimir(Instruccion) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la instrucción imprimir.</span></span><br><span class="line"><span class="string">        La instrucción imprimir únicamente tiene como parámetro una cadena</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self,  cad) :</span><br><span class="line">        self.cad = cad</span><br><span class="line"></span><br><span class="line">class Mientras(Instruccion) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la instrucción mientras.</span></span><br><span class="line"><span class="string">        La instrucción mientras recibe como parámetro una expresión lógica y la lista</span></span><br><span class="line"><span class="string">        de instrucciones a ejecutar si la expresión lógica es verdadera.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, expLogica, instrucciones = []) :</span><br><span class="line">        self.expLogica = expLogica</span><br><span class="line">        self.instrucciones = instrucciones</span><br></pre></td></tr></table></figure>

<p>Por ejemplo, para la clase <code>Imprimir</code> vemos que extiende de <code>Instruccion</code> y que su única propiedad es la cadena que se va imprimir. Esta propiedad, <code>cadena</code>, es de tipo <code>ExpresionCadena</code> como veremos más adelante.</p>
<p>De la misma forma, la instrucción <code>Mientras</code> extiende de <code>Instruccion</code> y sus propiedades son la expresión lógica a evaluar y el set de instrucciones a ejecutar mientras la condición sea verdadera. <code>expLogica</code> es de tipo ExpresionLogica e <code>instrucciones</code> es una lista, y sus elementos son de tipo <code>Instrucción</code>.</p>
<p>El proceso es similar para las instrucciones de <code>Definición</code> y <code>Asignación</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Definicion(Instruccion) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la instrucción de definición de variables.</span></span><br><span class="line"><span class="string">        Recibe como parámetro el nombre del identificador a definir</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, <span class="built_in">id</span>) :</span><br><span class="line">        self.id = <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">class Asignacion(Instruccion) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la instrucción de asignación de variables</span></span><br><span class="line"><span class="string">        Recibe como parámetro el identificador a asignar y el valor que será asignado.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, <span class="built_in">id</span>, expNumerica) :</span><br><span class="line">        self.id = <span class="built_in">id</span></span><br><span class="line">        self.expNumerica = expNumerica</span><br></pre></td></tr></table></figure>

<p>Finalmente, completamos nuestras instrucciones con <code>If</code> e <code>If-Else</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class If(Instruccion) : </span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la instrucción if.</span></span><br><span class="line"><span class="string">        La instrucción if recibe como parámetro una expresión lógica y la lista</span></span><br><span class="line"><span class="string">        de instrucciones a ejecutar si la expresión lógica es verdadera.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, expLogica, instrucciones = []) :</span><br><span class="line">        self.expLogica = expLogica</span><br><span class="line">        self.instrucciones = instrucciones</span><br><span class="line"></span><br><span class="line">class IfElse(Instruccion) : </span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la instrucción if-else.</span></span><br><span class="line"><span class="string">        La instrucción if-else recibe como parámetro una expresión lógica y la lista</span></span><br><span class="line"><span class="string">        de instrucciones a ejecutar si la expresión lógica es verdadera y otro lista de instrucciones</span></span><br><span class="line"><span class="string">        a ejecutar si la expresión lógica es falsa.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, expLogica, instrIfVerdadero = [], instrIfFalso = []) :</span><br><span class="line">        self.expLogica = expLogica</span><br><span class="line">        self.instrIfVerdadero = instrIfVerdadero</span><br><span class="line">        self.instrIfFalso = instrIfFalso</span><br></pre></td></tr></table></figure>

<h3 id="Clases-para-Expresiones"><a href="#Clases-para-Expresiones" class="headerlink" title="Clases para Expresiones"></a><strong>Clases para Expresiones</strong></h3><p>De la misma manera que manejamos las instrucciones manejaremos las expresiones. Definimos 3 clases abstractas que representan los 3 tipos de expresiones soportadas por nuestro lenguaje: Expresiones Aritméticas, Expresiones con Cadenas y Expresiones Lógicas, todas ellas definidas dentro del archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/expresiones.py">expresiones.py</a>.</p>
<p>También haremos uso de enumeraciones para definir constantes de nuestras operaciones, esto es altamente recomendado para evitar bugs durante el desarrollo.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">class OPERACION_ARITMETICA(Enum) :</span><br><span class="line">    MAS = 1</span><br><span class="line">    MENOS = 2</span><br><span class="line">    POR = 3</span><br><span class="line">    DIVIDIDO = 4</span><br><span class="line"></span><br><span class="line">class OPERACION_LOGICA(Enum) :</span><br><span class="line">    MAYOR_QUE = 1</span><br><span class="line">    MENOR_QUE = 2</span><br><span class="line">    IGUAL = 3</span><br><span class="line">    DIFERENTE = 4</span><br></pre></td></tr></table></figure>

<p>Iniciamos definiendo nuestra clase <code>ExpresionNumerica</code> de tipo abstracta y será nuestra clase base para las expresiones numéricas.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ExpresionNumerica:</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa una expresión numérica</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Las formas que puede tomar nuestra clase <code>ExpresionNumerica</code> son las siguientes:</p>
<ul>
<li><code>ExpresionBinaria</code>. Representa una operación aritmética binaria, la clase recibe los 2 operados: <code>exp1</code> y <code>exp2</code>, ambos de tipos <code>ExpresionNumérica</code>. Y recibe el <code>operador</code> el cual es un calor de nuestro <code>enum</code> definidos anteriormente.</li>
<li><code>ExpresionNegativo</code>. Representa la operación aritmética unaria de negación. Únicamente recibe como parámetro la expresión que se negara, esta es también de tipo <code>ExpresionNumerica</code></li>
<li><code>ExpresionNumero</code>. Representa un valor terminal numérico. El parámetro <code>val</code> contiene el valor extraído por el analizador léxico.</li>
<li><code>ExpresionIdentificador</code>. Representa un identificador. El parámetro <code>id</code> representa el nombre de la variable que se desea operar.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class ExpresionBinaria(ExpresionNumerica) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la Expresión Aritmética Binaria.</span></span><br><span class="line"><span class="string">        Esta clase recibe los operandos y el operador</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, exp1, exp2, operador) :</span><br><span class="line">        self.exp1 = exp1</span><br><span class="line">        self.exp2 = exp2</span><br><span class="line">        self.operador = operador</span><br><span class="line"></span><br><span class="line">class ExpresionNegativo(ExpresionNumerica) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la Expresión Aritmética Negativa.</span></span><br><span class="line"><span class="string">        Esta clase recibe la expresion</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    def __init__(self, exp) :</span><br><span class="line">        self.exp = exp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ExpresionNumero(ExpresionNumerica) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa una expresión numérica entera o decimal.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, val = 0) :</span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line">class ExpresionIdentificador(ExpresionNumerica) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa un identificador.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, <span class="built_in">id</span> = <span class="string">&quot;&quot;</span>) :</span><br><span class="line">        self.id = <span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>Ahora, siguiendo el proceso anterior, definimos nuestras expresiones con cadenas.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class ExpresionCadena :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa una Expresión de tipo cadena.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">class ExpresionConcatenar(ExpresionCadena) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa una Expresión de tipo cadena.</span></span><br><span class="line"><span class="string">        Recibe como parámetros las 2 expresiones a concatenar</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, exp1, exp2) :</span><br><span class="line">        self.exp1 = exp1</span><br><span class="line">        self.exp2 = exp2</span><br><span class="line"></span><br><span class="line">class ExpresionDobleComilla(ExpresionCadena) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa una cadena entre comillas doble.</span></span><br><span class="line"><span class="string">        Recibe como parámetro el valor del token procesado por el analizador léxico</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, val) :</span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line">class ExpresionCadenaNumerico(ExpresionCadena) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa una expresión numérica tratada como cadena.</span></span><br><span class="line"><span class="string">        Recibe como parámetro la expresión numérica</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    def __init__(self, exp) :</span><br><span class="line">        self.exp = exp</span><br></pre></td></tr></table></figure>
<p>Y finalmente, definimos nuestras expresiones lógicas</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ExpresionLogica() :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la expresión lógica.</span></span><br><span class="line"><span class="string">        Esta clase recibe los operandos y el operador</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, exp1, exp2, operador) :</span><br><span class="line">        self.exp1 = exp1</span><br><span class="line">        self.exp2 = exp2</span><br><span class="line">        self.operador = operador</span><br></pre></td></tr></table></figure>

<h3 id="Construccion-del-AST"><a href="#Construccion-del-AST" class="headerlink" title="Construcción del AST"></a><strong>Construcción del AST</strong></h3><p>Para construir el AST durante nuestro análisis sintáctico importamos nuestras clases de instrucciones y expresiones. Esto también incluye nuestros enum para las constantes, esto se hará en el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/gramatica.py">gramatica.py</a>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definición de la gramática</span></span><br><span class="line"></span><br><span class="line">from expresiones import *</span><br><span class="line">from instrucciones import *</span><br></pre></td></tr></table></figure>

<p>Una vez importados podemos hacer uso de ellas en la gramática. Por ejemplo, para la construcción de operaciones aritméticas hacemos uso de nuestras clases de tipo <code>ExpresionNumerica</code>, pasamos como parámetros los operandos y el tipo operación (utilizando nuestras constantes).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def p_expresion_binaria(t):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;expresion_numerica : expresion_numerica MAS expresion_numerica</span></span><br><span class="line"><span class="string">                        | expresion_numerica MENOS expresion_numerica</span></span><br><span class="line"><span class="string">                        | expresion_numerica POR expresion_numerica</span></span><br><span class="line"><span class="string">                        | expresion_numerica DIVIDIDO expresion_numerica&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> t[2] == <span class="string">&#x27;+&#x27;</span>  : t[0] = ExpresionBinaria(t[1], t[3], OPERACION_ARITMETICA.MAS)</span><br><span class="line">    <span class="keyword">elif</span> t[2] == <span class="string">&#x27;-&#x27;</span>: t[0] = ExpresionBinaria(t[1], t[3], OPERACION_ARITMETICA.MENOS)</span><br><span class="line">    <span class="keyword">elif</span> t[2] == <span class="string">&#x27;*&#x27;</span>: t[0] = ExpresionBinaria(t[1], t[3], OPERACION_ARITMETICA.POR)</span><br><span class="line">    <span class="keyword">elif</span> t[2] == <span class="string">&#x27;/&#x27;</span>: t[0] = ExpresionBinaria(t[1], t[3], OPERACION_ARITMETICA.DIVIDIDO)</span><br><span class="line"></span><br><span class="line">def p_expresion_unaria(t):</span><br><span class="line">    <span class="string">&#x27;expresion_numerica : MENOS expresion_numerica %prec UMENOS&#x27;</span></span><br><span class="line">    t[0] = ExpresionNegativo(t[2])</span><br><span class="line"></span><br><span class="line">def p_expresion_agrupacion(t):</span><br><span class="line">    <span class="string">&#x27;expresion_numerica : PARIZQ expresion_numerica PARDER&#x27;</span></span><br><span class="line">    t[0] = t[2]</span><br><span class="line"></span><br><span class="line">def p_expresion_number(t):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;expresion_numerica : ENTERO</span></span><br><span class="line"><span class="string">                        | DECIMAL&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    t[0] = ExpresionNumero(t[1])</span><br><span class="line"></span><br><span class="line">def p_expresion_id(t):</span><br><span class="line">    <span class="string">&#x27;expresion_numerica   : ID&#x27;</span></span><br><span class="line">    t[0] = ExpresionIdentificador(t[1])</span><br></pre></td></tr></table></figure>

<p>El proceso es el mismo para las Instrucciones, cada producción de tipo Instrucción construye una instancia concreta de la instrucción apropiada.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def p_instruccion_imprimir(t) :</span><br><span class="line">    <span class="string">&#x27;imprimir_instr     : IMPRIMIR PARIZQ expresion_cadena PARDER PTCOMA&#x27;</span></span><br><span class="line">    t[0] =Imprimir(t[3])</span><br><span class="line"></span><br><span class="line">def p_instruccion_definicion(t) :</span><br><span class="line">    <span class="string">&#x27;definicion_instr   : NUMERO ID PTCOMA&#x27;</span></span><br><span class="line">    t[0] =Definicion(t[2])</span><br><span class="line"></span><br><span class="line">def p_asignacion_instr(t) :</span><br><span class="line">    <span class="string">&#x27;asignacion_instr   : ID IGUAL expresion_numerica PTCOMA&#x27;</span></span><br><span class="line">    t[0] =Asignacion(t[1], t[3])</span><br><span class="line"></span><br><span class="line">def p_mientras_instr(t) :</span><br><span class="line">    <span class="string">&#x27;mientras_instr     : MIENTRAS PARIZQ expresion_logica PARDER LLAVIZQ instrucciones LLAVDER&#x27;</span></span><br><span class="line">    t[0] =Mientras(t[3], t[6])</span><br><span class="line"></span><br><span class="line">def p_if_instr(t) :</span><br><span class="line">    <span class="string">&#x27;if_instr           : IF PARIZQ expresion_logica PARDER LLAVIZQ instrucciones LLAVDER&#x27;</span></span><br><span class="line">    t[0] =If(t[3], t[6])</span><br><span class="line"></span><br><span class="line">def p_if_else_instr(t) :</span><br><span class="line">    <span class="string">&#x27;if_else_instr      : IF PARIZQ expresion_logica PARDER LLAVIZQ instrucciones LLAVDER ELSE LLAVIZQ instrucciones LLAVDER&#x27;</span></span><br><span class="line">    t[0] =IfElse(t[3], t[6], t[10])</span><br></pre></td></tr></table></figure>

<p>Finalmente, una vez que hayamos reconocido toda la entrada, construimos un arreglo con cada uno de los nodos. Este será nuestro AST.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def p_init(t) :</span><br><span class="line">    <span class="string">&#x27;init            : instrucciones&#x27;</span></span><br><span class="line">    t[0] = t[1]</span><br><span class="line"></span><br><span class="line">def p_instrucciones_lista(t) :</span><br><span class="line">    <span class="string">&#x27;instrucciones    : instrucciones instruccion&#x27;</span></span><br><span class="line">    t[1].append(t[2])</span><br><span class="line">    t[0] = t[1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def p_instrucciones_instruccion(t) :</span><br><span class="line">    <span class="string">&#x27;instrucciones    : instruccion &#x27;</span></span><br><span class="line">    t[0] = [t[1]]</span><br><span class="line"></span><br><span class="line">def p_instruccion(t) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;instruccion      : imprimir_instr</span></span><br><span class="line"><span class="string">                        | definicion_instr</span></span><br><span class="line"><span class="string">                        | asignacion_instr</span></span><br><span class="line"><span class="string">                        | mientras_instr</span></span><br><span class="line"><span class="string">                        | if_instr</span></span><br><span class="line"><span class="string">                        | if_else_instr&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    t[0] = t[1]</span><br></pre></td></tr></table></figure>

<h3 id="La-tabla-de-simbolos"><a href="#La-tabla-de-simbolos" class="headerlink" title="La tabla de símbolos"></a><strong>La tabla de símbolos</strong></h3><p>La <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/ts.py">tabla de símbolos</a> es la que permite el almacenamiento y recuperación de los valores de las variables. Para su implementación hacemos uso de una clase, ya que necesitaremos más de una instancia de tabla de símbolos. Cada ámbito tiene acceso únicamente a su propia tabla de símbolos y a la de los niveles superiores, la definición de esta clase puede encontrarse en el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/ts.py">ts.py</a>.</p>
<p>Definimos las constantes para los tipos de datos, en este tutorial se hace uso únicamente del tipo de dato numérico.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">class TIPO_DATO(Enum) :</span><br><span class="line">    NUMERO = 1</span><br></pre></td></tr></table></figure>

<p>Definimos una clase para los Símbolos.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Simbolo() :</span><br><span class="line">    <span class="string">&#x27;Esta clase representa un simbolo dentro de nuestra tabla de simbolos&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, <span class="built_in">id</span>, tipo, valor) :</span><br><span class="line">        self.id = <span class="built_in">id</span></span><br><span class="line">        self.tipo = tipo</span><br><span class="line">        self.valor = valor</span><br></pre></td></tr></table></figure>

<p>La clase <code>TablaDeSimbolos</code> define la estructura de una tabla de símbolos y sus funciones para agregar, modificar y obtener símbolos.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class TablaDeSimbolos() :</span><br><span class="line">    <span class="string">&#x27;Esta clase representa la tabla de simbolos&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, simbolos = &#123;&#125;) :</span><br><span class="line">        self.simbolos = simbolos</span><br><span class="line"></span><br><span class="line">    def agregar(self, simbolo) :</span><br><span class="line">        self.simbolos[simbolo.id] = simbolo</span><br><span class="line">    </span><br><span class="line">    def obtener(self, <span class="built_in">id</span>) :</span><br><span class="line">        <span class="keyword">if</span> not <span class="built_in">id</span> <span class="keyword">in</span> self.simbolos :</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error: variable &#x27;</span>, <span class="built_in">id</span>, <span class="string">&#x27; no definida.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> self.simbolos[<span class="built_in">id</span>]</span><br><span class="line"></span><br><span class="line">    def actualizar(self, simbolo) :</span><br><span class="line">        <span class="keyword">if</span> not simbolo.id <span class="keyword">in</span> self.simbolos :</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error: variable &#x27;</span>, simbolo.id, <span class="string">&#x27; no definida.&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            self.simbolos[simbolo.id] = simbolo</span><br></pre></td></tr></table></figure>

<h3 id="Construccion-del-Interprete"><a href="#Construccion-del-Interprete" class="headerlink" title="Construcción del Intérprete"></a><strong>Construcción del Intérprete</strong></h3><p>La definición del Intérprete se encuentra en el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/principal.py">principal.py</a> </p>
<p>Para iniciar con la implementación, primero importamos nuestra gramática, las constantes y clases de nuestro AST y  la Tabla de Símbolos.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import gramatica as g</span><br><span class="line">import ts as TS</span><br><span class="line">from expresiones import *</span><br><span class="line">from instrucciones import *</span><br></pre></td></tr></table></figure>

<p>Seguidamente, obtenemos el AST a partir del archivo de entrada.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">&quot;./entrada.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">input = f.read()</span><br><span class="line"></span><br><span class="line">instrucciones = g.parse(input)</span><br><span class="line">ts_global = TS.TablaDeSimbolos()</span><br><span class="line"></span><br><span class="line">procesar_instrucciones(instrucciones, ts_global)</span><br></pre></td></tr></table></figure>

<p>Nótese que el AST está contenido en la variable <code>instrucciones</code>. </p>
<p>La función principal del intérprete es de reconocer cada instrucción y ejecutarla, para esto es necesario recorrer el AST; es por ello que se ha definido la función <code>procesar_instrucciones</code> la cual itera las instrucciones en un ámbito y las ejecuta.</p>
<p>Para iniciar con la ejecución se crea la tabla de símbolos para el ámbito global y se invoca la función <code>procesar_instrucciones</code> con la raíz del AST y la tabla de símbolos del ámbito global.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def procesar_instrucciones(instrucciones, ts) :</span><br><span class="line">    <span class="comment">## lista de instrucciones recolectadas</span></span><br><span class="line">    <span class="keyword">for</span> instr <span class="keyword">in</span> instrucciones :</span><br><span class="line">        <span class="keyword">if</span> isinstance(instr, Imprimir) : procesar_imprimir(instr, ts)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(instr, Definicion) : procesar_definicion(instr, ts)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(instr, Asignacion) : procesar_asignacion(instr, ts)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(instr, Mientras) : procesar_mientras(instr, ts)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(instr, If) : procesar_if(instr, ts)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(instr, IfElse) : procesar_if_else(instr, ts)</span><br><span class="line">        <span class="keyword">else</span> : <span class="built_in">print</span>(<span class="string">&#x27;Error: instrucción no válida&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>Existe una función para procesar cada instrucción. </p>
<p>Las sentencias Mientras, If e If-Else crean nuevas tablas de símbolos antes de procesar las instrucciones dentro de sus bloques de instrucciones. Estas nuevas tablas de símbolos se inicializan con los valores de la tabla de símbolo actual y al terminar la ejecución de la sentencia los valores son eliminados ya que la instancia se crea localmente en el cuerpo de la función.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def procesar_mientras(instr, ts) :</span><br><span class="line">    <span class="keyword">while</span> resolver_expreision_logica(instr.expLogica, ts) :</span><br><span class="line">        ts_local = TS.TablaDeSimbolos(ts.simbolos)</span><br><span class="line">        procesar_instrucciones(instr.instrucciones, ts_local)</span><br><span class="line"></span><br><span class="line">def procesar_if(instr, ts) :</span><br><span class="line">    val = resolver_expreision_logica(instr.expLogica, ts)</span><br><span class="line">    <span class="keyword">if</span> val :</span><br><span class="line">        ts_local = TS.TablaDeSimbolos(ts.simbolos)</span><br><span class="line">        procesar_instrucciones(instr.instrucciones, ts_local)</span><br><span class="line"></span><br><span class="line">def procesar_if_else(instr, ts) :</span><br><span class="line">    val = resolver_expreision_logica(instr.expLogica, ts)</span><br><span class="line">    <span class="keyword">if</span> val :</span><br><span class="line">        ts_local = TS.TablaDeSimbolos(ts.simbolos)</span><br><span class="line">        procesar_instrucciones(instr.instrIfVerdadero, ts_local)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        ts_local = TS.TablaDeSimbolos(ts.simbolos)</span><br><span class="line">        procesar_instrucciones(instr.instrIfFalso, ts_local)</span><br></pre></td></tr></table></figure>

<p>Las sentencias de Declaración y Asignación agregan y modifican valores de la tabla de símbolos. La sentencia Imprimir muestra el valor de una cadena en la consola.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def procesar_imprimir(instr, ts) :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&gt; &#x27;</span>, resolver_cadena(instr.cad, ts))</span><br><span class="line"></span><br><span class="line">def procesar_definicion(instr, ts) :</span><br><span class="line">    simbolo = TS.Simbolo(instr.id, TS.TIPO_DATO.NUMERO, 0)      <span class="comment"># inicializamos con 0 como valor por defecto</span></span><br><span class="line">    ts.agregar(simbolo)</span><br><span class="line"></span><br><span class="line">def procesar_asignacion(instr, ts) :</span><br><span class="line">    val = resolver_expresion_aritmetica(instr.expNumerica, ts)</span><br><span class="line">    simbolo = TS.Simbolo(instr.id, TS.TIPO_DATO.NUMERO, val)</span><br><span class="line">    ts.actualizar(simbolo)</span><br></pre></td></tr></table></figure>

<p>Finalmente, todas las sentencias descritas anteriormente hacen uso de las operaciones numéricas, con cadenas y lógicas las cuales hacen uso de la tabla de símbolos para obtener valores de las variables.</p>
<p>Para las expresiones numéricas evaluamos el tipo de operación y con base en ellos resolvemos el valor apropiado</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def resolver_expresion_aritmetica(expNum, ts) :</span><br><span class="line">    <span class="keyword">if</span> isinstance(expNum, ExpresionBinaria) :</span><br><span class="line">        exp1 = resolver_expresion_aritmetica(expNum.exp1, ts)</span><br><span class="line">        exp2 = resolver_expresion_aritmetica(expNum.exp2, ts)</span><br><span class="line">        <span class="keyword">if</span> expNum.operador == OPERACION_ARITMETICA.MAS : <span class="built_in">return</span> exp1 + exp2</span><br><span class="line">        <span class="keyword">if</span> expNum.operador == OPERACION_ARITMETICA.MENOS : <span class="built_in">return</span> exp1 - exp2</span><br><span class="line">        <span class="keyword">if</span> expNum.operador == OPERACION_ARITMETICA.POR : <span class="built_in">return</span> exp1 * exp2</span><br><span class="line">        <span class="keyword">if</span> expNum.operador == OPERACION_ARITMETICA.DIVIDIDO : <span class="built_in">return</span> exp1 / exp2</span><br><span class="line">    <span class="keyword">elif</span> isinstance(expNum, ExpresionNegativo) :</span><br><span class="line">        exp = resolver_expresion_aritmetica(expNum.exp, ts)</span><br><span class="line">        <span class="built_in">return</span> exp * -1</span><br><span class="line">    <span class="keyword">elif</span> isinstance(expNum, ExpresionNumero) :</span><br><span class="line">        <span class="built_in">return</span> expNum.val</span><br><span class="line">    <span class="keyword">elif</span> isinstance(expNum, ExpresionIdentificador) :</span><br><span class="line">        <span class="built_in">return</span> ts.obtener(expNum.<span class="built_in">id</span>).valor</span><br></pre></td></tr></table></figure>

<p>Para las expresiones con cadenas también validamos el tipo de operación para verificar si es necesario una operación de concatenación. En cualquier caso se resuelve la cadena.  También es posible concatenar valores numéricos, para esto resolvemos la expresión apoyándonos de la función para procesar expresiones numéricas.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def resolver_cadena(expCad, ts) :</span><br><span class="line">    <span class="keyword">if</span> isinstance(expCad, ExpresionConcatenar) :</span><br><span class="line">        exp1 = resolver_cadena(expCad.exp1, ts)</span><br><span class="line">        exp2 = resolver_cadena(expCad.exp2, ts)</span><br><span class="line">        <span class="built_in">return</span> exp1 + exp2</span><br><span class="line">    <span class="keyword">elif</span> isinstance(expCad, ExpresionDobleComilla) :</span><br><span class="line">        <span class="built_in">return</span> expCad.val</span><br><span class="line">    <span class="keyword">elif</span> isinstance(expCad, ExpresionCadenaNumerico) :</span><br><span class="line">        <span class="built_in">return</span> str(resolver_expresion_aritmetica(expCad.exp, ts))</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error: Expresión cadena no válida&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>Al igual que las expresiones con cadena, las expresiones lógicas también se apoya en la función que procesa expresiones numéricas para poder evaluar las condiciones booleanas.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def resolver_expreision_logica(expLog, ts) :</span><br><span class="line">    exp1 = resolver_expresion_aritmetica(expLog.exp1, ts)</span><br><span class="line">    exp2 = resolver_expresion_aritmetica(expLog.exp2, ts)</span><br><span class="line">    <span class="keyword">if</span> expLog.operador == OPERACION_LOGICA.MAYOR_QUE : <span class="built_in">return</span> exp1 &gt; exp2</span><br><span class="line">    <span class="keyword">if</span> expLog.operador == OPERACION_LOGICA.MENOR_QUE : <span class="built_in">return</span> exp1 &lt; exp2</span><br><span class="line">    <span class="keyword">if</span> expLog.operador == OPERACION_LOGICA.IGUAL : <span class="built_in">return</span> exp1 == exp2</span><br><span class="line">    <span class="keyword">if</span> expLog.operador == OPERACION_LOGICA.DIFERENTE : <span class="built_in">return</span> exp1 != exp2</span><br></pre></td></tr></table></figure>

<p>Para ejecutar nuestro intérprete y procesar el archivo de entrada ejecutamos el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 ./principal.py</span><br></pre></td></tr></table></figure>

<p>Y veremos el resultado en consola.</p>


<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/rjanixz">Rainman Sián</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-10T22:17:25.000Z" title="2/10/2020, 4:17:25 PM">2020-02-10</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/10/24-Mi-primer-proyecto-utilizando-PLY/">Mi primer proyecto utilizando PLY con Python 3</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presentando como salida el resultado de dichas expresiones.</p>
<p>Las tecnologías a utilizar son:</p>
<ul>
<li><strong>PLY</strong>: Generador de analizadores léxicos y sintácticos.</li>
<li><strong>Python 3</strong>: Es un lenguaje de programación interpretado de alto nivel.</li>
<li><strong>Visual Studio Code</strong>: Es un editor de código ligero pero poderoso. Existen complementos para trabajar con este lenguaje.</li>
</ul>
<p>El proyecto completo lo pueden descargar del siguiente enlace</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoPly">Mi primer proyecto utilizando PLY</a></li>
</ul>
<h3 id="PLY"><a href="#PLY" class="headerlink" title="PLY"></a><strong>PLY</strong></h3><p><a target="_blank" rel="noopener" href="https://www.dabeaz.com/ply/">PLY</a> es una implementación en Python de lex y yacc, herramientas populares para la construcción de compiladores.</p>
<p>La principal tarea de un analizador léxico es leer los caracteres de entrada del programa fuente, agruparlos en lexemas y producir como salida una secuencia de tokens.</p>
<ul>
<li>Un <em>token</em> es un par que consiste en un nombre de token y un valor de atributo opcional.</li>
<li>Un <em>lexema</em> es una secuencia de caracteres en el programa fuente, que coinciden con el patrón para un token y que el analizador léxico identifica como una instancia de este token.</li>
<li>Un <em>patrón</em> es una descripción de la forma que pueden tomar los lexemas de un token.</li>
</ul>
<p>El analizador sintáctico obtiene una cadena de tokens del analizador léxico y verifica que dicha cadena pueda generarse con la gramática para el lenguaje fuente. Una gramática proporciona una especificación precisa y fácil de entender de un lenguaje de programación.</p>
<p>En <a target="_blank" rel="noopener" href="https://www.dabeaz.com/ply/">PLY</a> se definen los patrones de los diferentes tokens que se desean reconocer, esto se hace a través de expresiones regulares. Mientras que las producciones y acciones para formar la gramática se definen a través de funciones.</p>
<h3 id="Pre-requisitos"><a href="#Pre-requisitos" class="headerlink" title="Pre-requisitos"></a><strong>Pre-requisitos</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.python.org/">Python 3</a></li>
<li><a target="_blank" rel="noopener" href="https://www.dabeaz.com/ply/">PLY</a></li>
</ul>
<h3 id="Instalamos-PLY"><a href="#Instalamos-PLY" class="headerlink" title="Instalamos PLY"></a><strong>Instalamos PLY</strong></h3><p>Para hacer uso de PLY en nuestro proyecto no hacemos instalación como tal, lo que necesitamos es descargar el archivo ply-3.11.tar.gz (versión 3.11 al momento de escribir este tutorial) de la página oficial de <a target="_blank" rel="noopener" href="https://www.dabeaz.com/ply/">PLY</a> y lo que hacemos es copiar el fólder “ply” a nuestro proyecto.</p>


<h3 id="Crear-nuestro-proyecto"><a href="#Crear-nuestro-proyecto" class="headerlink" title="Crear nuestro proyecto"></a><strong>Crear nuestro proyecto</strong></h3><p>Primero crearemos un nuevo fólder, en este caso lo llamaremos PROYECTOPLY. Luego lo abrimos en nuestro editor de texto, en este caso usaremos <a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a>. Finalmente procedemos a crear un nuevo archivo llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoPly/blob/master/gramatica.py">gramatica.py</a> donde escribiremos nuestro compilador.</p>


<p>Los directorios “<strong>pycache</strong>“, al igual que los archivos “parser.out” y “parsetab.py” son generados por Python los cuales pueden ser excluidos en nuestro controlador de versiones. En este caso, los agregamos a nuestro <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoPly/blob/master/.gitignore">.gitignore</a>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser.out</span><br><span class="line">parsetab.py</span><br><span class="line">**/__pycache__/**</span><br></pre></td></tr></table></figure>

<p>El directorio “ply” es el que descargamos y utilizaremos para construir nuestro compilador.</p>
<h3 id="Codigo-Fuente-para-el-analizador-lexico-y-sintactico"><a href="#Codigo-Fuente-para-el-analizador-lexico-y-sintactico" class="headerlink" title="Código Fuente para el analizador léxico y sintáctico"></a><strong>Código Fuente para el analizador léxico y sintáctico</strong></h3><p>En el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoPly/blob/master/gramatica.py">gramatica.py</a> tenemos la construcción de nuestro compilador.</p>
<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-lexico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Explicación del código fuente para el analizador léxico"></a><strong>Explicación del código fuente para el analizador léxico</strong></h3><p>Lo primero que debemos hacer es definir el listado de tokens que vamos a reconocer ya asignarlo a la variable tokens</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tokens  = (</span><br><span class="line">    <span class="string">&#x27;REVALUAR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PARIZQ&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PARDER&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;CORIZQ&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;CORDER&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MAS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MENOS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;POR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;DIVIDIDO&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;DECIMAL&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ENTERO&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PTCOMA&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Luego escribimos los patrones para los tokens que definimos. Existen dos formas de definir las reglas de nuestros tokens.</p>
<p>La primera, es con expresiones regulares, agregamos el prefijo “t_” al token que queremos definir y luego le especificamos la expresión regular, para esto se hace uso del módulo <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/re.html">re</a> de Python.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tokens</span></span><br><span class="line">t_REVALUAR  = r<span class="string">&#x27;Evaluar&#x27;</span></span><br><span class="line">t_PARIZQ    = r<span class="string">&#x27;\(&#x27;</span></span><br><span class="line">t_PARDER    = r<span class="string">&#x27;\)&#x27;</span></span><br><span class="line">t_CORIZQ    = r<span class="string">&#x27;\[&#x27;</span></span><br><span class="line">t_CORDER    = r<span class="string">&#x27;\]&#x27;</span></span><br><span class="line">t_MAS       = r<span class="string">&#x27;\+&#x27;</span></span><br><span class="line">t_MENOS     = r<span class="string">&#x27;-&#x27;</span></span><br><span class="line">t_POR       = r<span class="string">&#x27;\*&#x27;</span></span><br><span class="line">t_DIVIDIDO  = r<span class="string">&#x27;/&#x27;</span></span><br><span class="line">t_PTCOMA    = r<span class="string">&#x27;;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>La otra forma es a través de funciones, esto nos sirve para manipular el valor del token que procesamos. Por ejemplo para los valores numéricos los retornamos con el tipo apropiado, hacer validaciones, etc.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def t_DECIMAL(t):</span><br><span class="line">    r<span class="string">&#x27;\d+\.\d+&#x27;</span></span><br><span class="line">    try:</span><br><span class="line">        t.value = <span class="built_in">float</span>(t.value)</span><br><span class="line">    except ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Floaat value too large %d&quot;</span>, t.value)</span><br><span class="line">        t.value = 0</span><br><span class="line">    <span class="built_in">return</span> t</span><br><span class="line"></span><br><span class="line">def t_ENTERO(t):</span><br><span class="line">    r<span class="string">&#x27;\d+&#x27;</span></span><br><span class="line">    try:</span><br><span class="line">        t.value = int(t.value)</span><br><span class="line">    except ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Integer value too large %d&quot;</span>, t.value)</span><br><span class="line">        t.value = 0</span><br><span class="line">    <span class="built_in">return</span> t</span><br></pre></td></tr></table></figure>

<p>Es importante definir también los caracteres que se van a ignorar.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Caracteres ignorados</span></span><br><span class="line">t_ignore = <span class="string">&quot; \t&quot;</span></span><br></pre></td></tr></table></figure>

<p>Las funciones también llevan el prefijo “t_” antes del nombre del token que queremos procesar. La función recibe un parámetro, “t” en nuestro ejemplo, este contiene el valor del token. Retornamos el valor ya procesado que deseamos, o no retornar nada si lo que deseamos es ignorar el token (por ejemplo: comentarios, contadores, etc.).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def t_newline(t):</span><br><span class="line">    r<span class="string">&#x27;\n+&#x27;</span></span><br><span class="line">    t.lexer.lineno += t.value.count(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line">def t_error(t):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Illegal character &#x27;%s&#x27;&quot;</span> % t.value[0])</span><br><span class="line">    t.lexer.skip(1)</span><br></pre></td></tr></table></figure>

<p>Finalmente construimos el analizador léxico haciendo uso de las librerías de PLY</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Construyendo el analizador léxico</span></span><br><span class="line">import ply.lex as lex</span><br><span class="line">lexer = lex.lex()</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-sintactico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Explicación del código fuente para el analizador sintáctico"></a><strong>Explicación del código fuente para el analizador sintáctico</strong></h3><p>Otra de las ventajas de Python es que en el mismo archivo podemos definir nuestro análisis sintáctico haciendo uso de los tokens previamente definidos en la sección del analizador léxico.</p>
<p>Primeramente definimos la asociatividad y precedencia de los operadores, ya que la gramática escrita es ambigua, es necesario definir una precedencia para que el analizador no entre en conflicto al analizar, en este caso la precedencia es la misma que la de los operadores aritméticos, la precedencia más baja la tienen la suma y la resta, luego están la multiplicación y la división que tienen una precedencia más alta y por último está el signo menos de las expresiones negativas que tendría la precedencia más alta.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Asociación de operadores y precedencia</span></span><br><span class="line">precedence = (</span><br><span class="line">    (<span class="string">&#x27;left&#x27;</span>,<span class="string">&#x27;MAS&#x27;</span>,<span class="string">&#x27;MENOS&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;left&#x27;</span>,<span class="string">&#x27;POR&#x27;</span>,<span class="string">&#x27;DIVIDIDO&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;right&#x27;</span>,<span class="string">&#x27;UMENOS&#x27;</span>),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>Ahora procedemos a escribir nuestras producciones, aquí vemos otra de las ventajas de Python, las acciones semánticas de nuestras producciones se hacen en forma de funciones. Las características de estas funciones son:</p>
<ul>
<li>El nombre inicia con el prefijo “_p”. El complemento del nombre queda a nuestra discreción</li>
<li>Tiene un único parámetro “t” el cual es una tupla, en cada posición tiene el valor de los terminales y no terminales de la producción.</li>
<li>Haciendo uso del docstring de las funciones de Python especificamos las producciones que serán procesadas por la función.</li>
<li>En el cuerpo de la función definimos la funcionalidad que deseamos</li>
</ul>
<p>Por ejemplo:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def p_expresion_evaluar(t):</span><br><span class="line">     <span class="string">&#x27;expresion : expresion MAS expresion&#x27;</span></span><br><span class="line">     <span class="comment">#   ^            ^      ^    ^</span></span><br><span class="line">     <span class="comment">#  t[0]         t[1]   t[2] t[3]</span></span><br><span class="line"> </span><br><span class="line">     t[0] = t[1] + t[3]</span><br></pre></td></tr></table></figure>

<p>Sintetizamos en p[0] (expresion) el valor del resultado de sumar loo valores de p[1] (expresion) y p[3].</p>
<p>A continuación el código completo de nuestras producciones:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definición de la gramática</span></span><br><span class="line">def p_instrucciones_lista(t):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;instrucciones    : instruccion instrucciones</span></span><br><span class="line"><span class="string">                        | instruccion &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">def p_instrucciones_evaluar(t):</span><br><span class="line">    <span class="string">&#x27;instruccion : REVALUAR CORIZQ expresion CORDER PTCOMA&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;El valor de la expresión es: &#x27;</span> + str(t[3]))</span><br><span class="line"></span><br><span class="line">def p_expresion_binaria(t):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;expresion : expresion MAS expresion</span></span><br><span class="line"><span class="string">                  | expresion MENOS expresion</span></span><br><span class="line"><span class="string">                  | expresion POR expresion</span></span><br><span class="line"><span class="string">                  | expresion DIVIDIDO expresion&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> t[2] == <span class="string">&#x27;+&#x27;</span>  : t[0] = t[1] + t[3]</span><br><span class="line">    <span class="keyword">elif</span> t[2] == <span class="string">&#x27;-&#x27;</span>: t[0] = t[1] - t[3]</span><br><span class="line">    <span class="keyword">elif</span> t[2] == <span class="string">&#x27;*&#x27;</span>: t[0] = t[1] * t[3]</span><br><span class="line">    <span class="keyword">elif</span> t[2] == <span class="string">&#x27;/&#x27;</span>: t[0] = t[1] / t[3]</span><br><span class="line"></span><br><span class="line">def p_expresion_unaria(t):</span><br><span class="line">    <span class="string">&#x27;expresion : MENOS expresion %prec UMENOS&#x27;</span></span><br><span class="line">    t[0] = -t[2]</span><br><span class="line"></span><br><span class="line">def p_expresion_agrupacion(t):</span><br><span class="line">    <span class="string">&#x27;expresion : PARIZQ expresion PARDER&#x27;</span></span><br><span class="line">    t[0] = t[2]</span><br><span class="line"></span><br><span class="line">def p_expresion_number(t):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;expresion    : ENTERO</span></span><br><span class="line"><span class="string">                    | DECIMAL&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    t[0] = t[1]</span><br><span class="line"></span><br><span class="line">def p_error(t):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error sintáctico en &#x27;%s&#x27;&quot;</span> % t.value)</span><br></pre></td></tr></table></figure>

<p>Por último, podemos manejar también las producciones de error para el manejo de errores sintácticos.</p>
<p>Ahora construimos el analizador sintáctico,la funcionalidad para leer el archivo y enviarle su contenido a nuestro compilador.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import ply.yacc as yacc</span><br><span class="line">parser = yacc.yacc()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">&quot;./entrada.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">input = f.read()</span><br><span class="line"><span class="built_in">print</span>(input)</span><br><span class="line">parser.parse(input)</span><br></pre></td></tr></table></figure>

<h3 id="Creando-un-archivo-de-entrada-para-nuestro-analizador"><a href="#Creando-un-archivo-de-entrada-para-nuestro-analizador" class="headerlink" title="Creando un archivo de entrada para nuestro analizador"></a><strong>Creando un archivo de entrada para nuestro analizador</strong></h3><p>Creamos un nuevo archivo de texto utilizando nuestro editor llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoPly/blob/master/entrada.txt">entrada.txt</a>. El contenido de este archivo es el siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1+1];</span><br><span class="line">Evaluar[1+1*2];</span><br><span class="line">Evaluar[-(1+1*6/3-5+7)];</span><br><span class="line">Evaluar[-(1+1*6/3-5+1*-2)];</span><br><span class="line">Evaluar[-(1.6+1.45)];</span><br></pre></td></tr></table></figure>

<p>Ejecución</p>
<p>Para ejecutar este script corremos el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  python3 .\gramatica.py</span><br></pre></td></tr></table></figure>

<p>Como podemos ver, obtenemos la salida esperada.</p>



<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/rjanixz">Rainman Sián</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Erick Navarro"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Erick Navarro</p><p class="is-size-6 is-block">Data Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Guatemala</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.linkedin.com/in/ericknd/" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ericknavarro"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LinkedIn" href="https://www.linkedin.com/in/ericknd/"><i class="fab fa-linkedin"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AWS/"><span class="level-start"><span class="level-item">AWS</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/AWS/Alexa-Skills/"><span class="level-start"><span class="level-item">Alexa Skills</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/CloudFront/"><span class="level-start"><span class="level-item">CloudFront</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/EC2/"><span class="level-start"><span class="level-item">EC2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/Lambda/"><span class="level-start"><span class="level-item">Lambda</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/Route-53/"><span class="level-start"><span class="level-item">Route 53</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/S3/"><span class="level-start"><span class="level-item">S3</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Computer-Science/"><span class="level-start"><span class="level-item">Computer Science</span></span><span class="level-end"><span class="level-item tag">19</span></span></a><ul><li><a class="level is-mobile" href="/categories/Computer-Science/Compilers/"><span class="level-start"><span class="level-item">Compilers</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Computer-Science/Data-Structures/"><span class="level-start"><span class="level-item">Data Structures</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Programming/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/2020/10/01/27-Mi-primer-proyecto-utilizando-Yacc-y-Lex/"><img src="/gallery/thumbnails/27.png" alt="Mi primer proyecto utilizando Yacc y Lex"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-10-01T21:03:28.000Z">2020-10-01</time></p><p class="title"><a href="/2020/10/01/27-Mi-primer-proyecto-utilizando-Yacc-y-Lex/">Mi primer proyecto utilizando Yacc y Lex</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/03/15/26-Interprete-sencillo-utilizando-PLY/"><img src="/gallery/thumbnails/26.png" alt="Intérprete sencillo utilizando PLY con Python 3"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-03-16T01:09:28.000Z">2020-03-15</time></p><p class="title"><a href="/2020/03/15/26-Interprete-sencillo-utilizando-PLY/">Intérprete sencillo utilizando PLY con Python 3</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/03/07/25-Interprete-sencillo-utilizando-Javacc/"><img src="/gallery/thumbnails/25.png" alt="Intérprete sencillo utilizando JavaCC"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-03-07T19:53:33.000Z">2020-03-07</time></p><p class="title"><a href="/2020/03/07/25-Interprete-sencillo-utilizando-Javacc/">Intérprete sencillo utilizando JavaCC</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/02/10/24-Mi-primer-proyecto-utilizando-PLY/"><img src="/gallery/thumbnails/24.png" alt="Mi primer proyecto utilizando PLY con Python 3"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-02-10T22:17:25.000Z">2020-02-10</time></p><p class="title"><a href="/2020/02/10/24-Mi-primer-proyecto-utilizando-PLY/">Mi primer proyecto utilizando PLY con Python 3</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/02/10/23-Mi-primer-proyecto-utilizando-JavaCC/"><img src="/gallery/thumbnails/23.png" alt="Mi primer proyecto utilizando JavaCC"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-02-10T22:14:34.000Z">2020-02-10</time></p><p class="title"><a href="/2020/02/10/23-Mi-primer-proyecto-utilizando-JavaCC/">Mi primer proyecto utilizando JavaCC</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">October 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">August 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">May 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">April 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Alexa-Skills/"><span class="tag">Alexa Skills</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C#</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CloudFront/"><span class="tag">CloudFront</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compilers/"><span class="tag">Compilers</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Data-Structures/"><span class="tag">Data Structures</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EC2/"><span class="tag">EC2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lambda/"><span class="tag">Lambda</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Route-53/"><span class="tag">Route 53</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/S3/"><span class="tag">S3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Visual-Basic/"><span class="tag">Visual Basic</span><span class="tag">4</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Erick Navarro" height="28"></a><p class="is-size-7"><span>&copy; 2025 Erick Navarro</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>