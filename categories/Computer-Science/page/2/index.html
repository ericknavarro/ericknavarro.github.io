<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: Computer Science - Erick Navarro</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Erick Navarro"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Erick Navarro"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Erick Navarro"><meta property="og:url" content="https://ericknavarro.github.io/"><meta property="og:site_name" content="Erick Navarro"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://ericknavarro.github.io/img/og_image.png"><meta property="article:author" content="Erick Navarro"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ericknavarro.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ericknavarro.github.io"},"headline":"Erick Navarro","image":["https://ericknavarro.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Erick Navarro"},"publisher":{"@type":"Organization","name":"Erick Navarro","logo":{"@type":"ImageObject","url":"https://ericknavarro.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-145306707-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-145306707-1');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Erick Navarro" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Connect on LinkedIn" href="https://www.linkedin.com/in/ericknd/"><i class="fab fa-linkedin"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories/">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Computer Science</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-07-22T00:46:08.000Z" title="7/21/2019, 6:46:08 PM">2019-07-21</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/21/17-Mi-primer-proyecto-utilizando-Jison-Linux/">Mi primer proyecto utilizando Jison (Linux)</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presenta como salida el resultado de dichas expresiones.</p>
<p>Las tecnologías a utilizar son:</p>
<ul>
<li><strong>Jison</strong>: Generador de analizadores léxicos y sintácticos.</li>
<li><strong>Nodejs</strong>: Es un entorno en tiempo de ejecución, multiplataforma, capaz de ejecutar javascript fuera de un explorador. </li>
<li><strong>Ubuntu 18.04</strong>: Sistema operativo.</li>
<li><strong>Visual Studio Code</strong>: Es un editor de código ligero pero poderoso. Viene con soporte integrado para JavaScript, Nodejs, entre otros.</li>
</ul>
<p>El proyecto completo lo pueden descargar del siguiente enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJisonJS">Mi primer proyecto utilizando Jison con Nodejs (Ubuntu)</a></li>
</ul>
<h3 id="Jison"><a href="#Jison" class="headerlink" title="Jison"></a><strong>Jison</strong></h3><p>Jison toma una gramática libre de contexto como entrada y produce código JavaScript capaz de parsear el lenguaje descrito por dicha gramática. Una vez se tenga el script generado podemos usarlo para parsear la entrada y aceptarla, rechazarla o ejecutar acciones con base en la entrada. Si se está familiarizado con <a target="_blank" rel="noopener" href="https://www.gnu.org/software/bison/">Bison</a>, <a target="_blank" rel="noopener" href="http://dinosaur.compilertools.net/yacc/">Yacc</a> o algún otro similar ya se está listo para iniciar. Jison genera tanto el analizador léxico como el analizador sintáctico.</p>
<p>La principal tarea de un analizador léxico es leer los caracteres de entrada del programa fuente, agruparlos en lexemas y producir como salida una secuencia de tokens.</p>
<ul>
<li><p>Un <em>token</em> es un par que consiste en un nombre de token y un valor de atributo opcional.</p>
</li>
<li><p>Un <em>lexema</em> es una secuencia de caracteres en el programa fuente, que coinciden con el patrón para un token y que el analizador léxico identifica como una instancia de este tóken.</p>
</li>
<li><p>Un <em>patrón</em> es una descripción de la forma que pueden tomar los lexemas de un token.</p>
</li>
</ul>
<p>El analizador sintáctico obtiene una cadena de tokens del analizador léxico y verifica que dicha cadena pueda generarse con la gramática para el lenguaje fuente. Una gramática proporciona una especificación precisa y fácil de entender de un lenguaje de programación.</p>
<p>En Jison se definen tanto el analizador léxico como el sintáctico. Esto es una gran ventaja pues podemos trabajar en una sola herramienta.</p>
<h3 id="Pre-requisitos"><a href="#Pre-requisitos" class="headerlink" title="Pre-requisitos"></a><strong>Pre-requisitos</strong></h3><p>Para este ejemplo hace falta que tengamos instalado:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/en/"><strong>Nodejs</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com/"><strong>npm</strong></a></li>
</ul>
<p>Para instalar Nodejs en Ubuntu basta con ejecutar el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install nodejs</span><br></pre></td></tr></table></figure>


<p>Para verificar que la instalación haya sido correcta ejecutamos el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nodejs --version</span><br></pre></td></tr></table></figure>


<p>Luego procedemos a instalar npm. Para esto ejecutamos el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install npm</span><br></pre></td></tr></table></figure>



<p>Y verificamos la instalación con el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm --version</span><br></pre></td></tr></table></figure>



<h3 id="Instalar-Jison"><a href="#Instalar-Jison" class="headerlink" title="Instalar Jison"></a><strong>Instalar Jison</strong></h3><p>Instalamos <a target="_blank" rel="noopener" href="https://zaa.ch/jison/">Jison</a> con el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> npm install jison -g</span><br></pre></td></tr></table></figure>



<p>La bandera -g nos sirve para indicar que instalaremos Jison de manera global, es decir, estará disponible en cualquier directorio del sistema.</p>
<h3 id="Crear-nuestro-proyecto"><a href="#Crear-nuestro-proyecto" class="headerlink" title="Crear nuestro proyecto"></a><strong>Crear nuestro proyecto</strong></h3><p>Usaremos npm para crear nuestro proyecto. Primero crearemos un nuevo folder, en este caso lo llamaremos ProyectoJisonUbuntu. Para esto abrimos una nueva terminal, nos ubicamos donde queremos crear el proyecto y ejecutamos el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> ProyectoJisonUbuntu</span><br></pre></td></tr></table></figure>

<p>Y luego ingresamos al directorio con el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ProyectoJisonUbuntu</span><br></pre></td></tr></table></figure>


<p>Ahora procedemos a iniciar el proyecto con npm. Para esto ejecutamos el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br></pre></td></tr></table></figure>



<p>Con esto habremos iniciado el proyecto. La bandera -y sirve para seleccionar valores por defecto en los parámetros de inicialización. </p>
<p>Ahora nos pasamos a nuestro editor de texto, en este caso usaremos Visual Studio Code. Ejecutamos el siguiente comando para abrir Code con nuestro proyecto directamente.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ code .</span><br></pre></td></tr></table></figure>



<p>Code se desplegará con nuestro proyecto llamado ProyectoJisonUbuntu</p>
 

<p>Nótese que únicamente contiene el archivo package.json el cual fue creado por el comando npm init.</p>
<p>Procedemos a crear un nuevo archivo llamado gramatica.jison</p>


<h3 id="Codigo-Fuente-para-el-analizador-lexico-y-sintactico"><a href="#Codigo-Fuente-para-el-analizador-lexico-y-sintactico" class="headerlink" title="Código Fuente para el analizador léxico y sintáctico"></a><strong>Código Fuente para el analizador léxico y sintáctico</strong></h3><p>En el archivo gramática.jison le indicamos a Jison la descripción de nuestra gramática.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ejemplo mi primer proyecto con Jison utilizando Nodejs en Ubuntu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Definición Léxica */</span></span><br><span class="line">%lex</span><br><span class="line"></span><br><span class="line">%options <span class="keyword">case</span>-insensitive</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Evaluar&quot;</span>           <span class="keyword">return</span> <span class="string">&#x27;REVALUAR&#x27;</span>;</span><br><span class="line"><span class="string">&quot;;&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;PTCOMA&#x27;</span>;</span><br><span class="line"><span class="string">&quot;(&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;PARIZQ&#x27;</span>;</span><br><span class="line"><span class="string">&quot;)&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;PARDER&#x27;</span>;</span><br><span class="line"><span class="string">&quot;[&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;CORIZQ&#x27;</span>;</span><br><span class="line"><span class="string">&quot;]&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;CORDER&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;+&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;MAS&#x27;</span>;</span><br><span class="line"><span class="string">&quot;-&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;MENOS&#x27;</span>;</span><br><span class="line"><span class="string">&quot;*&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;POR&#x27;</span>;</span><br><span class="line"><span class="string">&quot;/&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;DIVIDIDO&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Espacios en blanco */</span></span><br><span class="line">[ \r\t]+            &#123;&#125;</span><br><span class="line">\n                  &#123;&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>-<span class="number">9</span>]+(<span class="string">&quot;.&quot;</span>[<span class="number">0</span>-<span class="number">9</span>]+)?\b    <span class="keyword">return</span> <span class="string">&#x27;DECIMAL&#x27;</span>;</span><br><span class="line">[<span class="number">0</span>-<span class="number">9</span>]+\b                <span class="keyword">return</span> <span class="string">&#x27;ENTERO&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&lt;&lt;<span class="variable constant_">EOF</span>&gt;&gt;                 <span class="keyword">return</span> <span class="string">&#x27;EOF&#x27;</span>;</span><br><span class="line"></span><br><span class="line">.                       &#123; <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Este es un error léxico: &#x27;</span> + yytext + <span class="string">&#x27;, en la linea: &#x27;</span> + yylloc.<span class="property">first_line</span> + <span class="string">&#x27;, en la columna: &#x27;</span> + yylloc.<span class="property">first_column</span>); &#125;</span><br><span class="line">/lex</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Asociación de operadores y precedencia */</span></span><br><span class="line"></span><br><span class="line">%left <span class="string">&#x27;MAS&#x27;</span> <span class="string">&#x27;MENOS&#x27;</span></span><br><span class="line">%left <span class="string">&#x27;POR&#x27;</span> <span class="string">&#x27;DIVIDIDO&#x27;</span></span><br><span class="line">%left <span class="variable constant_">UMENOS</span></span><br><span class="line"></span><br><span class="line">%start ini</span><br><span class="line"></span><br><span class="line">%% <span class="comment">/* Definición de la gramática */</span></span><br><span class="line"></span><br><span class="line">ini</span><br><span class="line">	: instrucciones <span class="variable constant_">EOF</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">instrucciones</span><br><span class="line">	: instruccion instrucciones</span><br><span class="line">	| instruccion</span><br><span class="line">	| error &#123; <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Este es un error sintáctico: &#x27;</span> + yytext + <span class="string">&#x27;, en la linea: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">_$</span>.<span class="property">first_line</span> + <span class="string">&#x27;, en la columna: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">_$</span>.<span class="property">first_column</span>); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">instruccion</span><br><span class="line">	: <span class="variable constant_">REVALUAR</span> <span class="variable constant_">CORIZQ</span> expresion <span class="variable constant_">CORDER</span> <span class="variable constant_">PTCOMA</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;El valor de la expresión es: &#x27;</span> + $3);</span><br><span class="line">	&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expresion</span><br><span class="line">	: <span class="variable constant_">MENOS</span> expresion %prec <span class="variable constant_">UMENOS</span>  &#123; $$ = $2 *-<span class="number">1</span>; &#125;</span><br><span class="line">	| expresion <span class="variable constant_">MAS</span> expresion       &#123; $$ = $1 + $3; &#125;</span><br><span class="line">	| expresion <span class="variable constant_">MENOS</span> expresion     &#123; $$ = $1 - $3; &#125;</span><br><span class="line">	| expresion <span class="variable constant_">POR</span> expresion       &#123; $$ = $1 * $3; &#125;</span><br><span class="line">	| expresion <span class="variable constant_">DIVIDIDO</span> expresion  &#123; $$ = $1 / $3; &#125;</span><br><span class="line">	| <span class="variable constant_">ENTERO</span>                        &#123; $$ = <span class="title class_">Number</span>($1); &#125;</span><br><span class="line">	| <span class="variable constant_">DECIMAL</span>                       &#123; $$ = <span class="title class_">Number</span>($1); &#125;</span><br><span class="line">	| <span class="variable constant_">PARIZQ</span> expresion <span class="variable constant_">PARDER</span>       &#123; $$ = $2; &#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-lexico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Explicación del código fuente para el analizador léxico"></a><strong>Explicación del código fuente para el analizador léxico</strong></h3><p>Iniciamos indicando que queremos iniciar con la definición léxica, posteriormente agregamos las opciones que deseamos. En este caso indicamos que nuestro analizador no distinguirá diferencias entre mayúsculas y minúsculas.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Definición Léxica */</span></span><br><span class="line">%lex</span><br><span class="line"></span><br><span class="line">%options <span class="keyword">case</span>-insensitive</span><br></pre></td></tr></table></figure>

<p>A diferencia de otras herramientas, Jison por defecto cuenta la posición de línea y columna de los caracteres y acepta el conjunto de caracteres unicode.</p>
<p>Luego escribimos los patrones para los tokens que deseamos reconocer. Para cada uno de ellos debemos retornar el nombre asociado al token.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Evaluar&quot;</span>           <span class="keyword">return</span> <span class="string">&#x27;REVALUAR&#x27;</span>;</span><br><span class="line"><span class="string">&quot;;&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;PTCOMA&#x27;</span>;</span><br><span class="line"><span class="string">&quot;(&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;PARIZQ&#x27;</span>;</span><br><span class="line"><span class="string">&quot;)&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;PARDER&#x27;</span>;</span><br><span class="line"><span class="string">&quot;[&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;CORIZQ&#x27;</span>;</span><br><span class="line"><span class="string">&quot;]&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;CORDER&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;+&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;MAS&#x27;</span>;</span><br><span class="line"><span class="string">&quot;-&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;MENOS&#x27;</span>;</span><br><span class="line"><span class="string">&quot;*&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;POR&#x27;</span>;</span><br><span class="line"><span class="string">&quot;/&quot;</span>                 <span class="keyword">return</span> <span class="string">&#x27;DIVIDIDO&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>Jison también soporta el uso de expresiones regulares para identificar patrones. En las siguientes instrucciones escribimos una expresión regular para identificar espacios en blanco e indicamos que al ser reconocidos no hacemos nada. Esto se hace a través de un par de llaves vacíos.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Espacios en blanco */</span></span><br><span class="line">[ \r\t]+            &#123;&#125;</span><br><span class="line">\n                  &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Escribimos expresiones regulares para identificar enteros y decimales.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>-<span class="number">9</span>]+(<span class="string">&quot;.&quot;</span>[<span class="number">0</span>-<span class="number">9</span>]+)?\b    <span class="keyword">return</span> <span class="string">&#x27;DECIMAL&#x27;</span>;</span><br><span class="line">[<span class="number">0</span>-<span class="number">9</span>]+\b                <span class="keyword">return</span> <span class="string">&#x27;ENTERO&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>Las últimas dos expresiones son para reconocer el fin de la entrada y caracteres no válidos.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;<span class="variable constant_">EOF</span>&gt;&gt;                 <span class="keyword">return</span> <span class="string">&#x27;EOF&#x27;</span>;</span><br><span class="line"></span><br><span class="line">.                       &#123; <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Este es un error léxico: &#x27;</span> + yytext + <span class="string">&#x27;, en la linea: &#x27;</span> + yylloc.<span class="property">first_line</span> + <span class="string">&#x27;, en la columna: &#x27;</span> + yylloc.<span class="property">first_column</span>); &#125;</span><br><span class="line">/lex</span><br></pre></td></tr></table></figure>

<p>En caso de encontrarse con un error léxico lo desplegamos en consola.</p>
<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-sintactico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Explicación del código fuente para el analizador sintáctico"></a><strong>Explicación del código fuente para el analizador sintáctico</strong></h3><p>Otra de las ventajas de Jison es que en el mismo archivo podemos definir nuestro análisis sintáctico haciendo uso de los tokens previamente definidos en la sección del analizador léxico.</p>
<p>Primeramente definimos la asociatividad y precedencia de los operadores, ya que la gramática escrita es ambigua, es necesario definir una precedencia para que el analizador no entre en conflicto al analizar, en este caso la precedencia es la misma que la de los operadores aritméticos, la precedencia más baja la tienen la suma y la resta, luego están la multiplicación y la división que tienen una precedencia más alta y por último está el signo menos de las expresiones negativas que tendría la precedencia más alta</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Asociación de operadores y precedencia */</span></span><br><span class="line"></span><br><span class="line">%left <span class="string">&#x27;MAS&#x27;</span> <span class="string">&#x27;MENOS&#x27;</span></span><br><span class="line">%left <span class="string">&#x27;POR&#x27;</span> <span class="string">&#x27;DIVIDIDO&#x27;</span></span><br><span class="line">%left <span class="variable constant_">UMENOS</span></span><br></pre></td></tr></table></figure>

<p>Debemos indicarle a Jison cual será nuestro símbolo Inicial.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%start ini</span><br></pre></td></tr></table></figure>

<p>Finalmente, escribimos nuestras producciones, aquí vemos otra de las ventajas de Jison, cada No Terminal no debe definirse previamente, esto lo hace más práctico pero a la vez se debe de tener más cuidado con errores de escritura.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%% <span class="comment">/* Definición de la gramática */</span></span><br><span class="line"></span><br><span class="line">ini</span><br><span class="line">	: instrucciones <span class="variable constant_">EOF</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">instrucciones</span><br><span class="line">	: instruccion instrucciones</span><br><span class="line">	| instruccion</span><br><span class="line">	| error &#123; <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Este es un error sintáctico: &#x27;</span> + yytext + <span class="string">&#x27;, en la linea: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">_$</span>.<span class="property">first_line</span> + <span class="string">&#x27;, en la columna: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">_$</span>.<span class="property">first_column</span>); &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">instruccion</span><br><span class="line">	: <span class="variable constant_">REVALUAR</span> <span class="variable constant_">CORIZQ</span> expresion <span class="variable constant_">CORDER</span> <span class="variable constant_">PTCOMA</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;El valor de la expresión es: &#x27;</span> + $3);</span><br><span class="line">	&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expresion</span><br><span class="line">	: <span class="variable constant_">MENOS</span> expresion %prec <span class="variable constant_">UMENOS</span>  &#123; $$ = $2 *-<span class="number">1</span>; &#125;</span><br><span class="line">	| expresion <span class="variable constant_">MAS</span> expresion       &#123; $$ = $1 + $3; &#125;</span><br><span class="line">	| expresion <span class="variable constant_">MENOS</span> expresion     &#123; $$ = $1 - $3; &#125;</span><br><span class="line">	| expresion <span class="variable constant_">POR</span> expresion       &#123; $$ = $1 * $3; &#125;</span><br><span class="line">	| expresion <span class="variable constant_">DIVIDIDO</span> expresion  &#123; $$ = $1 / $3; &#125;</span><br><span class="line">	| <span class="variable constant_">ENTERO</span>                        &#123; $$ = <span class="title class_">Number</span>($1); &#125;</span><br><span class="line">	| <span class="variable constant_">DECIMAL</span>                       &#123; $$ = <span class="title class_">Number</span>($1); &#125;</span><br><span class="line">	| <span class="variable constant_">PARIZQ</span> expresion <span class="variable constant_">PARDER</span>       &#123; $$ = $2; &#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>Al final de cada producción se puede  incluir código javascript entre llaves “{ &lt;código javascript&gt; }”. Para sintetizar un valor asociado al no terminal de lado izquierdo de la producción hacemos uso de la variable $$. Esta variable es propia de Jison. Como podemos ver, para cada producción del no terminal “expresion” sintetizamos el valor de la operación aritmética o el valor del token aceptado. </p>
<p>La variable $$ puede tomar cualquier valor, recordemos que Jison al estar basado en javascript el tipo puede ser dinámico. </p>
<p>Nótese el terminal EOF, que indica el fin de la entrada, debe agregarse en nuestra gramática luego de haber reconocido nuestra entrada, esto indicará que hemos terminado. Si se omite este terminal obtendremos una excepción cuando nuestro analizador alcance el final del archivo.</p>
<p>Por último, podemos manejar también las producciones de error para el manejo de errores sintácticos.</p>
<h3 id="El-archivo-de-compilacion"><a href="#El-archivo-de-compilacion" class="headerlink" title="El archivo de compilación"></a><strong>El archivo de compilación</strong></h3><p>Para facilitar la compilación de nuestra gramática y poder obtener el script para nuestro parser procedemos a escribir un archivo sh.</p>
<p>Para esto creamos un nuevo archivo en Code llamado compilar.sh con el siguiente contenido:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Procesando gramática...&quot;</span></span><br><span class="line"></span><br><span class="line">jison gramatica.jison</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Gramática procesada...&quot;</span></span><br></pre></td></tr></table></figure>

<p>Para ejecutar nuestro script ejecutamos el siguiente comando en la terminal:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh compilar.sh</span><br></pre></td></tr></table></figure>

<p>Nos debe aparecer el siguiente resultado:</p>


<p>Si hubiese algún error debemos revisar que nuestra gramática esté correcta.</p>
<p>El comando nos generará el script en un archivo llamado gramatica.js en nuestro proyecto. Este es el script que utilizaremos para procesar nuestros archivos de entrada.</p>


<h3 id="Creando-un-archivo-de-entrada-para-nuestro-analizador"><a href="#Creando-un-archivo-de-entrada-para-nuestro-analizador" class="headerlink" title="Creando un archivo de entrada para nuestro analizador"></a><strong>Creando un archivo de entrada para nuestro analizador</strong></h3><p>Creamos un nuevo archivo de texto utilizando nuestro editor llamado entrada.txt. El contenido de este archivo es el siguiente:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Evaluar</span>[<span class="number">1</span>+<span class="number">1</span>];</span><br><span class="line"><span class="title class_">Evaluar</span>[<span class="number">1</span>+<span class="number">1</span>*<span class="number">2</span>];</span><br><span class="line"><span class="title class_">Evaluar</span>[-(<span class="number">1</span>+<span class="number">1</span>*<span class="number">6</span>/<span class="number">3</span>-<span class="number">5</span>+<span class="number">7</span>)];</span><br><span class="line"><span class="title class_">Evaluar</span>[-(<span class="number">1</span>+<span class="number">1</span>*<span class="number">6</span>/<span class="number">3</span>-<span class="number">5</span>+<span class="number">1</span>*-<span class="number">2</span>)];</span><br><span class="line"><span class="title class_">Evaluar</span>[-(<span class="number">1.6</span>+<span class="number">1.45</span>)];</span><br></pre></td></tr></table></figure>

<h3 id="Script-Principal"><a href="#Script-Principal" class="headerlink" title="Script Principal"></a><strong>Script Principal</strong></h3><p>Necesitamos de un script que nos ayude a leer el archivo de entrada e invocar a nuestro parser con su contenido. Para esto creamos un nuevo archivo de texto y lo nombramos parser.js. </p>
<p>Su contenido es el siguiente:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); </span><br><span class="line"><span class="keyword">var</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;./gramatica&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./entrada.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    parser.<span class="title function_">parse</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Hacemos uso de la librería fs de Nodejs para leer archivos y también de nuestro parser. Esto lo hacemos a través de la función require.</p>
<p>Luego invocamos al método readFile el cual lee nuestro archivo de entrada ‘entrdata.txt’. Este método devuelve dos parámetros, err el cual indica si hubo algún error y data, que almacena el contenido del archivo.</p>
<p>Validamos que no haya ocurrido error y con el contenido de nuestro archivo de entrada invocamos a nuestro parser.</p>
<p>Para ejecutar este script corremos el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node parser</span><br></pre></td></tr></table></figure>



<p>Como podemos ver, obtenemos la salida esperada.</p>
<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/rjanixz">Rainman Sián</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:40.000Z" title="4/26/2019, 3:21:40 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Data-Structures/">Data Structures</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/09-Graficar-arboles-binarios-de-busqueda-con-Graphviz-y-Java/">Graficar árboles binarios de búsqueda con Graphviz y Java</a></p><div class="content"><p>En este tutorial se desarrolla un ejemplo sencillo en el que se grafica un árbol binario de búsqueda con ayuda de la herramienta Graphviz. Es importante mencionar que para que ejemplo funcione correctamente debe estar instalado Graphviz. Este proyecto se desarrolló utilizando Ubuntu 14.04 y Netbeans 8.0. El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ABBGraphviz">Graficar árboles binarios de búsqueda con Graphviz y Java</a>.</p>
<p>Todo el código dentro del proyecto está documentado con comentarios que contienen explicaciones sobre su funcionamiento.</p>
<h3 id="Instalacion-de-Graphviz"><a href="#Instalacion-de-Graphviz" class="headerlink" title="Instalación de Graphviz"></a><strong>Instalación de Graphviz</strong></h3><p>Lo primero que haremos será instalar Graphviz, en caso de que no lo hayamos instalado todavía, para ello abrimos una terminal, en Ubuntu puede hacerse con la combinación de teclas Ctrl+Alt+t o en Aplicaciones → Accesorios → Terminal, una vez abierta la terminal ingresamos el comando “sudo apt-get install graphviz”, autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado Graphviz.</p>


<h3 id="Funcionamiento-del-proyecto"><a href="#Funcionamiento-del-proyecto" class="headerlink" title="Funcionamiento del proyecto"></a><strong>Funcionamiento del proyecto</strong></h3><p>El proyecto cuenta con la clase <em>ArbolBinarioBusqueda</em>, en el método principal de la aplicación, se instancian dos objetos de esta clase, es decir, dos árboles binarios de búsqueda, el primero almacena únicamente texto y el segundo únicamente números. El código de la clase principal de la aplicación es el siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Ejemplo desarrollado por Erick Navarro</span><br><span class="line"> * GitHub Page: ericknavarro.github.io</span><br><span class="line"> * Octubre - 2015</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">package abbgraphviz;</span><br><span class="line"></span><br><span class="line">import abb.ArbolBinarioBusqueda;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Clase principal de la aplicación.</span><br><span class="line"> * @author Erick Navarro</span><br><span class="line"> */</span><br><span class="line">public class ABBGraphviz &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Método principal de la aplicación</span><br><span class="line">     * @param args los argumentos de la línea de comando</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Creamos un árbol cuyos nodos contendrán solamente texto</span><br><span class="line">        ArbolBinarioBusqueda arbol_texto=new ArbolBinarioBusqueda();</span><br><span class="line">        //Llenamos con información el árbol</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Juan&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Pedro&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;María&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Roberto&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Teodoro&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Manuel&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Diego&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Alejandro&quot;</span>);</span><br><span class="line">        //Graficamos el árbol generando la imagen arbol_texto.jpg</span><br><span class="line">        arbol_texto.graficar(<span class="string">&quot;arbol_texto.jpg&quot;</span>);</span><br><span class="line">        //Imprimimos el contenido del árbol ordenado</span><br><span class="line">        arbol_texto.inorden();</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        //Creamos un árbol cuyos nodos contendrán solamente numeros</span><br><span class="line">        ArbolBinarioBusqueda arbol_numeros=new ArbolBinarioBusqueda();</span><br><span class="line">        //Llenamos con información el árbol</span><br><span class="line">        arbol_numeros.insertar(12);</span><br><span class="line">        arbol_numeros.insertar(5);</span><br><span class="line">        arbol_numeros.insertar(26);</span><br><span class="line">        arbol_numeros.insertar(33);</span><br><span class="line">        arbol_numeros.insertar(59);</span><br><span class="line">        arbol_numeros.insertar(27);</span><br><span class="line">        arbol_numeros.insertar(15);      </span><br><span class="line">        //Graficamos el árbol generando la imagen arbol_numeros.jpg</span><br><span class="line">        arbol_numeros.graficar(<span class="string">&quot;arbol_numeros.jpg&quot;</span>);</span><br><span class="line">        //Imprimimos el contenido del árbol ordenado</span><br><span class="line">        arbol_numeros.inorden();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Al ser ejecutada la aplicación, se generan dos imagenes, una para cada árbol la primera *arbol_texto.jpg *corresponde al árbol que solo almacena texto en sus nodos.</p>


<p>La segunda <em>arbol_numeros.jpg</em> corresponde al árbol que solo almacena números.</p>


<p>En la consola se verán los elementos de ambos árboles impresos en orden, esto se logra haciendo un recorrido <em>enorden</em> de los arboles binarios de búsqueda.</p>


<h3 id="Arbol-binario-de-busqueda"><a href="#Arbol-binario-de-busqueda" class="headerlink" title="Árbol binario de búsqueda"></a><strong>Árbol binario de búsqueda</strong></h3><p>En un árbol binario, todos los nodos tienen como máximo dos hijos.</p>
<p>“Un <strong>árbol binario de búsqueda</strong> es aquel que dado un nodo, todos los datos del subárbol izquierdo son menores que los datos de ese nodo, mientras que todos los datos del subárbol derecho son mayores que sus propios datos.”</p>
<p><em>Fuente: Programación en Java 2. Luis Joyanes Aguilar, Ignacio Zahonero Martínez.</em></p>
<p>En este árbol únicamente se desarrolla el método para insertar nodos, porque el objetivo de la aplicación es únicamente graficar el árbol, adicionalmente, podrían desarrollarse métodos para eliminar nodos, buscar nodos, vaciar el árbol, calcular la profundidad del árbol, etc. El único recorrido que se hace del árbol es el <em>enorden</em>, que muestra los nodos del árbol ordenados, pero existen otros recorridos que también podrían implementarse como el recorrido <em>preorden</em>, <em>postorden</em> o el recorrido por anchura.</p>
<h3 id="Interfaz-Comparable-El-secreto-tras-la-flexibilidad-de-este-arbol"><a href="#Interfaz-Comparable-El-secreto-tras-la-flexibilidad-de-este-arbol" class="headerlink" title="Interfaz Comparable: El secreto tras la flexibilidad de este árbol"></a><strong>Interfaz Comparable: El secreto tras la flexibilidad de este árbol</strong></h3><p>La razón por la cual este árbol puede utilizarse para almacenar cadenas o bien para almacenar números es la interfaz <em>Comparable.</em> Lo que almacena el nodo es la instancia de una clase que implementa la interfaz <em>Comparable</em>, por supuesto que todos los nodos tienen que poder compararse satisfactoriamente, por ejemplo no se podrían almacenar números enteros y también cadenas de caracteres en un mismo árbol, ya que no podrían comparase satisfactoriamente porque se daría un problema de tipos. Pero si todos los nodos almacenan números, el árbol funciona sin problemas, al igual cuando todos los nodos almacenan cadenas.</p>
<p>Si deseáramos almacenar otro tipo de información podríamos programar una clase que contenga los atributos que deseamos y que implemente la interfaz <em>Comparable</em>, entonces sin modificar el árbol podríamos almacenar esta información.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Programación en Java 2. Algoritmos, estructuras de datos y programación orientada a objetos. Luis Joyanes Aguilar, Ignacio Zahonero Martínez.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:38.000Z" title="4/26/2019, 3:21:38 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Data-Structures/">Data Structures</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/08-Graficar-arboles-AVL-con-Graphviz-y-Java/">Graficar árboles AVL con Graphviz y Java</a></p><div class="content"><p>En este tutorial se desarrolla un ejemplo sencillo en el que se grafica un árbol AVL con ayuda de la herramienta Graphviz. Es importante mencionar que para que ejemplo funcione correctamente debe estar instalado Graphviz. Este proyecto se desarrolló utilizando Ubuntu 14.04 y Netbeans 8.0. El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/AVLGraphviz">Graficar árboles AVL con Graphviz y Java</a>.</p>
<p>Todo el código dentro del proyecto está documentado con comentarios que contienen explicaciones sobre su funcionamiento.</p>
<h3 id="Instalacion-de-Graphviz"><a href="#Instalacion-de-Graphviz" class="headerlink" title="Instalación de Graphviz"></a><strong>Instalación de Graphviz</strong></h3><p>Lo primero que haremos será instalar Graphviz, en caso de que no lo hayamos instalado todavía, para ello abrimos una terminal, en Ubuntu puede hacerse con la combinación de teclas Ctrl+Alt+t o en Aplicaciones → Accesorios → Terminal, una vez abierta la terminal ingresamos el comando “sudo apt-get install graphviz”, autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado Graphviz.</p>


<h3 id="Funcionamiento-del-proyecto"><a href="#Funcionamiento-del-proyecto" class="headerlink" title="Funcionamiento del proyecto"></a><strong>Funcionamiento del proyecto</strong></h3><p>El proyecto cuenta con la clase ArbolAVL, en el método principal de la aplicación, se instancian dos objetos de esta clase, es decir, dos árboles AVL, el primero almacena únicamente texto y el segundo únicamente números. El código de la clase principal de la aplicación es el siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Ejemplo desarrollado por Erick Navarro</span><br><span class="line"> * GitHub Page: ericknavarro.github.io</span><br><span class="line"> * Octubre - 2015</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">package avlgraphviz;</span><br><span class="line"></span><br><span class="line">import avl.ArbolAVL;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Clase principal de la aplicación.</span><br><span class="line"> * @author Erick Navarro</span><br><span class="line"> */</span><br><span class="line">public class AVLGraphviz &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Método principal de la aplicación</span><br><span class="line">     * @param args los argumentos de la línea de comando.</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Creamos un árbol cuyos nodos contendrán solamente texto</span><br><span class="line">        ArbolAVL arbol_texto=new ArbolAVL();</span><br><span class="line">        //Llenamos con información el árbol</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Juan&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Pedro&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;María&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Roberto&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Teodoro&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Manuel&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Diego&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Alejandro&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Margarita&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Luis&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Hernán&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Jaime&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Ana&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Francisco&quot;</span>);</span><br><span class="line">        arbol_texto.insertar(<span class="string">&quot;Andrea&quot;</span>);</span><br><span class="line">        //Graficamos el árbol generando la imagen arbol_texto.jpg</span><br><span class="line">        arbol_texto.graficar(<span class="string">&quot;arbol_texto.jpg&quot;</span>);</span><br><span class="line">        //Imprimimos el contenido del árbol ordenado</span><br><span class="line">        arbol_texto.inorden();</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        //Creamos un árbol cuyos nodos contendrán solamente numeros</span><br><span class="line">        ArbolAVL arbol_numeros=new ArbolAVL();</span><br><span class="line">        //Llenamos con información el árbol</span><br><span class="line">        arbol_numeros.insertar(12);</span><br><span class="line">        arbol_numeros.insertar(5);</span><br><span class="line">        arbol_numeros.insertar(26);</span><br><span class="line">        arbol_numeros.insertar(33);</span><br><span class="line">        arbol_numeros.insertar(59);</span><br><span class="line">        arbol_numeros.insertar(27);</span><br><span class="line">        arbol_numeros.insertar(15);      </span><br><span class="line">        arbol_numeros.insertar(47);</span><br><span class="line">        arbol_numeros.insertar(74);</span><br><span class="line">        arbol_numeros.insertar(84);</span><br><span class="line">        arbol_numeros.insertar(88);</span><br><span class="line">        arbol_numeros.insertar(90);</span><br><span class="line">        arbol_numeros.insertar(124);</span><br><span class="line">        arbol_numeros.insertar(612);</span><br><span class="line">        //Graficamos el árbol generando la imagen arbol_numeros.jpg</span><br><span class="line">        arbol_numeros.graficar(<span class="string">&quot;arbol_numeros.jpg&quot;</span>);</span><br><span class="line">        //Imprimimos el contenido del árbol ordenado</span><br><span class="line">        arbol_numeros.inorden();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Al ser ejecutada la aplicación, se generan dos imagenes, una para cada árbol la primera arbol_texto.jpg corresponde al árbol que solo almacena texto en sus nodos.</p>


<p>La segunda arbol_numeros.jpg corresponde al árbol que solo almacena números.</p>


<p>En la consola se verán los elementos de ambos árboles impresos en orden, esto se logra haciendo un recorrido enorden de los arboles AVL.</p>
<h3 id="Arbol-AVL"><a href="#Arbol-AVL" class="headerlink" title="Árbol AVL"></a><strong>Árbol AVL</strong></h3><p>El árbol AVL es un árbol binario de búsqueda equilibrado. Recibió el nombre del árbol AVL en honor de Adelson, Velskii y Landis, que fueron los primeros científicos en estudiar esta estructura de datos. “Un árbol AVL es un árbol binario de búsqueda en el que las alturas de los subárboles izquierdo y derecho de cualquier nodo difieren como máximo en 1.”</p>
<p><em>Fuente: Algoritmos y estructuras de datos, una perspectiva en C. Luis Joyanes Aguilar, Ignacio Zahonero Martínez.</em></p>
<p>En este árbol únicamente se desarrolla el método para insertar nodos, porque el objetivo de la aplicación es únicamente graficar el árbol, adicionalmente, podrían desarrollarse métodos para eliminar nodos, buscar nodos, vaciar el árbol, calcular la profundidad del árbol, etc. El único recorrido que se hace del árbol es el enorden, que muestra los nodos del árbol ordenados, pero existen otros recorridos que también podrían implementarse como el recorrido preorden, postorden o el recorrido por anchura.</p>
<h3 id="Interfaz-Comparable-El-secreto-tras-la-flexibilidad-de-este-arbol"><a href="#Interfaz-Comparable-El-secreto-tras-la-flexibilidad-de-este-arbol" class="headerlink" title="Interfaz Comparable: El secreto tras la flexibilidad de este árbol"></a><strong>Interfaz Comparable: El secreto tras la flexibilidad de este árbol</strong></h3><p>La razón por la cual este árbol puede utilizarse para almacenar cadenas o bien para almacenar números es la interfaz Comparable. Lo que almacena el nodo es la instancia de una clase que implementa la interfaz Comparable, por supuesto que todos los nodos tienen que poder compararse satisfactoriamente, por ejemplo no se podrían almacenar números enteros y también cadenas de caracteres en un mismo árbol, ya que no podrían comparase satisfactoriamente porque se daría un problema de tipos. Pero si todos los nodos almacenan números, el árbol funciona sin problemas, al igual cuando todos los nodos almacenan cadenas. Si deseáramos almacenar otro tipo de información podríamos programar una clase que contenga los atributos que deseamos y que implemente la interfaz Comparable, entonces sin modificar el árbol podríamos almacenar esta información.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas"></a><strong>Fuentes consultadas</strong></h3><p>Algoritmos y estructuras de datos, una perspectiva en C. Luis Joyanes Aguilar, Ignacio Zahonero Martínez.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:36.000Z" title="4/26/2019, 3:21:36 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/07-Graficar-expresiones-aritmeticas-con-Graphviz-Java-Jlex-y-Cup/">Graficar expresiones aritméticas con Graphviz, Java, Jlex y Cup</a></p><div class="content"><p>En este tutorial se desarrolla un ejemplo sencillo de un intérprete que recibe como entrada un archivo de texto que contiene varias expresiones aritméticas que son evaluadas y posteriormente graficadas por Graphviz, para ello se hace análisis léxico y sintáctico de dicha entrada, los analizadores se generan con Jlex y Cup. Es importante mencionar que para que el ejemplo funcione correctamente debe estar instalado Graphviz. Para desarrollar el proyecto se utilizó Ubuntu 14.04 y Netbeans 8.0. El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/GraficandoAritmeticas">Graficar expresiones aritméticas con Graphviz, Java, Jlex y Cup</a></p>
<p>Todo el código dentro del proyecto está documentado con comentarios que contienen explicaciones sobre su funcionamiento.</p>
<p>Si desean, una pequeña introducción al uso de Jlex y Cup pueden visitar alguno de mis posts:</p>
<ul>
<li><a href="/2019/04/25/01-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Linux/" title="Mi primer proyecto utilizando Jlex y Cup (Linux)">Mi primer proyecto utilizando Jlex y Cup (Linux)</a></li>
<li><a href="/2019/04/26/02-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Windows/" title="Mi primer proyecto utilizando Jlex y Cup (Windows)">Mi primer proyecto utilizando Jlex y Cup (Windows)</a></li>
</ul>
<h3 id="Instalacion-de-Graphviz"><a href="#Instalacion-de-Graphviz" class="headerlink" title="Instalación de Graphviz"></a><strong>Instalación de Graphviz</strong></h3><p>Lo primero que haremos será instalar Graphviz, para ello abrimos una terminal, en Ubuntu puede hacerse con la combinación de teclas Ctrl+Alt+t o en Aplicaciones → Accesorios → Terminal, una vez abierta la terminal ingresamos el comando “sudo apt-get install graphviz”, autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado Graphviz.</p>


<h3 id="Funcionamiento-del-proyecto"><a href="#Funcionamiento-del-proyecto" class="headerlink" title="Funcionamiento del proyecto"></a><strong>Funcionamiento del proyecto</strong></h3><p>La aplicación recibe como entrada un archivo que se encuentra en la carpeta del proyecto, dicho archivo se llama “entrada.txt” y contiene lo siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1+1];</span><br><span class="line">Evaluar[1+1*2];</span><br><span class="line">Evaluar[1.5+1.25*6.4/3.3-5.2+7.1];</span><br><span class="line">Evaluar[1.1+1.2*6.3/3.4-5+1*-2.12345];</span><br><span class="line">Evaluar[(2+2)*3+(1-1)];</span><br></pre></td></tr></table></figure>

<p>Al ejecutar la aplicación, esta le hace análisis léxico y sintáctico al archivo de entrada, evalúa las expresiones aritméticas e indica el resultado de la expresión y el nombre del archivo en el que se generó la imagen.</p>


<p>Veremos que se generan una serie de archivos .dot y una serie de archivos .jpg, los archivos dot, contienen el código con el que Graphviz genera la imagen jpg correspondiente.</p>


<p>A continuación se muestra el detalle de las imágenes que se generaron para cada línea del archivo de entrada.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1+1];</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1+1*2];</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1.5+1.25*6.4/3.3-5.2+7.1];</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1.1+1.2*6.3/3.4-5+1*-2.12345];</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[(2+2)*3+(1-1)];</span><br></pre></td></tr></table></figure>



<h3 id="La-magia-detras-de-todo-esto-Arbol-de-sintaxis-abstracta-AST"><a href="#La-magia-detras-de-todo-esto-Arbol-de-sintaxis-abstracta-AST" class="headerlink" title="La magia detrás de todo esto: Árbol de sintaxis abstracta (AST)"></a><strong>La magia detrás de todo esto: Árbol de sintaxis abstracta (AST)</strong></h3><p>Un árbol de sintaxis abstracta (AST) es una representación simplificada de la estructura sintáctica del código fuente. A nivel de programación un AST es una estructura de datos que se genera durante el proceso de análisis sintáctico.</p>
<p>En este ejemplo el AST es la pieza más importante porque con él pueden ejecutarse las principales funciones que son: evaluar la expresión y graficar la expresión.</p>
<p>En este ejemplo el AST se construye al hacer análisis sintáctico al archivo de entrada, esta estructura es un árbol binario, ya que cada nodo puede tener como máximo dos hijos y modela bien el funcionamiento de las expresiones aritméticas porque todas sus operaciones tienen dos operandos y el caso del operador “-” de las expresiones negativas que tiene un solo operando.</p>
<p>Hacemos análisis sintáctico una sola vez para cargar el árbol, posteriormente podemos recorrer ese árbol las veces que deseemos, podemos manipularlo y hacer muchas cosas sin necesidad de hacer nuevamente análisis sintáctico al archivo de entrada.</p>
<p>En este caso, el árbol se carga y posteriormente se recorre para evaluar la expresión aritmética y mostrar en consola el resultado. Se recorre nuevamente el árbol para generar el código de Graphviz y guardarlo en un archivo .dot, con el archivo .dot podemos pedirle a Graphviz que cree el diagrama de la expresión aritmética.</p>
<p>Todos los métodos que realizan estas acciones luego de cargar el árbol se encuentran en la clase “Nodo”, del paquete “arbol”. El método getValor, devuelve el resultado de la expresión aritmética evaluada. El método graficar, genera el diagrama de la expresión aritmética y devuelve el nombre del archivo generado.</p>
<p>Si les gusto este tutorial, puede que también estén interesados en este otro: </p>
<ul>
<li><a href="/2019/04/26/05-Interprete-sencillo-utilizando-Java-Jlex-y-Cup/" title="Intérprete sencillo utilizando Java, Jlex y Cup">Intérprete sencillo utilizando Java, Jlex y Cup</a></li>
</ul>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:31.000Z" title="4/26/2019, 3:21:31 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/05-Interprete-sencillo-utilizando-Java-Jlex-y-Cup/">Intérprete sencillo utilizando Java, Jlex y Cup</a></p><div class="content"><p>En los cursos de compiladores de la universidad, es bastante común que se solicite al estudiante desarrollar un intérprete, una herramienta que reciba como entrada cierto lenguaje de programación y lo ejecute, pero la mayoría de documentación al respecto solo muestra ejemplos de cosas sencillas, como una calculadora o un lenguaje que imprime cadenas en consola. Pero qué pasa si lo que deseamos es que se ejecuten sentencias de control como el IF o ciclos como la sentencia WHILE y que además estas sentencias soporten muchos niveles de anidamiento, que se declaren variables y se asigne valores a estas variables, que se tenga control de los ámbitos de las variables, en fin, que tenga las funciones básicas de un lenguaje de programación. No es común encontrar este tipo de ejemplos, en lo personal, puedo asegurar que nunca encontré un tutorial en el que se mostrara un ejemplo documentado y bien explicado sobre esto. Es por eso que les traigo este ejemplo, espero que les sea útil.</p>
<h3 id="Funcionamiento-de-la-aplicacion"><a href="#Funcionamiento-de-la-aplicacion" class="headerlink" title="Funcionamiento de la aplicación"></a><strong>Funcionamiento de la aplicación</strong></h3><p>En este tutorial se desarrolla un intérprete que recibe como entrada un archivo de texto que contiene varias sentencias en un lenguaje programación diseñado especialmente para esta aplicación, primero se hace análisis léxico y sintáctico de dicha entrada, durante el análisis sintáctico se carga en memoria un Árbol de Sintaxis Abstracta (AST) que se utiliza posteriormente para ejecutar las sentencias. Los analizadores se generan con Jlex y Cup. Se desarrollaron dos versiones del proyecto, una utilizando Windows 10 y otra utilizando Ubuntu 14.04. El proyecto completo del ejemplo puede descargarse de los siguientes enlaces:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencillo">Intérprete sencillo utilizando Java, Jlex y Cup (Linux)</a><br><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloWindows">Intérprete sencillo utilizando Java, Jlex y Cup (Windows)</a></p>
<p>Todo el código dentro del proyecto está documentado con comentarios que contienen explicaciones sobre su funcionamiento.</p>
<p>Si desean una pequeña introducción al uso de Jlex y Cup pueden visitar mi post: <a href="/2019/04/25/01-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Linux/" title="Mi primer proyecto utilizando Jlex y Cup (Linux)">Mi primer proyecto utilizando Jlex y Cup (Linux)</a> o bien <a href="/2019/04/26/02-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Windows/" title="Mi primer proyecto utilizando Jlex y Cup (Windows)">Mi primer proyecto utilizando Jlex y Cup (Windows)</a>.</p>
<h3 id="El-lenguaje-de-entrada"><a href="#El-lenguaje-de-entrada" class="headerlink" title="El lenguaje de entrada"></a><strong>El lenguaje de entrada</strong></h3><p>Dentro de la carpeta del proyecto, hay un archivo de entrada llamado “entrada.txt”, en él se muestran ejemplos de todas las funciones del lenguaje diseñado para esta aplicación, al leerlo se puede tener una idea clara de las funciones con las que el lenguaje cuenta, este archivo contiene lo siguiente:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro *</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io    *</span></span><br><span class="line"><span class="comment"> * Septiembre - 2015                      *</span></span><br><span class="line"><span class="comment"> ******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Se imprime el encabezado</span></span><br><span class="line">imprimir(<span class="string">&quot;Tablas de&quot;</span> &amp; <span class="string">&quot; multiplicar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Se declara la variable a, de tipo numero</span></span><br><span class="line">numero a;</span><br><span class="line"><span class="comment">//Se asigna a la variable a el valor 0</span></span><br><span class="line">a=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//Se declara la variable c, de tipo numero</span></span><br><span class="line">numero c;</span><br><span class="line"><span class="comment">//Se asigna a la variable c el valor 0</span></span><br><span class="line">c=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//Se imprime un separador</span></span><br><span class="line">imprimir(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Se imprimen las tablas del 1 al 5 y </span></span><br><span class="line"><span class="comment"> * para cada tabla, se imprimen los resultados</span></span><br><span class="line"><span class="comment"> * desde el uno hasta el 5, esto se hace con </span></span><br><span class="line"><span class="comment"> * dos ciclos while anidados. </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">mientras(a&lt;<span class="number">4</span>+c)&#123; </span><br><span class="line"> a=a+<span class="number">1</span>;</span><br><span class="line"> numero b;</span><br><span class="line"> b=<span class="number">0</span>;</span><br><span class="line"> mientras(b&lt;<span class="number">4</span>+c)&#123;</span><br><span class="line">  b=b+<span class="number">1</span>;</span><br><span class="line">  imprimir(a &amp; <span class="string">&quot; * &quot;</span> &amp; b &amp; <span class="string">&quot; = &quot;</span> &amp; a * b);</span><br><span class="line"> &#125;</span><br><span class="line"> imprimir(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Se asigna a la variable a el valor de 11</span></span><br><span class="line">a=<span class="number">11</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * La variable b ya había sido declarada pero </span></span><br><span class="line"><span class="comment"> * dentro del ámbito del primer ciclo while, </span></span><br><span class="line"><span class="comment"> * entonces no existe en este ámbito por lo que </span></span><br><span class="line"><span class="comment"> * debe declararse.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">numero b;</span><br><span class="line"><span class="comment">//Se asigna valor de 12 a b y valor de 13 a c</span></span><br><span class="line">b=<span class="number">12</span>;</span><br><span class="line">c=<span class="number">13</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Se evalua si el valor de la variable a es </span></span><br><span class="line"><span class="comment"> * mayor que 10, si el b es mayor que 11 y si</span></span><br><span class="line"><span class="comment"> * el de c es mayor que 12. </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">If(a&gt;<span class="number">10</span>)&#123;</span><br><span class="line"> imprimir(<span class="string">&quot;a es mayor que 10.&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(b&gt;<span class="number">11</span>)&#123;</span><br><span class="line">  imprimir(<span class="string">&quot;a es mayor que 10 y b es mayor que 11.&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(c&gt;<span class="number">12</span>)&#123;</span><br><span class="line">   imprimir(<span class="string">&quot;a es mayor que 10, b es mayor que 11 y c es mayor que 12.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> imprimir(<span class="string">&quot;a es menor o igual que 10.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Como se puede observar, el lenguaje acepta:</p>
<ul>
<li><p>Comentarios de muchas líneas (&#x2F;<em><Contenido del comentario></em>&#x2F;).</p>
</li>
<li><p>Comentarios de una línea (&#x2F;&#x2F;<Contenido del comentario>).</p>
</li>
<li><p>Concatenación de cadenas, mediante el operador “&amp;”.</p>
</li>
<li><p>Función “imprimir”: que recibe como parámetro una cadena e imprime en consola dicha cadena.</p>
</li>
<li><p>Declaración de variables: el único tipo de variables que el lenguaje soporta es “numero”, que es una variable de tipo numérico que suporta números enteros o con punto decimal (Dentro del rango del tipo Double de Java).</p>
</li>
<li><p>Asignación de variables, a cualquier variable se le puede asignar cualquier expresión que tenga como resultado un número.</p>
</li>
<li><p>Instrucción “mientras”: tiene el comportamiento clásico del ciclo while, ejecuta el ciclo mientras la expresión booleana que recibe sea verdadera. Esta instrucción soporta anidamiento.</p>
</li>
<li><p>Instrucción “if” e instrucción “if-else”: si la expresión booleana que recibe es verdadera entonces ejecuta las instrucciones contenidas en el “if”, si es falsa y la instrucción tiene un “else” entonces se ejecutan las instrucciones contenidas en el “else”. Esta instrucción soporta anidamiento.</p>
</li>
<li><p>Expresiones aritméticas: Estas expresiones soportan sumas, restas, divisiones, multiplicaciones, expresiones negativas y paréntesis para agrupar operaciones. Tiene la precedencia habitual de las expresiones aritméticas.</p>
</li>
<li><p>Expresiones booleanas: comparan dos expresiones que tengan como resultado un número y soportan únicamente los operadores mayor que y menor que (&lt;, &gt;).</p>
</li>
</ul>
<h3 id="El-resultado-de-la-ejecucion"><a href="#El-resultado-de-la-ejecucion" class="headerlink" title="El resultado de la ejecución"></a><strong>El resultado de la ejecución</strong></h3><p>Al ejecutar el archivo de entrada mostrado anteriormente se obtiene el siguiente resultado en consola:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">run:</span><br><span class="line">Tablas de multiplicar</span><br><span class="line">----------------</span><br><span class="line">1.0 * 1.0 = 1.0</span><br><span class="line">1.0 * 2.0 = 2.0</span><br><span class="line">1.0 * 3.0 = 3.0</span><br><span class="line">1.0 * 4.0 = 4.0</span><br><span class="line">1.0 * 5.0 = 5.0</span><br><span class="line">----------------</span><br><span class="line">2.0 * 1.0 = 2.0</span><br><span class="line">2.0 * 2.0 = 4.0</span><br><span class="line">2.0 * 3.0 = 6.0</span><br><span class="line">2.0 * 4.0 = 8.0</span><br><span class="line">2.0 * 5.0 = 10.0</span><br><span class="line">----------------</span><br><span class="line">3.0 * 1.0 = 3.0</span><br><span class="line">3.0 * 2.0 = 6.0</span><br><span class="line">3.0 * 3.0 = 9.0</span><br><span class="line">3.0 * 4.0 = 12.0</span><br><span class="line">3.0 * 5.0 = 15.0</span><br><span class="line">----------------</span><br><span class="line">4.0 * 1.0 = 4.0</span><br><span class="line">4.0 * 2.0 = 8.0</span><br><span class="line">4.0 * 3.0 = 12.0</span><br><span class="line">4.0 * 4.0 = 16.0</span><br><span class="line">4.0 * 5.0 = 20.0</span><br><span class="line">----------------</span><br><span class="line">5.0 * 1.0 = 5.0</span><br><span class="line">5.0 * 2.0 = 10.0</span><br><span class="line">5.0 * 3.0 = 15.0</span><br><span class="line">5.0 * 4.0 = 20.0</span><br><span class="line">5.0 * 5.0 = 25.0</span><br><span class="line">----------------</span><br><span class="line">a es mayor que 10.</span><br><span class="line">a es mayor que 10 y b es mayor que 11.</span><br><span class="line">a es mayor que 10, b es mayor que 11 y c es mayor que 12.</span><br><span class="line">BUILD SUCCESSFUL (total <span class="keyword">time</span>: 0 seconds)</span><br></pre></td></tr></table></figure>



<h3 id="Sobre-la-tabla-de-simbolos"><a href="#Sobre-la-tabla-de-simbolos" class="headerlink" title="Sobre la tabla de símbolos"></a><strong>Sobre la tabla de símbolos</strong></h3><p>La tabla de símbolos es una parte importante en el proceso de ejecución del código, es en esta estructura de datos en donde guardamos información de las variables como su tipo, identificador y valor. A esta estructura podemos pedirle el valor de una variable, o pedirle que le asigne cierto valor a una variable.</p>
<p>Es importante mencionar que en el proceso de ejecución la tabla de símbolos va cambiando de forma dinámica, esto con el objetivo de manejar los ámbitos, por ejemplo, la instrucción WHILE tiene su propio ámbito, lo que significa que su tabla de símbolos contiene información de las variables declaradas en ámbitos superiores y la información de las variables declaradas en el ámbito local de la instrucción, al terminar de ejecutar la instrucción, todas las variables declaradas en el ámbito local se eliminan de la tabla de símbolos que almacena la información de los ámbitos superiores, de tal manera que los ámbitos superiores no tendrán acceso a las variables declaradas dentro del WHILE.</p>
<h3 id="La-magia-detras-de-todo-esto-Arbol-de-sintaxis-abstracta-AST"><a href="#La-magia-detras-de-todo-esto-Arbol-de-sintaxis-abstracta-AST" class="headerlink" title="La magia detrás de todo esto: Árbol de sintaxis abstracta (AST)"></a><strong>La magia detrás de todo esto: Árbol de sintaxis abstracta (AST)</strong></h3><p>Un árbol de sintaxis abstracta (AST) es una representación simplificada de la estructura sintáctica del código fuente. A nivel de programación un AST es una estructura de datos que se genera durante el proceso de análisis sintáctico.</p>
<p>En este ejemplo el AST es la pieza más importante porque al recorrerlo pueden ejecutarse las acciones del código de entrada y ese es el principal objetivo de la aplicación.</p>
<p>En el código fuente de Cup se observa que la mayoría de las acciones se enfocan en cargar el AST, básicamente es lo único que hace el analizador, además de verificar que la sintaxis de la entrada sea correcta</p>
<p>La estructura en este caso es un tanto compleja ya que cada nodo puede tener muchos hijos, en el caso de las instrucciones IF-ELSE y WHILE, el número de hijos es incierto ya que estas instrucciones pueden contener muchas otras instrucciones dentro, lo cierto es que el árbol se acopla muy bien al lenguaje de programación porque en el árbol se tiene bien claro qué instrucciones están contenidas dentro de otras instrucciones, porque cada nodo esta directamente ligado a sus hijos, entonces la ejecución de instrucciones anidadas no representa mayor problema.</p>
<p>Hacemos análisis sintáctico una sola vez para cargar el árbol, posteriormente recorremos ese árbol para ejecutar el código.</p>
<p>El árbol es una representación exacta de lo que el código de entrada contiene. Las únicos tres paquetes del proyecto son:</p>
<ul>
<li><p>analizadores: que contiene los archivos de Cup y JLex y los analizadores que con estas herramientas se generaron.</p>
</li>
<li><p>arbol: que contiene todas las clases que forman parte del AST, que se utiliza como estructura primaria en la aplicación.</p>
</li>
<li><p>interpretesencillo: que contiene la clase principal de la aplicación.</p>
</li>
</ul>


<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:29.000Z" title="4/26/2019, 3:21:29 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/04-Analizador-sintactico-en-Visual-Basic/">Analizador sintáctico en Visual Basic</a></p><div class="content"><p>En esta publicación se muestra un ejemplo sencillo de la implementación de un analizador sintáctico a partir de una gramática independiente del contexto. Este proyecto se desarrolló utilizando Visual Studio 2013. El proyecto completo puede descargarse del siguiente enlace:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/AnalizadorSintacticoVB">Analizador sintáctico en Visual Basic</a>.</p>
<p>Todo el código dentro del proyecto está documentado con comentarios que contienen explicaciones sobre su funcionamiento.</p>
<h3 id="Funcionamiento-del-proyecto"><a href="#Funcionamiento-del-proyecto" class="headerlink" title="Funcionamiento del proyecto"></a><strong>Funcionamiento del proyecto</strong></h3><p>Este ejemplo ilustra la implementación de un analizador sintáctico a partir de una gramática independiente del contexto. No se utiliza ningún generador de analizadores sintácticos que genere el analizador, ni se realiza el proceso de análisis sintáctico con ninguna librería. Los errores identificados en el proceso de análisis sintáctico se muestran en consola, si en el entorno de Visual Studio no aparece la consola, esta puede abrirse desde el menú ver, en la opción resultados o con Ctrl+Alt+O. Inicialmente se muestra una expresión aritmética de ejemplo que puede utilizarse como entrada, esta entrada contiene una expresión incompleta que léxicamente es correcta pero sintácticamente no, su estructura es incorrecta porque le hace falta un numero y un paréntesis derecho al final.</p>


<p>Al presionar el botón Analizar se ejecuta el análisis de la entrada y en consola se despliegan los mensajes de error.</p>


<p>El fundamento teórico que sirvió de soporte para el desarrollo de este ejemplo es el descrito en la sección 4.4.1 titulada Análisis sintáctico de descenso recursivo del libro: Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
<h3 id="Gramatica-independiente-del-contexto-utilizada"><a href="#Gramatica-independiente-del-contexto-utilizada" class="headerlink" title="Gramática independiente del contexto utilizada"></a><strong>Gramática independiente del contexto utilizada</strong></h3><p>La gramática utilizada reconoce expresiones aritméticas respetando la precedencia de operadores, no es ambigua y no tiene recursividad por la izquierda. La gramática es la siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">E  → T E<span class="string">&#x27;</span></span><br><span class="line"><span class="string">E&#x27;</span> → + T E<span class="string">&#x27;</span></span><br><span class="line"><span class="string">E&#x27;</span> → - T E<span class="string">&#x27;</span></span><br><span class="line"><span class="string">E&#x27;</span> → ε</span><br><span class="line">T  → F T<span class="string">&#x27;</span></span><br><span class="line"><span class="string">T&#x27;</span> → * F T<span class="string">&#x27;</span></span><br><span class="line"><span class="string">T&#x27;</span> → / F T<span class="string">&#x27;</span></span><br><span class="line"><span class="string">T&#x27;</span> → ε</span><br><span class="line">F  → ( E )</span><br><span class="line">F  → numero</span><br></pre></td></tr></table></figure>

<h3 id="Metodo-utilizado-para-el-desarrollo-del-analizador"><a href="#Metodo-utilizado-para-el-desarrollo-del-analizador" class="headerlink" title="Método utilizado para el desarrollo del analizador"></a><strong>Método utilizado para el desarrollo del analizador</strong></h3><p>Se desarrolló un analizador sintáctico predictivo recursivo. Los analizadores predictivos o descendentes consisten en la construcción de un árbol de análisis sintáctico para la cadena de entrada, partiendo desde la raíz y creando los nodos del árbol de análisis sintáctico en pre-orden. En este caso no se construye un árbol en memoria, ya que no es necesario guardar lo que se analiza, pero las llamadas recursivas a los diferentes métodos del analizador crean un árbol en pila mientras se ejecutan. La construcción de este analizador sintáctico predictivo recursivo sigue los siguientes principios:</p>
<ul>
<li><p>Consiste en un conjunto de procedimientos, uno para cada no terminal.</p>
</li>
<li><p>La ejecución empieza con el procedimiento para el símbolo inicial.</p>
</li>
<li><p>Se detiene y anuncia que tuvo éxito si el cuerpo de su procedimiento explora la cadena completa de entrada.</p>
</li>
<li><p>Para cada no terminal del lado derecho de las producciones se hace una llamada al método que le corresponde.</p>
</li>
<li><p>Para cada terminal del lado derecho de las producciones se hace una llamada al método match enviando como parámetro el terminal.</p>
</li>
<li><p>El método match valida si el terminal que se recibe es el que se esperaba, de no ser así despliega un mensaje de error.</p>
</li>
<li><p>La gramática a utilizar reconoce expresiones aritméticas y cumple con lo siguiente:</p>
</li>
<li><p>No es ambigua</p>
</li>
<li><p>No tiene recursividad por la izquierda</p>
</li>
</ul>
<h3 id="Sobre-la-recuperacion-de-errores-sintacticos"><a href="#Sobre-la-recuperacion-de-errores-sintacticos" class="headerlink" title="Sobre la recuperación de errores sintácticos"></a><strong>Sobre la recuperación de errores sintácticos</strong></h3><p>Este ejemplo es bastante básico, por lo que no tiene implementado un sistema de recuperación de errores sintácticos, para hacerlo existen muchas estrategias, como las siguientes:</p>
<ul>
<li><p>Recuperación en modo pánico</p>
</li>
<li><p>Recuperación a nivel de frase</p>
</li>
<li><p>Producción de errores</p>
</li>
<li><p>Corrección global</p>
</li>
</ul>
<p>Se recomienda la recuperación en modo pánico por ser la más sencilla de implementar</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><ul>
<li>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición. Sección 4.4.1.</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:28.000Z" title="4/26/2019, 3:21:28 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/03-Analizador-lexico-en-Visual-Basic/">Analizador léxico en Visual Basic</a></p><div class="content"><p>En esta publicación se muestra un ejemplo sencillo de la implementación de un analizador léxico a partir de un autómata finito determinista. Este proyecto se desarrolló utilizando Visual Studio 2013. El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/AnalizadorLexicoVB">Analizador léxico en Visual Basic</a>.</p>
<p>Todo el código dentro del proyecto está documentado con comentarios que contienen explicaciones sobre su funcionamiento.</p>
<h3 id="Funcionamiento-del-proyecto"><a href="#Funcionamiento-del-proyecto" class="headerlink" title="Funcionamiento del proyecto"></a><strong>Funcionamiento del proyecto</strong></h3><p>Este ejemplo ilustra la implementación de un analizador léxico a partir de un Autómata Finito Determinista (AFD). No se utiliza ningún generador de analizadores léxicos que genere el analizador, ni se realiza el proceso de análisis léxico con ninguna librería. Los errores identificados en el proceso de análisis léxico se muestran en consola, si en el entorno de Visual Studio no aparece la consola, esta pueden abrirse desde el menú ver, en la opción resultados o con Ctrl+Alt+O.</p>
<p>Inicialmente se muestra una expresión aritmética de ejemplo que puede utilizarse como entrada, del lado izquierdo.</p>


<p>Al presionar el botón Realizar Análisis Léxico se ejecuta el análisis de la entrada y del lado derecho se despliega la lista de tokens identificada, en la que se indica el tipo de token y el valor específico que este tiene.</p>


<p>Si existiera algún error léxico en la entrada, por ejemplo, si pusiéramos al final de la expresión una arroba en lugar del uno, entonces se desplegaría en consola un mensaje de error y se mostraría en la lista de tokens todos aquellos tokens válidos.</p>


<h3 id="Automata-Finito-Determinista-utilizado"><a href="#Automata-Finito-Determinista-utilizado" class="headerlink" title="Autómata Finito Determinista utilizado"></a><strong>Autómata Finito Determinista utilizado</strong></h3><p>En este ejemplo se reconocen los componentes léxicos propios de una expresión aritmética, por ello el ejemplo se realizó a partir del siguiente autómata finito determinista:</p>


<p>El estado inicial del autómata es E_0. En el autómata podemos observar que existen tres estados de aceptación, el primero (EA_1) reconoce todos los componentes léxicos de un carácter y a nivel programación se clasifican los tokens según el carácter que se haya reconocido, el segundo estado de aceptación (EA_2) reconoce los números enteros y el tercero (EA_3) reconoce los números reales, es decir, los números con punto decimal. Se pueden desplegar dos tipos de mensajes de error, ya que se cuentan con dos estados de error, el primero es cuando se reconoce un carácter desconocido estando en el estado 1, el segundo se da cuando estando en el estado 2, correspondiente a los números reales, se esperaban más dígitos después del punto decimal, pero se obtiene un carácter que no es un dígito.</p>
<p>A un lado de algunos estados se coloca un asterisco (*), que indica que debe retrocederse la entrada en una posición, esto se hace porque los tokens se dan como aceptados con el primer carácter del siguiente token, entonces para que no se pierda ese carácter del siguiente token en el análisis debe retrocederse una posición en la entrada, esta notación es la misma que se utiliza en el libro de Aho, Lam, Sethi y Ullman.</p>
<h3 id="El-secreto-tras-la-implementacion-del-automata"><a href="#El-secreto-tras-la-implementacion-del-automata" class="headerlink" title="El secreto tras la implementación del autómata"></a><strong>El secreto tras la implementación del autómata</strong></h3><p>El secreto es encontrar la forma de ejecutar en código las acciones que un reconocedor haría basado en el autómata finito determinista, es lógico que la función core del analizador léxico debe estar dentro de un ciclo ya que deben recorrerse los caracteres de izquierda a derecha y agruparse en componentes léxicos. Este ciclo se encuentra en la función escanear de la clase <em>AnalizadorLexico</em>, dentro de dicho ciclo debe haber un <em>select case</em> en el que cada caso representa a uno de los estados del conjunto de estados para cada caso (o estado) hay un <em>if elseif elseif … else</em> que representan el conjunto de transiciones que salen de dicho estado.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><ul>
<li><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición. Págs. 111, 130 y 131</p>
</li>
<li><p>Teoría de la computación. Lenguajes formales, autómatas y complejidad. J. Glenn Brookshear. Pág. 24</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-26T21:21:25.000Z" title="4/26/2019, 3:21:25 PM">2019-04-26</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/26/02-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Windows/">Mi primer proyecto utilizando Jlex y Cup (Windows)</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presenta como salida el resultado de dichas expresiones.</p>
<p>Las tecnologías a utilizar son:</p>
<ul>
<li><p><strong>Jlex</strong>: Generador de analizadores léxicos</p>
</li>
<li><p><strong>Cup</strong>: Generador de analizadores sintácticos</p>
</li>
<li><p><strong>Windows 10</strong>: Sistema operativo</p>
</li>
<li><p><strong>Netbeans 8.2</strong>: IDE (entorno de desarrollo integrado)</p>
</li>
</ul>
<p>El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoCupJlexWindows">Mi primer proyecto utilizando Jlex y Cup (Windows)</a></p>
<h3 id="JLex"><a href="#JLex" class="headerlink" title="JLex"></a><strong>JLex</strong></h3><p>JLex es un generador de analizadores léxicos, escrito en Java, para Java. JLex fue desarrollado por Elliot Berk en la Universidad de Princeton. Para más información visitar la <a target="_blank" rel="noopener" href="https://www.cs.princeton.edu/~appel/modern/java/JLex/">página oficial de JLex</a>.</p>
<p>La principal tarea de un analizador léxico es leer los caracteres de entrada del programa fuente, agruparlos en lexemas y producir como salida una secuencia de tokens.</p>
<ul>
<li><p>Un <em>token</em> es un par que consiste en un nombre de token y un valor de atributo opcional.</p>
</li>
<li><p>Un <em>lexema</em> es una secuencia de caracteres en el programa fuente, que coinciden con el patrón para un token y que el analizador léxico identifica como una instancia de este tóken.</p>
</li>
<li><p>Un <em>patrón</em> es una descripción de la forma que pueden tomar los lexemas de un token.</p>
</li>
</ul>
<p>En JLex se definen los patrones de los diferentes tokens que se desean reconocer, estos patrones pueden definirse a través de expresiones regulares. Además JLex cuenta con múltiples opciones, una muy imporante es su capacidad para integrarse con generadores de analizadores sintácticos como Cup.</p>
<h3 id="Cup"><a href="#Cup" class="headerlink" title="Cup"></a><strong>Cup</strong></h3><p><a target="_blank" rel="noopener" href="http://www2.cs.tum.edu/projects/cup/">Cup</a> es un generador de analizadores sintácticos de tipo LALR para Java.</p>
<p>El analizador sintáctico obtiene una cadena de tokens del analizador léxico y verifica que dicha cadena pueda generase con la gramática para el lenguaje fuente. Una gramática proporciona una especificación precisa y fácil de entender de un lenguaje de programación.</p>
<h3 id="Pre-requisitos"><a href="#Pre-requisitos" class="headerlink" title="Pre-requisitos"></a><strong>Pre-requisitos</strong></h3><p>Para este ejemplo hace falta que tengamos instalado:</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Java Development Kit (JDK)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://netbeans.org/downloads/">Netbeans</a></p>
</li>
</ul>
<p>Debemos asegurarnos que la carpeta bin del JDK haya sido agregada a nuestra variable de entorno Path, para ello vamos a la configuración de dicha variable de entorno (Clic derecho en This PC → Properties → Advanced system settings → Environment Variables → Variable Path → Edit) y si no existe agregamos la ruta a la carpeta bin del JDK, que en mi caso es: C:\Program Files\Java\jdk1.8.0_152\bin</p>


<h3 id="Descargar-JLex"><a href="#Descargar-JLex" class="headerlink" title="Descargar JLex"></a><strong>Descargar JLex</strong></h3><p> Lo primero que haremos será descargar JLex, para ello vamos a la <a target="_blank" rel="noopener" href="https://www.cs.princeton.edu/~appel/modern/java/JLex/">página oficial</a> y descargamos la versión actual del software:</p>


<p>Vamos a obtener el archivo Main.java:</p>


<h3 id="Descargar-Cup"><a href="#Descargar-Cup" class="headerlink" title="Descargar Cup"></a><strong>Descargar Cup</strong></h3><p>Para descargar Cup, vamos a la <a target="_blank" rel="noopener" href="http://www2.cs.tum.edu/projects/cup/">página oficial</a> y descargamos la última versión del software:</p>


<p>Descomprimimos el archivo descargado, para ello se recomienda la herramienta <a target="_blank" rel="noopener" href="http://www.peazip.org/">PeaZip</a> y vamos a obtener los siguientes archivos:</p>


<h3 id="Crear-nuestro-proyecto"><a href="#Crear-nuestro-proyecto" class="headerlink" title="Crear nuestro proyecto"></a><strong>Crear nuestro proyecto</strong></h3><p>Abrimos Netbeans y creamos un nuevo proyecto de Java (File → New Project).</p>




<p>Creamos un paquete llamado analizadores, este almacenará todo el código fuente relacionado con el analizador léxico y sintáctico (Clic derecho en Source Packages → New → Java Package).</p>


<p>Creamos tres archivos en el paquete analizadores, el primero “Lexico”, que almacenará el código fuente con el cual JLex generará el analizador léxico que queremos, el segundo “Sintactico”, que almacenará el código fuente con el cual Cup generará el analizador sintáctico que queremos y el tercero “compilar.sh”, que guardará los comandos que deben ejecutarse para solicitarle a JLex y a Cup que generen los analizadores. Para crear cada uno de los archivos hacemos clic derecho en el paquete analizadores → New → Other → en la ventana que despliegue, seleccionar Categories: Other y File Types: Empty File, seleccionamos siguiente, indicamos el nombre para el archivo y finalizamos. De tal modo que al final tendremos los tres archivos archivos.</p>


<h3 id="Importar-la-libreria-de-Cup-en-nuestro-proyecto-para-poder-ejecutar-el-analizador-sintactico-que-generemos"><a href="#Importar-la-libreria-de-Cup-en-nuestro-proyecto-para-poder-ejecutar-el-analizador-sintactico-que-generemos" class="headerlink" title="Importar la librería de Cup en nuestro proyecto para poder ejecutar el analizador sintáctico que generemos"></a><strong>Importar la librería de Cup en nuestro proyecto para poder ejecutar el analizador sintáctico que generemos</strong></h3><p>Para ello creamos una carpeta lib dentro de la carpeta de nuestro proyecto.</p>


<p>Dentro de la carpeta lib pegamos el archivo “java-cup-11b-runtime.jar” que descargamos anteriormente.</p>


<p>Para importar el archivo jar, vamos a Netbeans y damos clic derecho en la pestaña Libraries de nuestro proyecto → Add JAR&#x2F;Folder… luego buscamos el archivo jar en la carpeta lib que acabamos de copiar en la carpeta lib y lo seleccionamos.</p>


<h3 id="Codigo-fuente-para-el-analizador-lexico"><a href="#Codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Código fuente para el analizador léxico"></a><strong>Código fuente para el analizador léxico</strong></h3><p>En el archivo “Lexico” incluiremos todo el código que le indicará a Jlex lo que debe hacer. El código se muestra a continuación:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io</span></span><br><span class="line"><span class="comment"> * Julio - 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> analizadores;</span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.Symbol; </span><br><span class="line"></span><br><span class="line">%% </span><br><span class="line">%<span class="keyword">class</span> <span class="title class_">Lexico</span></span><br><span class="line">%<span class="keyword">public</span> </span><br><span class="line">%line </span><br><span class="line">%<span class="type">char</span> </span><br><span class="line">%cup </span><br><span class="line">%unicode</span><br><span class="line">%ignorecase</span><br><span class="line"></span><br><span class="line">%init&#123; </span><br><span class="line">    yyline = <span class="number">1</span>; </span><br><span class="line">    yychar = <span class="number">1</span>; </span><br><span class="line">%init&#125; </span><br><span class="line"></span><br><span class="line">BLANCOS=[ \r\t]+</span><br><span class="line">D=[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">DD=[<span class="number">0</span>-<span class="number">9</span>]+(<span class="string">&quot;.&quot;</span>[  |<span class="number">0</span>-<span class="number">9</span>]+)?</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Evaluar&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.REVALUAR,yyline,yychar,</span><br><span class="line">                             yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;;&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PTCOMA,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;(&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;)&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARDER,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;[&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;]&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORDER,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;+&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MAS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;-&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MENOS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;*&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.POR,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;/&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DIVIDIDO,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">\n &#123;yychar=<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#123;BLANCOS&#125; &#123;&#125; </span><br><span class="line">&#123;D&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.ENTERO,yyline,yychar, yytext());&#125; </span><br><span class="line">&#123;DD&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DECIMAL,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Este es un error lexico: &quot;</span>+yytext()+</span><br><span class="line">    <span class="string">&quot;, en la linea: &quot;</span>+yyline+<span class="string">&quot;, en la columna: &quot;</span>+yychar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-lexico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Explicación del código fuente para el analizador léxico"></a><strong>Explicación del código fuente para el analizador léxico</strong></h3><p>En las primeras líneas indicamos a Jlex que la clase estará en el paquete analizadores y que es necesario que se importe la clase Symbol.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> analizadores;</span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.Symbol;</span><br></pre></td></tr></table></figure>

<p>Posteriormente indicamos a Jlex que:</p>
<ul>
<li><p>La clase del analizador se llamará “Lexico”</p>
</li>
<li><p>La clase será pública</p>
</li>
<li><p>Debe llevar el conteo de las líneas</p>
</li>
<li><p>Debe llevar el conteo de los caracteres reconocidos</p>
</li>
<li><p>Debe integrarse con cup</p>
</li>
<li><p>El set de caracteres que debe utilizar es el unicode</p>
</li>
<li><p>El analizador no será case sensitive, es decir, no le importa si las letras son mayúsculas o minúsculas</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%% </span><br><span class="line">%<span class="keyword">class</span> <span class="title class_">Lexico</span></span><br><span class="line">%<span class="keyword">public</span> </span><br><span class="line">%line </span><br><span class="line">%<span class="type">char</span> </span><br><span class="line">%cup </span><br><span class="line">%unicode</span><br><span class="line">%ignorecase</span><br></pre></td></tr></table></figure>

<p>Luego viene el bloque init, dentro del init, se ejecutan las acciones de inicialización, es decir, lo que va dentro del constructor del analizador léxico.En este caso indicamos dentro del init que:</p>
<ul>
<li><p>La variable yyline, que lleva la cuenta del número de linea por el que va el analizador valdrá inicialmente 1.</p>
</li>
<li><p>La variable yychar, que lleva la cuenta del número de carácter por el que va el analizador valdrá inicialmente 1.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%init&#123; </span><br><span class="line">    yyline = <span class="number">1</span>; </span><br><span class="line">    yychar = <span class="number">1</span>; </span><br><span class="line">%init&#125;</span><br></pre></td></tr></table></figure>

<p>Luego se escriben algunas expresiones regulares que son almacenadas en macros, que básicamente son variables que almacenan los patrones, en este caso se definen las macros: BLANCOS, D y DD. Los patrones para cada una son los siguientes:</p>
<ul>
<li><p>BLANCOS: Expresión regular que reconoce uno o muchos espacios en blanco, retornos de carro o tabuladores.</p>
</li>
<li><p>D: Expresión regular que reconoce números enteros.</p>
</li>
<li><p>DD: Expresión regular que reconoce números con punto decimal.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BLANCOS=[ \r\t]+</span><br><span class="line">D=[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">DD=[<span class="number">0</span>-<span class="number">9</span>]+(<span class="string">&quot;.&quot;</span>[  |<span class="number">0</span>-<span class="number">9</span>]+)?</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<p>Por último se definen todas las reglas léxicas, en las que indicamos el patrón que reconocerá y dentro de llaves lo que debe hacer cuando lo reconozca. En la mayoría de los casos se retorna un objeto de tipo Symbol, que vendría siendo un token, este se instancia con el tipo, la fila en la que se encontró, la columna en la que se encontró y el lexema en específico que se reconoció, este se obtiene mediante yytext(). Dentro de las llaves podríamos incluir el código java que quisiéramos. Vemos que al reconocer el patrón BLANCOS no se hace nada porque esperamos que ignore los espacios en blanco. También vemos que al encontrar un salto de linea reinicia la variable yychar, es decir, reinicia el conteo de caracteres para que se lleve la cuenta del número de columna en cada fila.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Evaluar&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.REVALUAR,yyline,yychar,</span><br><span class="line">                             yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;;&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PTCOMA,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;(&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;)&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARDER,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;[&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;]&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORDER,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;+&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MAS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;-&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MENOS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;*&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.POR,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;/&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DIVIDIDO,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">\n &#123;yychar=<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#123;BLANCOS&#125; &#123;&#125; </span><br><span class="line">&#123;D&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.ENTERO,yyline,yychar, yytext());&#125; </span><br><span class="line">&#123;DD&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DECIMAL,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Este es un error lexico: &quot;</span>+yytext()+</span><br><span class="line">    <span class="string">&quot;, en la linea: &quot;</span>+yyline+<span class="string">&quot;, en la columna: &quot;</span>+yychar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Codigo-fuente-para-el-analizador-sintactico"><a href="#Codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Código fuente para el analizador sintáctico"></a><strong>Código fuente para el analizador sintáctico</strong></h3><p>En el archivo “Sintáctico” incluiremos todo el código que le indicará a Cup lo que debe hacer. El código se muestra a continuación:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io</span></span><br><span class="line"><span class="comment"> * Julio - 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> analizadores; </span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.*;</span><br><span class="line"></span><br><span class="line">parser code </span><br><span class="line">&#123;:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintactico.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syntax_error</span><span class="params">(Symbol s)</span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error Sintáctico en la Línea &quot;</span> + (s.left) +</span><br><span class="line">        <span class="string">&quot; Columna &quot;</span>+s.right+ <span class="string">&quot;. No se esperaba este componente: &quot;</span> +s.value+<span class="string">&quot;.&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintáctico </span></span><br><span class="line"><span class="comment">     * en el que ya no es posible una recuperación de errores.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unrecovered_syntax_error</span><span class="params">(Symbol s)</span> <span class="keyword">throws</span> java.lang.Exception&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error síntactico irrecuperable en la Línea &quot;</span> + </span><br><span class="line">        (s.left)+ <span class="string">&quot; Columna &quot;</span>+s.right+<span class="string">&quot;. Componente &quot;</span> + s.value + </span><br><span class="line">        <span class="string">&quot; no reconocido.&quot;</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">:&#125; </span><br><span class="line"></span><br><span class="line">terminal String PTCOMA,PARIZQ,PARDER,CORIZQ,CORDER;</span><br><span class="line">terminal String MAS,MENOS,POR,DIVIDIDO;</span><br><span class="line">terminal String ENTERO;</span><br><span class="line">terminal String DECIMAL;</span><br><span class="line">terminal String UMENOS;</span><br><span class="line">terminal String REVALUAR;</span><br><span class="line"></span><br><span class="line">non terminal ini;</span><br><span class="line">non terminal instrucciones;</span><br><span class="line">non terminal instruccion;</span><br><span class="line">non terminal Double expresion;</span><br><span class="line"></span><br><span class="line">precedence left MAS,MENOS;</span><br><span class="line">precedence left POR,DIVIDIDO;</span><br><span class="line">precedence right UMENOS; </span><br><span class="line"></span><br><span class="line">start with ini; </span><br><span class="line"></span><br><span class="line">ini::=instrucciones;</span><br><span class="line"></span><br><span class="line">instrucciones ::= </span><br><span class="line">   instruccion instrucciones</span><br><span class="line"> | instruccion</span><br><span class="line"> | error instrucciones</span><br><span class="line">; </span><br><span class="line"></span><br><span class="line">instruccion ::= </span><br><span class="line">   REVALUAR CORIZQ expresion:a CORDER PTCOMA&#123;:System.out.println(<span class="string">&quot;El valor de la expresión es: &quot;</span>+a);:&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expresion  ::= </span><br><span class="line">    MENOS expresion:a                      &#123;:RESULT=a*-<span class="number">1</span>;:&#125;%prec UMENOS     </span><br><span class="line"> |  expresion:a MAS        expresion:b     &#123;:RESULT=a+b;:&#125;</span><br><span class="line"> |  expresion:a MENOS      expresion:b     &#123;:RESULT=a-b;:&#125;</span><br><span class="line"> |  expresion:a POR        expresion:b     &#123;:RESULT=a*b;:&#125;</span><br><span class="line"> |  expresion:a DIVIDIDO   expresion:b     &#123;:RESULT=a/b;:&#125;</span><br><span class="line"> |  ENTERO:a                               &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  DECIMAL:a                              &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  PARIZQ expresion:a PARDER              &#123;:RESULT=a;:&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-sintactico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Explicación del código fuente para el analizador sintáctico"></a><strong>Explicación del código fuente para el analizador sintáctico</strong></h3><p>En las primeras líneas indicamos a Cup que la clase estará en el paquete analizadores y que es necesario que se importe todo el contenido de “java_cup.runtime”.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> analizadores; </span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.*;</span><br></pre></td></tr></table></figure>

<p>Luego viene la sección “parser code”, en la que se programan acciones propias del parser o analizador sintáctico que se va a generar, en este caso se programa lo que se debe hacer ante un error sintáctico y ante un error sintáctico irrecuperable.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">parser code </span><br><span class="line">&#123;:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintactico.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syntax_error</span><span class="params">(Symbol s)</span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error Sintáctico en la Línea &quot;</span> + (s.left) +</span><br><span class="line">        <span class="string">&quot; Columna &quot;</span>+s.right+ <span class="string">&quot;. No se esperaba este componente: &quot;</span> +s.value+<span class="string">&quot;.&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintáctico </span></span><br><span class="line"><span class="comment">     * en el que ya no es posible una recuperación de errores.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unrecovered_syntax_error</span><span class="params">(Symbol s)</span> <span class="keyword">throws</span> java.lang.Exception&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error síntactico irrecuperable en la Línea &quot;</span> + </span><br><span class="line">        (s.left)+ <span class="string">&quot; Columna &quot;</span>+s.right+<span class="string">&quot;. Componente &quot;</span> + s.value + </span><br><span class="line">        <span class="string">&quot; no reconocido.&quot;</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">:&#125;</span><br></pre></td></tr></table></figure>

<p>Luego se definen los terminales, a estos se les puede indicar un tipo, en este caso todos son de tipo *String, *si no se indicara un tipo, los terminales serían por defecto de tipo <em>Object</em>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">terminal String PTCOMA,PARIZQ,PARDER,CORIZQ,CORDER;</span><br><span class="line">terminal String MAS,MENOS,POR,DIVIDIDO;</span><br><span class="line">terminal String ENTERO;</span><br><span class="line">terminal String DECIMAL;</span><br><span class="line">terminal String UMENOS;</span><br><span class="line">terminal String REVALUAR;</span><br></pre></td></tr></table></figure>

<p>Existe un terminal por cada tipo de token que el analizador léxico devuelve. Todos estos tipos estarán definidos en la clase “sym”, que se genera automáticamente y de la que se hablará más adelante.</p>
<p>Luego viene la declaración de los no terminales, a los que también se les puede indicar un tipo específico, si no se les indica un tipo, estos son por defecto de tipo <em>Object</em>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">non terminal ini;</span><br><span class="line">non terminal instrucciones;</span><br><span class="line">non terminal instruccion;</span><br><span class="line">non terminal Double expresion;</span><br></pre></td></tr></table></figure>

<p>Posteriormente podemos indicar la precedencia de los operadores, ya que la gramática escrita es ambigua, es necesario definir una precedencia para que el analizador no entre en conflicto al analizar, en este caso la precedencia es la misma que la de los operadores aritméticos, la precedencia más baja la tienen la suma y la resta, luego están la multiplicación y la división que tienen una precedencia más alta y por último está el signo menos de las expresiones negativas que tendría la precedencia más alta.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">precedence left MAS,MENOS;</span><br><span class="line">precedence left POR,DIVIDIDO;</span><br><span class="line">precedence right UMENOS;</span><br></pre></td></tr></table></figure>

<p>Por último viene el conjunto de reglas de escritura de la gramática o producciones, al final de cada producción puede incluirse código java entre llaves y dos puntos “{:&lt;código java&gt;:}”. Podemos ver que en las producciones del no terminal “expresion”, se utiliza la variable RESULT, esta variable es propia de Cup y nos permite sintetizar cierto atributo para ese no terminal que se encuentra del lado izquierdo de la producción, recordemos que Cup trabaja con analizadores LALR, que son de tipo ascendente, lo que significa que nos permiten manipular atributos sintetizados. Básicamente eso es RESULT, un atributo sintetizado.</p>
<p>RESULT puede ser cualquier objeto, por ejemplo si quisiéramos que RESULT almacenara varios números enteros hacemos una clase Nodo que contenga muchas variables de tipo entero y declaramos los no terminales para que sean de tipo Nodo, entonces el RESULT que sintetizarán dichos no terminales serán de tipo Nodo.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">start with ini; </span><br><span class="line"></span><br><span class="line">ini::=instrucciones;</span><br><span class="line"></span><br><span class="line">instrucciones ::= </span><br><span class="line">   instruccion instrucciones</span><br><span class="line"> | instruccion</span><br><span class="line"> | error instrucciones</span><br><span class="line">; </span><br><span class="line"></span><br><span class="line">instruccion ::= </span><br><span class="line">   REVALUAR CORIZQ expresion:a CORDER PTCOMA&#123;:System.out.println(<span class="string">&quot;El valor de la expresión es: &quot;</span>+a);:&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expresion  ::= </span><br><span class="line">    MENOS expresion:a                      &#123;:RESULT=a*-<span class="number">1</span>;:&#125;%prec UMENOS     </span><br><span class="line"> |  expresion:a MAS        expresion:b     &#123;:RESULT=a+b;:&#125;</span><br><span class="line"> |  expresion:a MENOS      expresion:b     &#123;:RESULT=a-b;:&#125;</span><br><span class="line"> |  expresion:a POR        expresion:b     &#123;:RESULT=a*b;:&#125;</span><br><span class="line"> |  expresion:a DIVIDIDO   expresion:b     &#123;:RESULT=a/b;:&#125;</span><br><span class="line"> |  ENTERO:a                               &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  DECIMAL:a                              &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  PARIZQ expresion:a PARDER              &#123;:RESULT=a;:&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="Incluir-JLex-para-generar-el-analizador-lexico-de-nuestro-proyecto"><a href="#Incluir-JLex-para-generar-el-analizador-lexico-de-nuestro-proyecto" class="headerlink" title="Incluír JLex para generar el analizador léxico de nuestro proyecto"></a><strong>Incluír JLex para generar el analizador léxico de nuestro proyecto</strong></h3><p>Creamos un paquete llamado JLex dentro del paquete analizadores, este almacenará la herramienta JLex (Clic derecho en el paquete analizadores → New → Java Package).</p>


<p>En la carpeta del paquete JLex copiamos el archivo Main.java que descargamos de la página oficial de JLex.</p>




<h3 id="Incluir-Cup-para-generar-el-analizador-sintactico-de-nuestro-proyecto"><a href="#Incluir-Cup-para-generar-el-analizador-sintactico-de-nuestro-proyecto" class="headerlink" title="Incluír Cup para generar el analizador sintáctico de nuestro proyecto"></a><strong>Incluír Cup para generar el analizador sintáctico de nuestro proyecto</strong></h3><p>Creamos un paquete llamado Cup dentro del paquete analizadores, este almacenará la herramienta Cup (Clic derecho en el paquete analizadores → New → Java Package).</p>


<p>En la carpeta del paquete Cup copiamos el archivo “java-cup-11b-runtime.jar” que descargamos de la página oficial de Cup.</p>




<h3 id="El-archivo-de-compilacion"><a href="#El-archivo-de-compilacion" class="headerlink" title="El archivo de compilación"></a><strong>El archivo de compilación</strong></h3><p>En el archivo “compilar.bat”, ejecutamos tres líneas, la primera indica a compila Main.java para poder disponer de la herramienta para generar nuestro analizador léxico, la segunda le indica a la herramienta Jlex que debe generar un analizador léxico en base al código fuente que se encuentra en el archivo “Lexico”, la tercera indica a Cup que la clase que debe generar para el analizador sintáctico se llamará “Sintactico” y que debe generarse en base al código fuente que se encuentra en el archivo “Sintactico”.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac JLex/Main.java</span><br><span class="line">java JLex.Main Lexico</span><br><span class="line">java -jar Cup/java-cup-11b.jar -parser Sintactico Sintactico</span><br></pre></td></tr></table></figure>

<p>Para ejecutarlo solo vamos a Netbeans, damos clic derecho sobre el archivo y seleccionamos la opción Run. Al finalizar la ejecución del archivo, veremos en la consola de Netbeans una salida como la siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">&#x27;C:/Users/erick/OneDrive/Documentos/NetBeansProjects/ProyectoCupJlexWindows/src/analizadores&#x27;</span></span><br><span class="line">C:/Users/erick/OneDrive/Documentos/NetBeansProjects/ProyectoCupJlexWindows/src/analizadores/compilar.bat </span><br><span class="line"></span><br><span class="line">C:\Users\erick\OneDrive\Documentos\NetBeansProjects\ProyectoCupJlexWindows\src\analizadores&gt;javac JLex/Main.java </span><br><span class="line">Note: JLex\Main.java uses unchecked or unsafe operations.</span><br><span class="line">Note: Recompile with -Xlint:unchecked <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">C:\Users\erick\OneDrive\Documentos\NetBeansProjects\ProyectoCupJlexWindows\src\analizadores&gt;java JLex.Main Lexico </span><br><span class="line">Processing first section -- user code.</span><br><span class="line">Processing second section -- JLex declarations.</span><br><span class="line">Processing third section -- lexical rules.</span><br><span class="line">Creating NFA machine representation.</span><br><span class="line">NFA comprised of 67 states.</span><br><span class="line">Working on character classes.:::::.:::::::::::::.:::.</span><br><span class="line">NFA has 24 distinct character classes.</span><br><span class="line">Creating DFA transition table.</span><br><span class="line">Working on DFA states...........................</span><br><span class="line">Minimizing DFA transition table.</span><br><span class="line">24 states after removal of redundant states.</span><br><span class="line">Outputting lexical analyzer code.</span><br><span class="line"></span><br><span class="line">C:\Users\erick\OneDrive\Documentos\NetBeansProjects\ProyectoCupJlexWindows\src\analizadores&gt;java -jar Cup/java-cup-11b.jar -parser Sintactico Sintactico </span><br><span class="line">------- CUP v0.11b 20160615 (GIT 4ac7450) Parser Generation Summary -------</span><br><span class="line">  0 errors and 0 warnings</span><br><span class="line">  15 terminals, 4 non-terminals, and 14 productions declared, </span><br><span class="line">  producing 28 unique parse states.</span><br><span class="line">  0 terminals declared but not used.</span><br><span class="line">  0 non-terminals declared but not used.</span><br><span class="line">  0 productions never reduced.</span><br><span class="line">  0 conflicts detected (0 expected).</span><br><span class="line">  Code written to <span class="string">&quot;Sintactico.java&quot;</span>, and <span class="string">&quot;sym.java&quot;</span>.</span><br><span class="line">---------------------------------------------------- (CUP v0.11b 20160615 (GIT 4ac7450))</span><br><span class="line"></span><br><span class="line">RUN SUCCESSFUL (total <span class="keyword">time</span>: 3s)</span><br></pre></td></tr></table></figure>

<p>Que nos confirma que la generación del analizador léxico fue exitosa y que la del analizador sintáctico también. Veremos que se han creado tres nuevos archivos en el paquete analizadores. Estos archivos son las clases: Lexico.java, Sintactico.java y sym.java.</p>


<p>La clase sym.java, sirve como puente entre la clase Lexico.java y Sintactico.java, por ejemplo, cuando el analizador léxico reconoce un número entero, instancia un objeto de la clase Symbol e indica que es de tipo número entero por medio de la constante “sym.ENTERO”, que se genera dentro de la clase sym.java y esta constante se genera porque en el archivo de entrada para Cup se indicó que existe un terminal llamado ENTERO. Entonces tanto el analizador léxico como el sintáctico hacen referencia a los tokens de tipo número entero con la constante “sym.ENTERO”. Básicamente eso es sym.java, una clase con muchas constantes estáticas a las que acceden ambos analizadores para poder integrarse y ejecutar sus tareas exitosamente.</p>
<h3 id="Creando-un-archivo-de-entrada-para-nuestros-analizadores"><a href="#Creando-un-archivo-de-entrada-para-nuestros-analizadores" class="headerlink" title="Creando un archivo de entrada para nuestros analizadores"></a><strong>Creando un archivo de entrada para nuestros analizadores</strong></h3><p>Dentro de la carpeta del proyecto crearé un archivo de entrada llamado “entrada.txt”. Que contendrá el archivo de entrada que reconocerán nuestros analizadores.</p>


<p>El archivo de “entrada.txt” contiene lo siguiente:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[<span class="number">1</span>+<span class="number">1</span>];</span><br><span class="line">Evaluar[<span class="number">1</span>+<span class="number">1</span>*<span class="number">2</span>];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>*<span class="number">6</span>/<span class="number">3</span>-<span class="number">5</span>+<span class="number">7</span>)];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>*<span class="number">6</span>/<span class="number">3</span>-<span class="number">5</span>+<span class="number">1</span>*-<span class="number">2</span>)];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>)];</span><br></pre></td></tr></table></figure>

<h3 id="Clase-principal"><a href="#Clase-principal" class="headerlink" title="Clase principal"></a><strong>Clase principal</strong></h3><p>Dentro de la clase principal solo tenemos el método <em>main</em> y el método interpretar que lee el contenido del archivo que se encuentra en el path que se le indica y ejecuta análisis léxico y análisis sintáctico, en el transcurso del analisis sintáctico se mandan a imprimir en consola los resultados de las expresiones aritméticas analizadas, por lo que al final del análisis tendremos todos los resultados de las operaciones en consola. A continuación se muestra el código de la clase principal.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io</span></span><br><span class="line"><span class="comment"> * Julio - 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> proyectocupjlexwindows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clase principal de la aplicación</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Erick</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProyectoCupJlexWindows</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args argumentos de la linea de comando</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        interpretar(<span class="string">&quot;entrada.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método que interpreta el contenido del archivo que se encuentra en el path</span></span><br><span class="line"><span class="comment">     * que recibe como parámentro</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path ruta del archivo a interpretar</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">interpretar</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        analizadores.Sintactico pars;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pars=<span class="keyword">new</span> <span class="title class_">analizadores</span>.Sintactico(<span class="keyword">new</span> <span class="title class_">analizadores</span>.Lexico(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path)));</span><br><span class="line">            pars.parse();        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error fatal en compilación de entrada.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Causa: &quot;</span>+ex.getCause());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ejecutando-nuestra-aplicacion"><a href="#Ejecutando-nuestra-aplicacion" class="headerlink" title="Ejecutando nuestra aplicación"></a><strong>Ejecutando nuestra aplicación</strong></h3><p>Al ejecutar la aplicación obtenemos los resultados de las operaciones evaluadas en consola.</p>


<p>Si les gusto este tutorial, puede que también estén interesados en este otro: <a href="/2019/04/26/05-Interprete-sencillo-utilizando-Java-Jlex-y-Cup/" title="Intérprete sencillo utilizando Java, Jlex y Cup">Intérprete sencillo utilizando Java, Jlex y Cup</a>.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-04-25T21:32:08.000Z" title="4/25/2019, 3:32:08 PM">2019-04-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/25/01-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Linux/">Mi primer proyecto utilizando Jlex y Cup (Linux)</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presenta como salida el resultado de dichas expresiones.</p>
<p>Las tecnologías a utilizar son:</p>
<ul>
<li><p><strong>Jlex</strong>: Generador de analizadores léxicos</p>
</li>
<li><p><strong>Cup</strong>: Generador de analizadores sintácticos</p>
</li>
<li><p><strong>Ubuntu 14.04</strong>: Sistema operativo basado en GNU&#x2F;Linux</p>
</li>
<li><p><strong>Netbeans 8.0</strong>: IDE (entorno de desarrollo integrado)</p>
</li>
</ul>
<p>El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoCupJlex">Mi primer proyecto utilizando Jlex y Cup (Linux)</a></li>
</ul>
<h3 id="JLex"><a href="#JLex" class="headerlink" title="JLex"></a><strong>JLex</strong></h3><p>JLex es un generador de analizadores léxicos, escrito en Java, para Java. JLex fue desarrollado por Elliot Berk en la Universidad de Princeton. Para más información visitar la <a target="_blank" rel="noopener" href="https://www.cs.princeton.edu/~appel/modern/java/JLex/">página oficial de JLex</a>.<br>La principal tarea de un analizador léxico es leer los caracteres de entrada del programa fuente, agruparlos en lexemas y producir como salida una secuencia de tokens.</p>
<ul>
<li><p>Un <em>token</em> es un par que consiste en un nombre de token y un valor de atributo opcional.</p>
</li>
<li><p>Un <em>lexema</em> es una secuencia de caracteres en el programa fuente, que coinciden con el patrón para un token y que el analizador léxico identifica como una instancia de este tóken.</p>
</li>
<li><p>Un <em>patrón</em> es una descripción de la forma que pueden tomar los lexemas de un token.</p>
</li>
</ul>
<p>En JLex se definen los patrones de los diferentes tokens que se desean reconocer, estos patrones pueden definirse a través de expresiones regulares. Además JLex cuenta con múltiples opciones, una muy imporante es su capacidad para integrarse con generadores de analizadores sintácticos como Cup.</p>
<h3 id="Cup"><a href="#Cup" class="headerlink" title="Cup"></a><strong>Cup</strong></h3><p><a target="_blank" rel="noopener" href="http://www2.cs.tum.edu/projects/cup/">Cup</a> es un generador de analizadores sintácticos de tipo LALR para Java.</p>
<p>El analizador sintáctico obtiene una cadena de tokens del analizador léxico y verifica que dicha cadena pueda generase con la gramática para el lenguaje fuente. Una gramática proporciona una especificación precisa y fácil de entender de un lenguaje de programación.</p>
<h3 id="Pre-requisitos"><a href="#Pre-requisitos" class="headerlink" title="Pre-requisitos"></a><strong>Pre-requisitos</strong></h3><p>Para este ejemplo hace falta que tengamos instalado:</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Java Development Kit (JDK)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://netbeans.org/downloads/">Netbeans</a></p>
</li>
</ul>
<h3 id="Instalacion-y-configuracion-de-las-herramientas"><a href="#Instalacion-y-configuracion-de-las-herramientas" class="headerlink" title="Instalación y configuración de las herramientas"></a><strong>Instalación y configuración de las herramientas</strong></h3><p>Lo primero que haremos será instalar JLex, para ello abrimos una terminal, en Ubuntu puede hacerse con la combinación de teclas Ctrl+Alt+t o en Aplicaciones → Accesorios → Terminal, una vez abierta la terminal ingresamos el comando “sudo apt-get install jlex”, autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado JLex.</p>


<p>Luego instalamos cup, ejecutando en la terminal el comando “sudo apt-get install cup”, autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado Cup.</p>


<p>Abrimos Netbeans y creamos un nuevo proyecto de Java (File → New Project).</p>




<p>Creamos un paquete llamado analizadores, este almacenará todo el código fuente relacionado con el analizador léxico y sintáctico (Clic derecho en Source Packages → New → Java Package).</p>




<p>Creamos tres archivos en el paquete analizadores, el primero “Lexico”, que almacenará el código fuente con el cual JLex generará el analizador léxico que queremos, el segundo “Sintactico”, que almacenará el código fuente con el cual Cup generará el analizador sintáctico que queremos y el tercero “compilar.sh”, que guardará los comandos que deben ejecutarse para solicitarle a JLex y a Cup que generen los analizadores. Para crear cada uno de los archivos hacemos clic derecho en el paquete analizadores → New → Other → en la ventana que despliegue, seleccionar Categories: Other y File Types: Empty File, seleccionamos siguiente, indicamos el nombre para el archivo y finalizamos. De tal modo que al final tendremos los tres archivos archivos.</p>


<p>Ahora importaremos la llibrería de Cup a nuestro proyecto de netbeans, para ello descargamos el archivo “java-cup-bin-11b-&lt;versión&gt;.tar.gz” de la <a target="_blank" rel="noopener" href="http://www2.cs.tum.edu/projects/cup/">página oficial de Cup</a>. En este caso el archivo descargado fue el “java-cup-bin-11b-20150326.tar.gz”.</p>


<p>Lo descomprimimos y veremos que contiene dos archivos .jar, el que nos interesa es el archivo “java-cup-11b-runtime.jar”.</p>


<p>Creamos una carpeta lib dentro de la carpeta de nuestro proyecto.</p>


<p>Dentro de la carpeta lib pegamos el archivo “java-cup-11b-runtime.jar”.</p>


<p>Para importar el archivo jar, vamos a Netbeans y damos clic derecho en la pestaña Libraries de nuestro proyecto → Add JAR&#x2F;Folder… luego buscamos el archivo jar en la carpeta lib que acabamos de crear y lo seleccionamos.</p>


<h3 id="Codigo-fuente-para-el-analizador-lexico"><a href="#Codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Código fuente para el analizador léxico"></a><strong>Código fuente para el analizador léxico</strong></h3><p>En el archivo “Lexico” incluiremos todo el código que le indicará a Jlex lo que debe hacer. El código se muestra a continuación:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io</span></span><br><span class="line"><span class="comment"> * Septiembre - 2015</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> analizadores;</span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.Symbol; </span><br><span class="line"></span><br><span class="line">%% </span><br><span class="line">%<span class="keyword">class</span> <span class="title class_">Lexico</span></span><br><span class="line">%<span class="keyword">public</span> </span><br><span class="line">%line </span><br><span class="line">%<span class="type">char</span> </span><br><span class="line">%cup </span><br><span class="line">%unicode</span><br><span class="line">%ignorecase</span><br><span class="line"></span><br><span class="line">%init&#123; </span><br><span class="line">	yyline = <span class="number">1</span>; </span><br><span class="line">	yychar = <span class="number">1</span>; </span><br><span class="line">%init&#125; </span><br><span class="line"></span><br><span class="line">BLANCOS=[ \r\t]+</span><br><span class="line">D=[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">DD=[<span class="number">0</span>-<span class="number">9</span>]+(<span class="string">&quot;.&quot;</span>[  |<span class="number">0</span>-<span class="number">9</span>]+)?</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Evaluar&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.REVALUAR,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;;&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PTCOMA,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;(&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;)&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARDER,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;[&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;]&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORDER,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;+&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MAS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;-&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MENOS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;*&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.POR,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;/&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DIVIDIDO,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">\n &#123;yychar=<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#123;BLANCOS&#125; &#123;&#125; </span><br><span class="line">&#123;D&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.ENTERO,yyline,yychar, yytext());&#125; </span><br><span class="line">&#123;DD&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DECIMAL,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Este es un error lexico: &quot;</span>+yytext()+</span><br><span class="line">	<span class="string">&quot;, en la linea: &quot;</span>+yyline+<span class="string">&quot;, en la columna: &quot;</span>+yychar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-lexico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Explicación del código fuente para el analizador léxico"></a><strong>Explicación del código fuente para el analizador léxico</strong></h3><p>En las primeras líneas indicamos a Jlex que la clase estará en el paquete analizadores y que es necesario que se importe la clase Symbol.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> analizadores;</span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.Symbol;</span><br></pre></td></tr></table></figure>
<p>Posteriormente indicamos a Jlex que:</p>
<ul>
<li><p>La clase del analizador se llamará “Lexico”</p>
</li>
<li><p>La clase será pública</p>
</li>
<li><p>Debe llevar el conteo de las líneas</p>
</li>
<li><p>Debe llevar el conteo de los caracteres reconocidos</p>
</li>
<li><p>Debe integrarse con cup</p>
</li>
<li><p>El set de caracteres que debe utilizar es el unicode</p>
</li>
<li><p>El analizador no será case sensitive, es decir, no le importa si las letras son mayúsculas o minúsculas</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%% </span><br><span class="line">%<span class="keyword">class</span> <span class="title class_">Lexico</span></span><br><span class="line">%<span class="keyword">public</span> </span><br><span class="line">%line </span><br><span class="line">%<span class="type">char</span> </span><br><span class="line">%cup </span><br><span class="line">%unicode</span><br><span class="line">%ignorecase</span><br></pre></td></tr></table></figure>

<p>Luego viene el bloque init, dentro del init, se ejecutan las acciones de inicialización, es decir, lo que va dentro del constructor del analizador léxico.En este caso indicamos dentro del init que:</p>
<ul>
<li><p>La variable yyline, que lleva la cuenta del número de linea por el que va el analizador valdrá inicialmente 1.</p>
</li>
<li><p>La variable yychar, que lleva la cuenta del número de carácter por el que va el analizador valdrá inicialmente 1.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%init&#123; </span><br><span class="line">	yyline = <span class="number">1</span>; </span><br><span class="line">	yychar = <span class="number">1</span>; </span><br><span class="line">%init&#125;</span><br></pre></td></tr></table></figure>

<p>Luego se escriben algunas expresiones regulares que son almacenadas en macros, que básicamente son variables que almacenan los patrones, en este caso se definen las macros: BLANCOS, D y DD. Los patrones para cada una son los siguientes:</p>
<ul>
<li><p>BLANCOS: Expresión regular que reconoce uno o muchos espacios en blanco, retornos de carro o tabuladores.</p>
</li>
<li><p>D: Expresión regular que reconoce números enteros.</p>
</li>
<li><p>DD: Expresión regular que reconoce números con punto decimal.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BLANCOS=[ \r\t]+</span><br><span class="line">D=[<span class="number">0</span>-<span class="number">9</span>]+</span><br><span class="line">DD=[<span class="number">0</span>-<span class="number">9</span>]+(<span class="string">&quot;.&quot;</span>[  |<span class="number">0</span>-<span class="number">9</span>]+)?</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<p>Por último se definen todas las reglas léxicas, en las que indicamos los patrones que reconocerá y dentro de llaves lo que debe hacer cuando los reconozca. En la mayoría de los casos se retorna un objeto de tipo Symbol, que vendría siendo un token, este se instancia con el tipo, la fila en la que se encontró, la columna en la que se encontró y el lexema en específico que se reconoció, este se obtiene mediante yytext(). Dentro de las llaves podríamos incluir el código java que quisiéramos. Vemos que al reconocer el patrón BLANCOS no se hace nada porque esperamos que ignore los espacios en blanco. También vemos que al encontrar un salto de linea reinicia la variable yychar, es decir, reinicia el conteo de caracteres para que se lleve la cuenta del número de columna en cada fila.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Evaluar&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.REVALUAR,yyline,yychar,</span><br><span class="line">                             yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;;&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PTCOMA,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;(&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;)&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.PARDER,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;[&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORIZQ,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;]&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.CORDER,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;+&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MAS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;-&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.MENOS,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;*&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.POR,yyline,yychar, yytext());&#125; </span><br><span class="line"><span class="string">&quot;/&quot;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DIVIDIDO,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">\n &#123;yychar=<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#123;BLANCOS&#125; &#123;&#125; </span><br><span class="line">&#123;D&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.ENTERO,yyline,yychar, yytext());&#125; </span><br><span class="line">&#123;DD&#125; &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Symbol</span>(sym.DECIMAL,yyline,yychar, yytext());&#125; </span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Este es un error lexico: &quot;</span>+yytext()+</span><br><span class="line">    <span class="string">&quot;, en la linea: &quot;</span>+yyline+<span class="string">&quot;, en la columna: &quot;</span>+yychar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Codigo-fuente-para-el-analizador-sintactico"><a href="#Codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Código fuente para el analizador sintáctico"></a><strong>Código fuente para el analizador sintáctico</strong></h3><p>En el archivo “Sintáctico” incluiremos todo el código que le indicará a Cup lo que debe hacer. El código se muestra a continuación:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io</span></span><br><span class="line"><span class="comment"> * Septiembre - 2015</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> analizadores; </span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.*;</span><br><span class="line"></span><br><span class="line">parser code </span><br><span class="line">&#123;:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintactico.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syntax_error</span><span class="params">(Symbol s)</span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error Sintáctico en la Línea &quot;</span> + (s.left) +</span><br><span class="line">        <span class="string">&quot; Columna &quot;</span>+s.right+ <span class="string">&quot;. No se esperaba este componente: &quot;</span> +s.value+<span class="string">&quot;.&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintáctico </span></span><br><span class="line"><span class="comment">     * en el que ya no es posible una recuperación de errores.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unrecovered_syntax_error</span><span class="params">(Symbol s)</span> <span class="keyword">throws</span> java.lang.Exception&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error síntactico irrecuperable en la Línea &quot;</span> + </span><br><span class="line">        (s.left)+ <span class="string">&quot; Columna &quot;</span>+s.right+<span class="string">&quot;. Componente &quot;</span> + s.value + </span><br><span class="line">        <span class="string">&quot; no reconocido.&quot;</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">:&#125; </span><br><span class="line"></span><br><span class="line">terminal String PTCOMA,PARIZQ,PARDER,CORIZQ,CORDER;</span><br><span class="line">terminal String MAS,MENOS,POR,DIVIDIDO;</span><br><span class="line">terminal String ENTERO;</span><br><span class="line">terminal String DECIMAL;</span><br><span class="line">terminal String UMENOS;</span><br><span class="line">terminal String REVALUAR;</span><br><span class="line"></span><br><span class="line">non terminal ini;</span><br><span class="line">non terminal instrucciones;</span><br><span class="line">non terminal instruccion;</span><br><span class="line">non terminal Double expresion;</span><br><span class="line"></span><br><span class="line">precedence left MAS,MENOS;</span><br><span class="line">precedence left POR,DIVIDIDO;</span><br><span class="line">precedence right UMENOS; </span><br><span class="line"></span><br><span class="line">start with ini; </span><br><span class="line"></span><br><span class="line">ini::=instrucciones;</span><br><span class="line"></span><br><span class="line">instrucciones ::= </span><br><span class="line">   instruccion instrucciones</span><br><span class="line"> | instruccion</span><br><span class="line"> | error instrucciones</span><br><span class="line">; </span><br><span class="line"></span><br><span class="line">instruccion ::= </span><br><span class="line">   REVALUAR CORIZQ expresion:a CORDER PTCOMA&#123;:System.out.println(<span class="string">&quot;El valor de la expresión es: &quot;</span>+a);:&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expresion  ::= </span><br><span class="line">    MENOS expresion:a                      &#123;:RESULT=a*-<span class="number">1</span>;:&#125;%prec UMENOS     </span><br><span class="line"> |  expresion:a MAS        expresion:b     &#123;:RESULT=a+b;:&#125;</span><br><span class="line"> |  expresion:a MENOS      expresion:b     &#123;:RESULT=a-b;:&#125;</span><br><span class="line"> |  expresion:a POR        expresion:b     &#123;:RESULT=a*b;:&#125;</span><br><span class="line"> |  expresion:a DIVIDIDO   expresion:b     &#123;:RESULT=a/b;:&#125;</span><br><span class="line"> |  ENTERO:a                               &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  DECIMAL:a                              &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  PARIZQ expresion:a PARDER              &#123;:RESULT=a;:&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-sintactico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Explicación del código fuente para el analizador sintáctico"></a><strong>Explicación del código fuente para el analizador sintáctico</strong></h3><p>En las primeras líneas indicamos a Cup que la clase estará en el paquete analizadores y que es necesario que se importe todo el contenido de “java_cup.runtime”.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> analizadores; </span><br><span class="line"><span class="keyword">import</span> java_cup.runtime.*;</span><br></pre></td></tr></table></figure>
<p>Luego viene la sección “parser code”, en la que se programan acciones propias del parser o analizador sintáctico que se va a generar, en este caso se programa lo que se debe hacer ante un error sintáctico y ante un error sintáctico irrecuperable.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">parser code </span><br><span class="line">&#123;:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintactico.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syntax_error</span><span class="params">(Symbol s)</span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error Sintáctico en la Línea &quot;</span> + (s.left) +</span><br><span class="line">        <span class="string">&quot; Columna &quot;</span>+s.right+ <span class="string">&quot;. No se esperaba este componente: &quot;</span> +s.value+<span class="string">&quot;.&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método al que se llama automáticamente ante algún error sintáctico </span></span><br><span class="line"><span class="comment">     * en el que ya no es posible una recuperación de errores.</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unrecovered_syntax_error</span><span class="params">(Symbol s)</span> <span class="keyword">throws</span> java.lang.Exception&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Error síntactico irrecuperable en la Línea &quot;</span> + </span><br><span class="line">        (s.left)+ <span class="string">&quot; Columna &quot;</span>+s.right+<span class="string">&quot;. Componente &quot;</span> + s.value + </span><br><span class="line">        <span class="string">&quot; no reconocido.&quot;</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">:&#125;</span><br></pre></td></tr></table></figure>

<p>Luego se definen los terminales, a estos se les puede indicar un tipo, en este caso todos son de tipo *String, *si no se indicara un tipo, los terminales serían por defecto de tipo <em>Object</em>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">terminal String PTCOMA,PARIZQ,PARDER,CORIZQ,CORDER;</span><br><span class="line">terminal String MAS,MENOS,POR,DIVIDIDO;</span><br><span class="line">terminal String ENTERO;</span><br><span class="line">terminal String DECIMAL;</span><br><span class="line">terminal String UMENOS;</span><br><span class="line">terminal String REVALUAR;</span><br></pre></td></tr></table></figure>

<p>Existe un terminal por cada tipo de token que el analizador léxico devuelve. Todos estos tipos estarán definidos en la clase “sym”, que se genera automáticamente y de la que se hablará más adelante.</p>
<p>Luego viene la declaración de los no terminales, a los que también se les puede indicar un tipo específico, si no se les indica un tipo, estos son por defecto de tipo <em>Object</em>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">non terminal ini;</span><br><span class="line">non terminal instrucciones;</span><br><span class="line">non terminal instruccion;</span><br><span class="line">non terminal Double expresion;</span><br></pre></td></tr></table></figure>

<p>Posteriormente, podemos indicar la precedencia de los operadores, ya que la gramática escrita es ambigua, es necesario definir una precedencia para que el analizador no entre en conflicto al analizar, en este caso la precedencia es la misma que la de los operadores aritméticos, la precedencia más baja la tienen la suma y la resta, luego están la multiplicación y la división que tienen una precedencia más alta y por último está el signo menos de las expresiones negativas que tendría la precedencia más alta.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">precedence left MAS,MENOS;</span><br><span class="line">precedence left POR,DIVIDIDO;</span><br><span class="line">precedence right UMENOS;</span><br></pre></td></tr></table></figure>

<p>Por último viene el conjunto de reglas de escritura de la gramática o producciones, al final de cada producción puede incluirse código java entre llaves y dos puntos “{:&lt;código java&gt;:}”. Podemos ver que en las producciones del no terminal “expresion”, se utiliza la variable RESULT, esta variable es propia de Cup y nos permite sintetizar cierto atributo para ese no terminal que se encuentra del lado izquierdo de la producción, recordemos que Cup trabaja con analizadores LALR, que son de tipo ascendente, lo que significa que nos permiten manipular atributos sintetizados. Básicamente eso es RESULT, un atributo sintetizado.</p>
<p>RESULT puede ser cualquier objeto, por ejemplo si quisiéramos que RESULT almacenara varios números enteros hacemos una clase Nodo que contenga muchas variables de tipo entero y declaramos los no terminales para que sean de tipo Nodo, entonces el RESULT que sintetizarán dichos no terminales serán de tipo Nodo.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">start with ini; </span><br><span class="line"></span><br><span class="line">ini::=instrucciones;</span><br><span class="line"></span><br><span class="line">instrucciones ::= </span><br><span class="line">   instruccion instrucciones</span><br><span class="line"> | instruccion</span><br><span class="line"> | error instrucciones</span><br><span class="line">; </span><br><span class="line"></span><br><span class="line">instruccion ::= </span><br><span class="line">   REVALUAR CORIZQ expresion:a CORDER PTCOMA&#123;:System.out.println(<span class="string">&quot;El valor de la expresión es: &quot;</span>+a);:&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expresion  ::= </span><br><span class="line">    MENOS expresion:a                      &#123;:RESULT=a*-<span class="number">1</span>;:&#125;%prec UMENOS     </span><br><span class="line"> |  expresion:a MAS        expresion:b     &#123;:RESULT=a+b;:&#125;</span><br><span class="line"> |  expresion:a MENOS      expresion:b     &#123;:RESULT=a-b;:&#125;</span><br><span class="line"> |  expresion:a POR        expresion:b     &#123;:RESULT=a*b;:&#125;</span><br><span class="line"> |  expresion:a DIVIDIDO   expresion:b     &#123;:RESULT=a/b;:&#125;</span><br><span class="line"> |  ENTERO:a                               &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  DECIMAL:a                              &#123;:RESULT=<span class="keyword">new</span> <span class="title class_">Double</span>(a);:&#125;</span><br><span class="line"> |  PARIZQ expresion:a PARDER              &#123;:RESULT=a;:&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="El-archivo-de-compilacion"><a href="#El-archivo-de-compilacion" class="headerlink" title="El archivo de compilación"></a><strong>El archivo de compilación</strong></h3><p>En el archivo “compilar.sh”, ejecutamos dos líneas, la primera indica a Jlex que debe generar un analizador léxico en base al código fuente que se encuentra en el archivo “Lexico”, la segunda indica a Cup que la clase que debe generar para el analizador sintáctico se llamará “Sintactico” y que debe generarse en base al código fuente que se encuentra en el archivo “Sintactico”.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jlex Lexico</span><br><span class="line">cup -parser Sintactico Sintactico</span><br></pre></td></tr></table></figure>

<p>Para ejecutarlo solo vamos a Netbeans, damos clic derecho sobre el archivo y seleccionamos la opción Run. Al finalizar la ejecución del archivo, veremos en la consola de Netbeans una salida como la siguiente:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Processing first section -- user code.</span><br><span class="line">Processing second section -- JLex declarations.</span><br><span class="line">Processing third section -- lexical rules.</span><br><span class="line">Creating NFA machine representation.</span><br><span class="line">NFA comprised of <span class="number">67</span> states.</span><br><span class="line">Working on character classes.:::::.:::::::::::::.:::.</span><br><span class="line">NFA has <span class="number">24</span> distinct character classes.</span><br><span class="line">Creating DFA transition table.</span><br><span class="line">Working on DFA states...........................</span><br><span class="line">Minimizing DFA transition table.</span><br><span class="line"><span class="number">24</span> states after removal of redundant states.</span><br><span class="line">Outputting lexical analyzer code.</span><br><span class="line">------- CUP v0.11a beta <span class="number">20060608</span> Parser Generation Summary -------</span><br><span class="line">  <span class="number">0</span> errors and <span class="number">0</span> warnings</span><br><span class="line">  <span class="number">15</span> terminals, <span class="number">4</span> non-terminals, and <span class="number">14</span> productions declared, </span><br><span class="line">  producing <span class="number">28</span> unique parse states.</span><br><span class="line">  <span class="number">0</span> terminals declared but not used.</span><br><span class="line">  <span class="number">0</span> non-terminals declared but not used.</span><br><span class="line">  <span class="number">0</span> productions never reduced.</span><br><span class="line">  <span class="number">0</span> conflicts <span class="title function_">detected</span> <span class="params">(<span class="number">0</span> expected)</span>.</span><br><span class="line">  Code written to <span class="string">&quot;Sintactico.java&quot;</span>, and <span class="string">&quot;sym.java&quot;</span>.</span><br><span class="line">---------------------------------------------------- (v0.11a beta <span class="number">20060608</span>)</span><br><span class="line"></span><br><span class="line">RUN <span class="title function_">SUCCESSFUL</span> <span class="params">(total time: 757ms)</span></span><br></pre></td></tr></table></figure>

<p>Que nos confirma que la generación del analizador léxico fue exitosa y que la del analizador sintáctico también. Veremos que se han creado tres nuevos archivos en el paquete analizadores. Estos archivos son las clases: Lexico.java, Sintactico.java y sym.java.</p>


<p>La clase sym.java, sirve como puente entre la clase Lexico.java y Sintactico.java, por ejemplo, cuando el analizador léxico reconoce un número entero, instancia un objeto de la clase Symbol e indica que es de tipo número entero por medio de la constante “sym.ENTERO”, que se genera dentro de la clase sym.java y esta constante se genera porque en el archivo de entrada para Cup se indicó que existe un terminal llamado ENTERO. Entonces tanto el analizador léxico como el sintáctico hacen referencia a los tokens de tipo número entero con la constante “sym.ENTERO”. Básicamente eso es sym.java, una clase con muchas constantes estáticas a las que acceden ambos analizadores para poder integrarse y ejecutar sus tareas exitosamente.</p>
<h3 id="Archivo-de-entrada"><a href="#Archivo-de-entrada" class="headerlink" title="Archivo de entrada"></a><strong>Archivo de entrada</strong></h3><p>Dentro de la carpeta del proyecto crearé un archivo de entrada llamado “entrada.txt”. Que contendrá el archivo de entrada que reconocerán nuestros analizadores.</p>


<p>El archivo de “entrada.txt” contiene lo siguiente:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[<span class="number">1</span>+<span class="number">1</span>];</span><br><span class="line">Evaluar[<span class="number">1</span>+<span class="number">1</span>*<span class="number">2</span>];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>*<span class="number">6</span>/<span class="number">3</span>-<span class="number">5</span>+<span class="number">7</span>)];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>*<span class="number">6</span>/<span class="number">3</span>-<span class="number">5</span>+<span class="number">1</span>*-<span class="number">2</span>)];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>)];</span><br></pre></td></tr></table></figure>

<h3 id="Clase-principal"><a href="#Clase-principal" class="headerlink" title="Clase principal"></a><strong>Clase principal</strong></h3><p>Dentro de la clase principal solo tenemos el método <em>main</em> y el método interpretar que lee el contenido del archivo que se encuentra en el path que se le indica y ejecuta análisis léxico y análisis sintáctico, en el transcurso del analisis sintáctico se mandan a imprimir en consola los resultados de las expresiones aritméticas analizadas, por lo que al final del análisis tendremos todos los resultados de las operaciones en consola. A continuación se muestra el código de la clase principal.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io</span></span><br><span class="line"><span class="comment"> * Septiembre - 2015</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> proyectocupjlex;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clase principal de la aplicación</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Erick</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProyectoCupJlex</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args argumentos de la linea de comando</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        interpretar(<span class="string">&quot;entrada.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Método que interpreta el contenido del archivo que se encuentra en el path</span></span><br><span class="line"><span class="comment">     * que recibe como parámentro</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path ruta del archivo a interpretar</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">interpretar</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        analizadores.Sintactico pars;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pars=<span class="keyword">new</span> <span class="title class_">analizadores</span>.Sintactico(<span class="keyword">new</span> <span class="title class_">analizadores</span>.Lexico(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path)));</span><br><span class="line">            pars.parse();        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error fatal en compilación de entrada.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Causa: &quot;</span>+ex.getCause());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ejecutando-nuestra-aplicacion"><a href="#Ejecutando-nuestra-aplicacion" class="headerlink" title="Ejecutando nuestra aplicación"></a><strong>Ejecutando nuestra aplicación</strong></h3><p>Al ejecutar la aplicación obtenemos los resultados de las operaciones evaluadas en consola.</p>


<p>Si les gusto este tutorial, puede que también estén interesados en este otro: <a href="/2019/04/26/05-Interprete-sencillo-utilizando-Java-Jlex-y-Cup/" title="Intérprete sencillo utilizando Java, Jlex y Cup">Intérprete sencillo utilizando Java, Jlex y Cup</a>.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/Computer-Science/">Previous</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/categories/Computer-Science/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/Computer-Science/">1</a></li><li><a class="pagination-link is-current" href="/categories/Computer-Science/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Erick Navarro"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Erick Navarro</p><p class="is-size-6 is-block">Data Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Guatemala</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.linkedin.com/in/ericknd/" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ericknavarro"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LinkedIn" href="https://www.linkedin.com/in/ericknd/"><i class="fab fa-linkedin"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AWS/"><span class="level-start"><span class="level-item">AWS</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/AWS/Alexa-Skills/"><span class="level-start"><span class="level-item">Alexa Skills</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/CloudFront/"><span class="level-start"><span class="level-item">CloudFront</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/EC2/"><span class="level-start"><span class="level-item">EC2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/Lambda/"><span class="level-start"><span class="level-item">Lambda</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/Route-53/"><span class="level-start"><span class="level-item">Route 53</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/S3/"><span class="level-start"><span class="level-item">S3</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Computer-Science/"><span class="level-start"><span class="level-item">Computer Science</span></span><span class="level-end"><span class="level-item tag">19</span></span></a><ul><li><a class="level is-mobile" href="/categories/Computer-Science/Compilers/"><span class="level-start"><span class="level-item">Compilers</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Computer-Science/Data-Structures/"><span class="level-start"><span class="level-item">Data Structures</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Programming/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/2020/10/01/27-Mi-primer-proyecto-utilizando-Yacc-y-Lex/"><img src="/gallery/thumbnails/27.png" alt="Mi primer proyecto utilizando Yacc y Lex"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-10-01T21:03:28.000Z">2020-10-01</time></p><p class="title"><a href="/2020/10/01/27-Mi-primer-proyecto-utilizando-Yacc-y-Lex/">Mi primer proyecto utilizando Yacc y Lex</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/03/15/26-Interprete-sencillo-utilizando-PLY/"><img src="/gallery/thumbnails/26.png" alt="Intérprete sencillo utilizando PLY con Python 3"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-03-16T01:09:28.000Z">2020-03-15</time></p><p class="title"><a href="/2020/03/15/26-Interprete-sencillo-utilizando-PLY/">Intérprete sencillo utilizando PLY con Python 3</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/03/07/25-Interprete-sencillo-utilizando-Javacc/"><img src="/gallery/thumbnails/25.png" alt="Intérprete sencillo utilizando JavaCC"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-03-07T19:53:33.000Z">2020-03-07</time></p><p class="title"><a href="/2020/03/07/25-Interprete-sencillo-utilizando-Javacc/">Intérprete sencillo utilizando JavaCC</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/02/10/24-Mi-primer-proyecto-utilizando-PLY/"><img src="/gallery/thumbnails/24.png" alt="Mi primer proyecto utilizando PLY con Python 3"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-02-10T22:17:25.000Z">2020-02-10</time></p><p class="title"><a href="/2020/02/10/24-Mi-primer-proyecto-utilizando-PLY/">Mi primer proyecto utilizando PLY con Python 3</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/02/10/23-Mi-primer-proyecto-utilizando-JavaCC/"><img src="/gallery/thumbnails/23.png" alt="Mi primer proyecto utilizando JavaCC"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-02-10T22:14:34.000Z">2020-02-10</time></p><p class="title"><a href="/2020/02/10/23-Mi-primer-proyecto-utilizando-JavaCC/">Mi primer proyecto utilizando JavaCC</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">October 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">August 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">May 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">April 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Alexa-Skills/"><span class="tag">Alexa Skills</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C#</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CloudFront/"><span class="tag">CloudFront</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compilers/"><span class="tag">Compilers</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Data-Structures/"><span class="tag">Data Structures</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EC2/"><span class="tag">EC2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lambda/"><span class="tag">Lambda</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Route-53/"><span class="tag">Route 53</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/S3/"><span class="tag">S3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Visual-Basic/"><span class="tag">Visual Basic</span><span class="tag">4</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Erick Navarro" height="28"></a><p class="is-size-7"><span>&copy; 2025 Erick Navarro</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>