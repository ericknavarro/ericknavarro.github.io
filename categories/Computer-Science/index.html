<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: Computer Science - Erick Navarro</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Erick Navarro"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Erick Navarro"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Erick Navarro"><meta property="og:url" content="https://ericknavarro.github.io/"><meta property="og:site_name" content="Erick Navarro"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://ericknavarro.github.io/img/og_image.png"><meta property="article:author" content="Erick Navarro"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ericknavarro.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ericknavarro.github.io"},"headline":"Erick Navarro","image":["https://ericknavarro.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Erick Navarro"},"publisher":{"@type":"Organization","name":"Erick Navarro","logo":{"@type":"ImageObject","url":"https://ericknavarro.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-145306707-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-145306707-1');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Erick Navarro" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Connect on LinkedIn" href="https://www.linkedin.com/in/ericknd/"><i class="fab fa-linkedin"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories/">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Computer Science</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-10-01T21:03:28.000Z" title="10/1/2020, 3:03:28 PM">2020-10-01</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/01/27-Mi-primer-proyecto-utilizando-Yacc-y-Lex/">Mi primer proyecto utilizando Yacc y Lex</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presenta como salida el resultado de dichas expresiones.</p>
<p>Las tecnologías a utilizar son:</p>
<ul>
<li><strong>Lex</strong>: Generador de analizadores léxicos</li>
<li><strong>Yacc</strong>: Generador de analizadores sintácticos</li>
<li><strong>Ubuntu 20.04</strong>: Sistema operativo</li>
<li><strong>Visual Studio Code</strong>: Editor de código fuente</li>
<li><strong>C</strong>: Lenguaje de programación</li>
</ul>
<p>El proyecto completo del ejemplo puede descargarse en el siguient enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC">Mi primer proyecto utilizando Yacc y Lex</a></li>
</ul>
<h3 id="Lex"><a href="#Lex" class="headerlink" title="Lex"></a><strong>Lex</strong></h3><p>Lex es una herramienta que permite generar analizadore léxicos a partir de un conjunto de reglas y expresiones regulares. Desarrollado por Eric Schmidt y Mike Lesk para los sistemas Unix. Escrito en C para C, su implementación para C++ es posible, aunque no es segura ya que está mas enfocado en el trabajo con C.<br>La principal tarea de un analizador léxico es leer los caracteres de entrada del programa fuente, agruparlos en lexemas y producir como salida una secuencia de tokens.</p>
<ul>
<li>Un <em>token</em> es un par que consiste en un nombre de token y un valor de atributo opcional.</li>
<li>Un <em>lexema</em> es una secuencia de caracteres en el programa fuente, que coinciden con el patrón para un token y que el analizador léxico identifica como una instancia de este token.</li>
<li>Un <em>patrón</em> es una descripción de la forma que pueden tomar los lexemas de un token.</li>
</ul>
<p>Para obtener más información de Lex, es recomendable visitar su <a target="_blank" rel="noopener" href="http://dinosaur.compilertools.net/lex">página oficial</a>.</p>
<h3 id="Yacc"><a href="#Yacc" class="headerlink" title="Yacc"></a><strong>Yacc</strong></h3><p>Yacc es un generador de analizadores sintácticos ascendentes escrito en C para C. Las siglas Yacc significan <em>Yet Another Compiler-Compiler</em>. Desarrollado por Stephen C. Jhonson en AT&amp;T para el sistema operativo Unix. </p>
<p>El analizador sintáctico obtiene una cadena de tokens del analizador léxico y verifica que dicha cadena pueda generase con la gramática para el lenguaje fuente. Una gramática proporciona una especificación precisa y fácil de entender de un lenguaje de programación.</p>
<p>Para obtener más información de Lex, es recomendable visitar su <a target="_blank" rel="noopener" href="http://dinosaur.compilertools.net/yacc">página oficial</a>.</p>
<h3 id="Pre-requisitos"><a href="#Pre-requisitos" class="headerlink" title="Pre-requisitos"></a><strong>Pre-requisitos</strong></h3><p>Para este ejemplo neceistamos las siguientes herramientas:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/">Compilador GCC</a></li>
<li><a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a> (o cualquier editor de texto de nuestro agrado)</li>
</ul>
<h3 id="Instalacion-y-configuracion-de-las-herramientas"><a href="#Instalacion-y-configuracion-de-las-herramientas" class="headerlink" title="Instalación y configuración de las herramientas"></a><strong>Instalación y configuración de las herramientas</strong></h3><p>Lo primero que haremos será instalar Lex, para ello abrimos una terminal, en Ubuntu puede hacerse con la combinación de teclas <strong>Ctrl + Alt + t</strong> o en <strong>Aplicaciones → Accesorios → Terminal</strong>, una vez abierta la terminal ingresamos el comando:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install flex</span><br></pre></td></tr></table></figure>
<p>Autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado <strong>Lex</strong>. Como nos pudimos dar cuenta, la instalación de Lex se hace a través Flex que es otra herramienta de analisis léxico. </p>


<p>Luego instalamos Yacc, ejecutando el comando: </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install bison</span><br></pre></td></tr></table></figure>
<p>Autenticamos ingresando nuestra contraseña y aceptamos la descarga e instalación, con esto quedará instalado <strong>Yacc</strong>. Como nos pudimos dar cuenta, la instalación de Yacc se hace a través de Bison que es otra herramienta de análisis sintáctico.</p>


<h3 id="Crear-nuestro-proyecto"><a href="#Crear-nuestro-proyecto" class="headerlink" title="Crear nuestro proyecto"></a><strong>Crear nuestro proyecto</strong></h3><p>Creamos un nuevo folder el cual será nuestro espacio de trabajo, para crearlo abrimos una terminal y ejecutamos el comando:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ProyectoLexYacc</span><br></pre></td></tr></table></figure>
<p>Luego ingresamos a nuestro folder con el comando:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ProyectoLexYacc</span><br></pre></td></tr></table></figure>




<p>Ahora nos pasamos a el editor de código, en este caso usaremos Visual Studio Code. Para abrir nuestro directorio de trabajo en Visual Studio Code ejecutamos desde la terminal el comando: </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure>
<p>El punto al final es importante, ya que le indica a Visual Studio Code que abra una nueva ventana en el directorio actual.</p>


<p>Esto desplegará una ventana de Visual Studio Code, con nuestro proyecto llamado <strong>ProyectoLexYacc</strong>.</p>


<p>Definimos la estructura de nuestro espacio de trabajo creando un directorio llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/tree/master/src">src</a> en donde estará todo nuestro código fuente. Dentro del directorio <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/tree/master/src">src</a> creamos un directorio <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/tree/master/src/analizador">analizador</a>, en este directorio estará todo el código relacionado con Yacc y Lex.</p>
<h3 id="Codigo-fuente-para-el-analizador-lexico"><a href="#Codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Código fuente para el analizador léxico"></a>Código fuente para el analizador léxico</h3><p>En el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/blob/master/src/analizador/lexer.l">lexer.l</a> incluiremos todo el código que le indicará a Lex lo que debe de hacer. El código se muestra a continuación:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%&#123; </span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;y.tab.h&quot;</span> </span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">yyerror</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line">%&#125; </span><br><span class="line"></span><br><span class="line">%option noyywrap</span><br><span class="line">  </span><br><span class="line">DIGIT   [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">NUM     &#123;DIGIT&#125;+(<span class="string">&quot;.&quot;</span>&#123;DIGIT&#125;+)?</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rule Section */</span></span><br><span class="line">%% </span><br><span class="line">&#123;NUM&#125;               &#123; yylval=atoi(yytext); <span class="keyword">return</span> NUMBER; &#125; </span><br><span class="line">[-()+*/;]            &#123; <span class="keyword">return</span> *yytext; &#125;</span><br><span class="line"><span class="string">&quot;evaluar&quot;</span>            &#123; <span class="keyword">return</span> EVALUAR; &#125;</span><br><span class="line">[[:blank:]] ;</span><br><span class="line">.                     yyerror(<span class="string">&quot;Unknown character&quot;</span>);</span><br><span class="line">%% </span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-codigo-fuente-para-el-analizador-lexico"><a href="#Explicacion-codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Explicación código fuente para el analizador léxico"></a>Explicación código fuente para el analizador léxico</h3><p>En las primeras lineas incluimos <code>stdio.h</code> para la lectura de archivos, luego incluimos la cabecera <code>y.tab.h</code> que es el archivo que genera Yacc para nuestro analizador sintáctico. Por último declaramos la función <code>yyerror</code>, función propia de Lex y Yacc para el manejo de errores léxicos.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%&#123; </span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;y.tab.h&quot;</span> </span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">yyerror</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line">%&#125; </span><br></pre></td></tr></table></figure>

<p>Establecemos una lista de directivas propias de Lex:</p>
<ul>
<li>La directiva <code>noyywrap</code> le indica a Lex que unicamente leera un archivo de entrada.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%option noyywrap</span><br></pre></td></tr></table></figure>

<ul>
<li>Luego se escriben algunas expresiones regulares para identificar enteros y decimales.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DIGIT   [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">NUM     &#123;DIGIT&#125;+(<span class="string">&quot;.&quot;</span>&#123;DIGIT&#125;+)?</span><br></pre></td></tr></table></figure>

<ul>
<li>Por último definimos todas las reglas léxicas, en las que indicamos los patrones que reconocerá y dentro de llaves lo que debe hacer cuando los reconozca. Para retornar nuestras reglas como tokens y que puedan ser utilizadas en el analizador sintáctico retornamos un id que le asignaremos a cada token, para los tokens de tipo símbolo retornamos la variable <code>yytext</code> para tener una definición más limpia y corta. En el caso de <code>NUM</code> adicional al token debemos regresar el valor numérico reconocido, por lo que es necesario hacer una conversión con la función <code>atoi</code> que convierte una cadena a un número y lo almacenamos en yyval. Para los espacios en blanco, Lex cuenta con una directiva <code>[[:blank]]</code> donde podemos ver que no retornamos ningún simbolo, ya que ignoramos los espacios en blanco. Luego indicamos con un punto que todo lo que no fue reconocido en las reglas anteriores será un error léxico.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Rule Section */</span></span><br><span class="line">%% </span><br><span class="line">&#123;NUM&#125;               &#123; yylval=<span class="built_in">atoi</span>(yytext); <span class="keyword">return</span> NUMBER; &#125; </span><br><span class="line">[-()+*/;]            &#123; <span class="keyword">return</span> *yytext; &#125;</span><br><span class="line"><span class="string">&quot;evaluar&quot;</span>            &#123; <span class="keyword">return</span> EVALUAR; &#125;</span><br><span class="line">[[:blank:]] ;</span><br><span class="line">.                     <span class="built_in">yyerror</span>(<span class="string">&quot;Unknown character&quot;</span>);</span><br><span class="line">%% </span><br></pre></td></tr></table></figure>

<h3 id="Codigo-fuente-para-el-analizador-sintactico"><a href="#Codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Código fuente para el analizador sintáctico"></a>Código fuente para el analizador sintáctico</h3><p>En el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/blob/master/src/analizador/parser.y">parser.y</a> incluiremos todo el código que le indicará a Yacc lo que debe de hacer. El código se muestra a continuación:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">%&#123; </span><br><span class="line">   <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">yylex</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="type">void</span> <span class="title function_">yyerror</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line">   FILE *yyin;</span><br><span class="line">%&#125; </span><br><span class="line">  </span><br><span class="line">%token NUMBER EVALUAR</span><br><span class="line">  </span><br><span class="line">%left <span class="string">&#x27;+&#x27;</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">%left <span class="string">&#x27;*&#x27;</span> <span class="string">&#x27;/&#x27;</span></span><br><span class="line">%left NEG</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Rule Section */</span></span><br><span class="line">%% </span><br><span class="line">  </span><br><span class="line">Init </span><br><span class="line">   : Lista &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">Lista </span><br><span class="line">   : Lista EVALUAR <span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\nResult=%d\n&quot;</span>, $<span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   | EVALUAR <span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">   &#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\nResult=%d\n&quot;</span>, $<span class="number">3</span>); </span><br><span class="line">   &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">Expr </span><br><span class="line">   : Expr <span class="string">&#x27;+&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span> + $<span class="number">3</span>; </span><br><span class="line">   &#125; </span><br><span class="line">   | Expr <span class="string">&#x27;-&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span> - $<span class="number">3</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   | Expr <span class="string">&#x27;*&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span> * $<span class="number">3</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   | Expr <span class="string">&#x27;/&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span>/$<span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   | <span class="string">&#x27;-&#x27;</span> Expr %prec NEG &#123;</span><br><span class="line">      $$ = -$<span class="number">2</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   |<span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span> </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">2</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   | NUMBER </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span>;</span><br><span class="line">   &#125; </span><br><span class="line">; </span><br><span class="line">  </span><br><span class="line">%% </span><br><span class="line">  </span><br><span class="line"><span class="comment">//driver code </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse</span><span class="params">(FILE *file)</span> &#123; </span><br><span class="line">   yyin = file;</span><br><span class="line">   yyparse();</span><br><span class="line">   fclose(yyin);</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">yyerror</span><span class="params">(<span class="type">char</span> *s)</span> &#123; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n&quot;</span>, s); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-codigo-fuente-para-el-analizador-sintactico"><a href="#Explicacion-codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Explicación código fuente para el analizador sintáctico"></a>Explicación código fuente para el analizador sintáctico</h3><p>En las primeras lineas incluimos el ficherio <code>stdio.h</code> para la lectura de archivos, luego declarramos la función <strong>yylex</strong>, que es la encargada del analizador léxico, también declaramos la función <strong>yyerror</strong>, que utiliza Yacc para el manejo de errores sintácticos. Por último declaramos una variable de tipo FILE llamada <strong>yyin</strong>, en esta indicaremos el archivo de entrada que será analizado.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%&#123; </span><br><span class="line">   <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">yylex</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">   <span class="type">void</span> <span class="title function_">yyerror</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br><span class="line">   FILE *yyin;</span><br><span class="line">%&#125; </span><br></pre></td></tr></table></figure>

<p>Luego se definen los no terminales, a estos se les puede indicar o no un tipo, por defecto es de tipo int. Los terminales que son símbolos y no retornan ningún identificador asociado al token en el analizador léxico no se agregan en esta sección.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******* TERMINALES ********/</span></span><br><span class="line">%token NUMBER EVALUAR</span><br></pre></td></tr></table></figure>

<p>Posteriormente podemos indicar la precedencia de operadores, ya que la gramática escrita es ambigua, es necesario definir una precedencia para que el analizador no entre en conflicto. El nivel de precendencia se define del mas bajo al mas alto. La precendencia mas baja la tienen la suma y la resta, seguido por la multiplicación y división y por último tenemos el signo menos de las expresiones negativas.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%left <span class="string">&#x27;+&#x27;</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">%left <span class="string">&#x27;*&#x27;</span> <span class="string">&#x27;/&#x27;</span></span><br><span class="line">%left NEG</span><br></pre></td></tr></table></figure>

<p>A continuación tenemos el conjunto de reglas de escritura de la gramática o producciones. Escribimos nuestras producciones, para asignar reglas de producción lo hacemos mediante llaves “{ }”, en esta sección podemos escribir código de C. Ya que los analizadores que utiliza Yacc son ascenentes, nos permiten sintetizar atributos, para sintentizar un atributo lo hacemos a traves del identificador “$$”.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line">Init </span><br><span class="line">   : Lista &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">Lista </span><br><span class="line">   : Lista EVALUAR <span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\nResult=%d\n&quot;</span>, $<span class="number">4</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   | EVALUAR <span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">   &#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\nResult=%d\n&quot;</span>, $<span class="number">3</span>); </span><br><span class="line">   &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">Expr </span><br><span class="line">   : Expr <span class="string">&#x27;+&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span> + $<span class="number">3</span>; </span><br><span class="line">   &#125; </span><br><span class="line">   | Expr <span class="string">&#x27;-&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span> - $<span class="number">3</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   | Expr <span class="string">&#x27;*&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span> * $<span class="number">3</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   | Expr <span class="string">&#x27;/&#x27;</span> Expr </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span>/$<span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   | <span class="string">&#x27;-&#x27;</span> Expr %prec NEG &#123;</span><br><span class="line">      $$ = -$<span class="number">2</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   |<span class="string">&#x27;(&#x27;</span> Expr <span class="string">&#x27;)&#x27;</span> </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">2</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   | NUMBER </span><br><span class="line">   &#123;</span><br><span class="line">      $$ = $<span class="number">1</span>;</span><br><span class="line">   &#125; </span><br><span class="line">;  </span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<p>Como último paso, definimos la función que será llamada para inciar el análisis sintáctico, que en este caso es la función <strong>parse</strong>, esta recibe como parámetro un FILE, que será nuestro archivo de entrada a ser analizado. Por último definimos la función <strong>yyerror</strong>, la cúal será llamada si existiera un error sintáctico, esta función es propia de Yacc.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse</span><span class="params">(FILE *file)</span> </span>&#123; </span><br><span class="line">   yyin = file;</span><br><span class="line">   <span class="built_in">yyparse</span>();</span><br><span class="line">   <span class="built_in">fclose</span>(yyin);</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n&quot;</span>, s); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="El-archivo-de-compilacion"><a href="#El-archivo-de-compilacion" class="headerlink" title="El archivo de compilación"></a>El archivo de compilación</h3><p>En el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/blob/master/src/analizador/compilar.sh">compilar.sh</a>, ejecutamos dos lineas, la primera indica a Lex que debe generar un analizador léxico en base al código fuente que se encuentra en el archivo Léxico. La segunda linea le indica a Yacc que genere los archivos de compilación para el analizador sintáctico en base al archvio Parser.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lex lexer.l</span><br><span class="line">yacc parser.y -d</span><br></pre></td></tr></table></figure>

<p>Para ejecutar abrimos una terminal sobre el directorio <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/tree/master/src/analizador">analizador</a> y ejecutamos lo siguiente:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./compilar.sh</span><br></pre></td></tr></table></figure>

<p><strong>Nota:</strong> Si el comando genera error, asegurese de que el archivo tenga permisos de ejecución.</p>
<p>Este comando genera una serie de archivos que se han mencionado ya anteriormente. Los archivos que genera son los siguientes:</p>
<ul>
<li>y.tab.c</li>
<li>y.tab.h</li>
<li>lex.yy.c</li>
</ul>
<h3 id="Archivo-de-entrada"><a href="#Archivo-de-entrada" class="headerlink" title="Archivo de entrada"></a>Archivo de entrada</h3><p>Dentro de la carpeta src del proyecto, creamos un archivo de entrada llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/blob/master/src/entrada.txt">entrada.txt</a>, que contendrá el archivo de enetrada que reconocerán nuestros analizadores.</p>
<p>El archivo contiene lo siguiente:</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">evaluar(1+1);</span><br><span class="line">evaluar(1+1*2);</span><br><span class="line">evaluar(-(1+1*6/3-5+7));</span><br><span class="line">evaluar(-(1+1*6/3-5+1*-2));</span><br><span class="line">evaluar(-(1+1));</span><br></pre></td></tr></table></figure>

<h3 id="Archivo-Principal"><a href="#Archivo-Principal" class="headerlink" title="Archivo Principal"></a>Archivo Principal</h3><p>Dentro del archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoLexYACC/blob/master/src/main.c">main.c</a>, declaramos el método <em>parse</em>, el cúal fue definido en el analizador sintáctico. Definimos nuestro método <em>main</em>, en este creamos abrimos un archivo a través de FILE, indicamos la ruta del archivo de entrada y por último llamamos a nuestro método parse y le pasamos como parámetro el archivo de entrada. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;analizador/y.tab.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse</span><span class="params">(FILE *file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;entrada.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    parse(file);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ejecutando-nuestra-aplicacion"><a href="#Ejecutando-nuestra-aplicacion" class="headerlink" title="Ejecutando nuestra aplicación"></a>Ejecutando nuestra aplicación</h3><p>Para ejecutar nuestra aplicación necesitamos compilar todos los archivos y generar el ejecutable. Esto lo realizamos con el compilador GCC ejecutando desde consola el siguiente comando:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c ./analizador/*.c</span><br></pre></td></tr></table></figure>

<p>Este nos genera un archivo <code>a.out</code>, que es el binario resultante de la compilación, este archivo lo ejecutamos desde consola y obtenemos la salida de nuestro proyecto.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure>



<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/erflod5">Erik Flores</a> y revisado por el Catedrático <a target="_blank" rel="noopener" href="https://github.com/ericknavarro">Erick Navarro</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h2 id="Fuentes-Consultadas"><a href="#Fuentes-Consultadas" class="headerlink" title="Fuentes Consultadas"></a>Fuentes Consultadas</h2><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-03-16T01:09:28.000Z" title="3/15/2020, 7:09:28 PM">2020-03-15</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/15/26-Interprete-sencillo-utilizando-PLY/">Intérprete sencillo utilizando PLY con Python 3</a></p><div class="content"><h3 id="Funcionamiento-de-la-aplicacion"><a href="#Funcionamiento-de-la-aplicacion" class="headerlink" title="Funcionamiento de la aplicación"></a><strong>Funcionamiento de la aplicación</strong></h3><p>En este tutorial se desarrolla un intérprete que recibe como entrada un archivo de texto que contiene varias sentencias de un lenguaje de programación diseñado especialmente para esta aplicación. Primero se hace análisis léxico y sintáctico de dicha entrada, durante el análisis sintáctico se carga en memoria un Árbol de Sintaxis Abstracta (AST) que se utiliza posteriormente para ejecutar las sentencias. El analizador se genera con PLY utilizando Python 3 en Ubuntu 18.04. El proyecto completo puede descargarse del siguiente enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly">Intérpete sencillo utilizando PLY con Python 3</a></li>
</ul>
<p>Todo el código del proyecto está documentado con comentarios que contienen los detalles de su funcionamiento.</p>
<p>Si se desea una introducción sobre el uso de PLY con Python pueden visitar el post: <a href="/2020/02/10/24-Mi-primer-proyecto-utilizando-PLY/" title="Mi primer proyecto utilizando PLY con Python 3">Mi primer proyecto utilizando PLY con Python 3</a>, en el cual se describen los pre-requisitos y los pasos para la creación del proyecto.</p>
<h3 id="El-lenguaje-de-entrada"><a href="#El-lenguaje-de-entrada" class="headerlink" title="El lenguaje de entrada"></a><strong>El lenguaje de entrada</strong></h3><p>Dentro de la carpeta del proyecto, hay un archivo de entrada llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/entrada.txt">entrada.txt</a> en el cual se muestran ejemplos de todas las funciones del lenguaje diseñado para esta aplicación, al leerlo se puede tener una idea clara de las funciones con las que el lenguaje cuenta, este archivo contiene lo siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//Se imprime el encabezado</span><br><span class="line">imprimir(<span class="string">&quot;Tablas de&quot;</span> &amp; <span class="string">&quot; multiplicar&quot;</span>);</span><br><span class="line"></span><br><span class="line">//Se declara la variable a, de tipo numero</span><br><span class="line">numero a;</span><br><span class="line">//Se asigna a la variable a el valor 0</span><br><span class="line">a=0;</span><br><span class="line">//Se declara la variable c, de tipo numero</span><br><span class="line">numero c;</span><br><span class="line">//Se asigna a la variable c el valor 0</span><br><span class="line">c=1;</span><br><span class="line">//Se imprime un separador</span><br><span class="line">imprimir(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">/**</span><br><span class="line"> * Se imprimen las tablas del 1 al 5 y </span><br><span class="line"> * para cada tabla, se imprimen los resultados</span><br><span class="line"> * desde el uno hasta el 5, esto se hace con </span><br><span class="line"> * dos ciclos <span class="keyword">while</span> anidados. </span><br><span class="line"> **/</span><br><span class="line">mientras(a&lt;4+c)&#123;	</span><br><span class="line">	a=a+1;</span><br><span class="line">	numero b;</span><br><span class="line">	b=0;</span><br><span class="line">	mientras(b&lt;4+c)&#123;</span><br><span class="line">		b=b+1;</span><br><span class="line">		imprimir(a &amp; <span class="string">&quot; * &quot;</span> &amp; b &amp; <span class="string">&quot; = &quot;</span> &amp; a * b);</span><br><span class="line">	&#125;</span><br><span class="line">	imprimir(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Se asigna a la variable a el valor de 11</span><br><span class="line">a=11;</span><br><span class="line">/**</span><br><span class="line"> * La variable b ya había sido declarada pero </span><br><span class="line"> * dentro del ámbito del primer ciclo <span class="keyword">while</span>, </span><br><span class="line"> * entonces no existe en este ámbito por lo que </span><br><span class="line"> * debe declararse.</span><br><span class="line"> **/</span><br><span class="line">numero b;</span><br><span class="line">//Se asigna valor de 12 a b y valor de 13 a c</span><br><span class="line">b=12;</span><br><span class="line">c=13;</span><br><span class="line">/**</span><br><span class="line"> * Se evalua si el valor de la variable a es </span><br><span class="line"> * mayor que 10, si el b es mayor que 11 y si</span><br><span class="line"> * el de c es mayor que 12. </span><br><span class="line"> **/</span><br><span class="line">If(a&gt;10)&#123;</span><br><span class="line">	imprimir(<span class="string">&quot;a es mayor que 10.&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(b&gt;11)&#123;</span><br><span class="line">		imprimir(<span class="string">&quot;a es mayor que 10 y b es mayor que 11.&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(c&gt;12)&#123;</span><br><span class="line">			imprimir(<span class="string">&quot;a es mayor que 10, b es mayor que 11 y c es mayor que 12.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	imprimir(<span class="string">&quot;a es menor o igual que 10.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Como se puede observar, el lenguaje acepta:</p>
<ul>
<li>Comentarios simples, es decir de una sola línea (&#x2F;&#x2F;)</li>
<li>Comentarios múltiples, es decir de más de una línea (&#x2F;* *&#x2F;)</li>
<li>Concatenación de cadenas mediante el operador <code>&amp;</code></li>
<li>Función Imprimir. Recibe como parámetro una cadena e imprime su valor en consola.</li>
<li>Declaración de variables. Únicamente se acepta definición de variables de tipo <code>numero</code> incluyendo enteros y decimales.</li>
<li>Asignación de variables. A cualquier variable se le puede asignar cualquier expresión que tenga como resultado un número.</li>
<li>Instrucción Mientras. Tiene el comportamiento clásico del ciclo while, ejecuta el ciclo mientras la expresión booleana que recibe sea verdadera. Esta instrucción soporta anidamiento. </li>
<li>Instrucción If e If-Else. Tiene el comportamiento clásico de las sentencias de selección If e If-Else, evalúa la expresión booleana y ejecuta el bloque de instrucciones en If si es verdadera. En caso contrario y si existe un bloque Else se ejecuta este bloque de instrucciones. Estas instrucciones también soportan anidamiento.</li>
<li>Expresiones aritméticas. Se soportan las expresiones aritméticas binarias: suma, resta, multiplicación y división. También la expresión unaria: negación. Adicionalmente se soporta expresiones agrupadas en paréntesis. Se maneja la precedencia habitual de las expresiones aritméticas.</li>
<li>Expresiones booleanas. Comparan dos expresiones que tengan como resultado un número y soportan unicamente los operados Mayor Que y Menor que (&lt;, &gt;).</li>
</ul>
<h3 id="El-analizador-lexico-y-sintactico"><a href="#El-analizador-lexico-y-sintactico" class="headerlink" title="El analizador léxico y sintáctico"></a><strong>El analizador léxico y sintáctico</strong></h3><p>En el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/gramatica.py">gramatica.py</a> detallamos la estructura del lenguaje utilizando PLY. A continuación detallaremos los aspectos más relevantes.</p>
<h3 id="Sobre-el-analizador-lexico"><a href="#Sobre-el-analizador-lexico" class="headerlink" title="Sobre el analizador léxico"></a><strong>Sobre el analizador léxico</strong></h3><p>El analizador léxico define los patrones para los tokens que deseamos reconocer. Hacemos uso de expresiones regulares para identificar números, cadenas y comentarios. Para esto hacemos uso del módulo <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/re.html">re</a> de Python</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">reservadas = &#123;</span><br><span class="line">    <span class="string">&#x27;numero&#x27;</span> : <span class="string">&#x27;NUMERO&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;imprimir&#x27;</span> : <span class="string">&#x27;IMPRIMIR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;mientras&#x27;</span> : <span class="string">&#x27;MIENTRAS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;if&#x27;</span> : <span class="string">&#x27;IF&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;else&#x27;</span> : <span class="string">&#x27;ELSE&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tokens  = [</span><br><span class="line">    <span class="string">&#x27;PTCOMA&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;LLAVIZQ&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;LLAVDER&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PARIZQ&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PARDER&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;IGUAL&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MAS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MENOS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;POR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;DIVIDIDO&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;CONCAT&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MENQUE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MAYQUE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;IGUALQUE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;NIGUALQUE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;DECIMAL&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ENTERO&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;CADENA&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ID&#x27;</span></span><br><span class="line">] + list(reservadas.values())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tokens</span></span><br><span class="line">t_PTCOMA    = r<span class="string">&#x27;;&#x27;</span></span><br><span class="line">t_LLAVIZQ   = r<span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line">t_LLAVDER   = r<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">t_PARIZQ    = r<span class="string">&#x27;\(&#x27;</span></span><br><span class="line">t_PARDER    = r<span class="string">&#x27;\)&#x27;</span></span><br><span class="line">t_IGUAL     = r<span class="string">&#x27;=&#x27;</span></span><br><span class="line">t_MAS       = r<span class="string">&#x27;\+&#x27;</span></span><br><span class="line">t_MENOS     = r<span class="string">&#x27;-&#x27;</span></span><br><span class="line">t_POR       = r<span class="string">&#x27;\*&#x27;</span></span><br><span class="line">t_DIVIDIDO  = r<span class="string">&#x27;/&#x27;</span></span><br><span class="line">t_CONCAT    = r<span class="string">&#x27;&amp;&#x27;</span></span><br><span class="line">t_MENQUE    = r<span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">t_MAYQUE    = r<span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">t_IGUALQUE  = r<span class="string">&#x27;==&#x27;</span></span><br><span class="line">t_NIGUALQUE = r<span class="string">&#x27;!=&#x27;</span></span><br><span class="line"></span><br><span class="line">def t_DECIMAL(t):</span><br><span class="line">    r<span class="string">&#x27;\d+\.\d+&#x27;</span></span><br><span class="line">    try:</span><br><span class="line">        t.value = <span class="built_in">float</span>(t.value)</span><br><span class="line">    except ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Float value too large %d&quot;</span>, t.value)</span><br><span class="line">        t.value = 0</span><br><span class="line">    <span class="built_in">return</span> t</span><br><span class="line"></span><br><span class="line">def t_ENTERO(t):</span><br><span class="line">    r<span class="string">&#x27;\d+&#x27;</span></span><br><span class="line">    try:</span><br><span class="line">        t.value = int(t.value)</span><br><span class="line">    except ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Integer value too large %d&quot;</span>, t.value)</span><br><span class="line">        t.value = 0</span><br><span class="line">    <span class="built_in">return</span> t</span><br><span class="line"></span><br><span class="line">def t_ID(t):</span><br><span class="line">     r<span class="string">&#x27;[a-zA-Z_][a-zA-Z_0-9]*&#x27;</span></span><br><span class="line">     t.type = reservadas.get(t.value.lower(),<span class="string">&#x27;ID&#x27;</span>)    <span class="comment"># Check for reserved words</span></span><br><span class="line">     <span class="built_in">return</span> t</span><br><span class="line"></span><br><span class="line">def t_CADENA(t):</span><br><span class="line">    r<span class="string">&#x27;\&quot;.*?\&quot;&#x27;</span></span><br><span class="line">    t.value = t.value[1:-1] <span class="comment"># remuevo las comillas</span></span><br><span class="line">    <span class="built_in">return</span> t </span><br><span class="line"></span><br><span class="line"><span class="comment"># Comentario de múltiples líneas /* .. */</span></span><br><span class="line">def t_COMENTARIO_MULTILINEA(t):</span><br><span class="line">    r<span class="string">&#x27;/\*(.|\n)*?\*/&#x27;</span></span><br><span class="line">    t.lexer.lineno += t.value.count(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Comentario simple // ...</span></span><br><span class="line">def t_COMENTARIO_SIMPLE(t):</span><br><span class="line">    r<span class="string">&#x27;//.*\n&#x27;</span></span><br><span class="line">    t.lexer.lineno += 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Caracteres ignorados</span></span><br><span class="line">t_ignore = <span class="string">&quot; \t&quot;</span></span><br><span class="line"></span><br><span class="line">def t_newline(t):</span><br><span class="line">    r<span class="string">&#x27;\n+&#x27;</span></span><br><span class="line">    t.lexer.lineno += t.value.count(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line">def t_error(t):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Illegal character &#x27;%s&#x27;&quot;</span> % t.value[0])</span><br><span class="line">    t.lexer.skip(1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Construyendo el analizador léxico</span></span><br><span class="line">import ply.lex as lex</span><br><span class="line">lexer = lex.lex()</span><br></pre></td></tr></table></figure>

<p>Nótese que los comentarios, saltos de líneas y espacios en blanco son ignorados (no retornan ningún valor). </p>
<p>Otro aspecto importante a destacar es que las palabras reservadas son tratadas como <code>Identificadores</code>, esto se debe a que PLY da precedencia a las expresiones regulares más generales. Por ejemplo, la palabra reservada “Imprimir” siempre hará match con la expresión regular de Identificador, por lo que si se define de la forma <code>t_IMPRIMIR = r&#39;imprimir&#39;</code> nunca será alcanzado. Esto lo hace con la finalidad de hacer el proceso de parsing más eficiente al tener menos expresiones regulares que evaluar.</p>
<h3 id="Sobre-el-analizador-sintactico"><a href="#Sobre-el-analizador-sintactico" class="headerlink" title="Sobre el analizador sintáctico"></a><strong>Sobre el analizador sintáctico</strong></h3><p>El objetivo principal de nuestro analizador sintáctico es validar que la entrada sea válida y, si lo es, construir el AST. Para lograr esto hacemos uso de la programación orientada a objetos. Específicamente haremos uso del polimorfismo para la construcción de nuestro árbol. Las clases utilizadas para construir las diferentes instrucciones que componen nuestro AST, están definidas en el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/instrucciones.py">instrucciones.py</a>.</p>
<p><strong>Clases para Instrucciones</strong></p>
<p>Primero definimos una clase abstracta <code>Instruccion</code>, esto nos permitirá abstraer las Instrucciones que soporta nuestro lenguaje:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Instruccion:</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;This is an abstract class&#x27;</span><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Seguidamente, definimos una clase concreta para cada una de las formas posibles que puede tomar <code>Instruccion</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Imprimir(Instruccion) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la instrucción imprimir.</span></span><br><span class="line"><span class="string">        La instrucción imprimir únicamente tiene como parámetro una cadena</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self,  cad) :</span><br><span class="line">        self.cad = cad</span><br><span class="line"></span><br><span class="line">class Mientras(Instruccion) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la instrucción mientras.</span></span><br><span class="line"><span class="string">        La instrucción mientras recibe como parámetro una expresión lógica y la lista</span></span><br><span class="line"><span class="string">        de instrucciones a ejecutar si la expresión lógica es verdadera.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, expLogica, instrucciones = []) :</span><br><span class="line">        self.expLogica = expLogica</span><br><span class="line">        self.instrucciones = instrucciones</span><br></pre></td></tr></table></figure>

<p>Por ejemplo, para la clase <code>Imprimir</code> vemos que extiende de <code>Instruccion</code> y que su única propiedad es la cadena que se va imprimir. Esta propiedad, <code>cadena</code>, es de tipo <code>ExpresionCadena</code> como veremos más adelante.</p>
<p>De la misma forma, la instrucción <code>Mientras</code> extiende de <code>Instruccion</code> y sus propiedades son la expresión lógica a evaluar y el set de instrucciones a ejecutar mientras la condición sea verdadera. <code>expLogica</code> es de tipo ExpresionLogica e <code>instrucciones</code> es una lista, y sus elementos son de tipo <code>Instrucción</code>.</p>
<p>El proceso es similar para las instrucciones de <code>Definición</code> y <code>Asignación</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Definicion(Instruccion) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la instrucción de definición de variables.</span></span><br><span class="line"><span class="string">        Recibe como parámetro el nombre del identificador a definir</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, <span class="built_in">id</span>) :</span><br><span class="line">        self.id = <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">class Asignacion(Instruccion) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la instrucción de asignación de variables</span></span><br><span class="line"><span class="string">        Recibe como parámetro el identificador a asignar y el valor que será asignado.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, <span class="built_in">id</span>, expNumerica) :</span><br><span class="line">        self.id = <span class="built_in">id</span></span><br><span class="line">        self.expNumerica = expNumerica</span><br></pre></td></tr></table></figure>

<p>Finalmente, completamos nuestras instrucciones con <code>If</code> e <code>If-Else</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class If(Instruccion) : </span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la instrucción if.</span></span><br><span class="line"><span class="string">        La instrucción if recibe como parámetro una expresión lógica y la lista</span></span><br><span class="line"><span class="string">        de instrucciones a ejecutar si la expresión lógica es verdadera.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, expLogica, instrucciones = []) :</span><br><span class="line">        self.expLogica = expLogica</span><br><span class="line">        self.instrucciones = instrucciones</span><br><span class="line"></span><br><span class="line">class IfElse(Instruccion) : </span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la instrucción if-else.</span></span><br><span class="line"><span class="string">        La instrucción if-else recibe como parámetro una expresión lógica y la lista</span></span><br><span class="line"><span class="string">        de instrucciones a ejecutar si la expresión lógica es verdadera y otro lista de instrucciones</span></span><br><span class="line"><span class="string">        a ejecutar si la expresión lógica es falsa.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, expLogica, instrIfVerdadero = [], instrIfFalso = []) :</span><br><span class="line">        self.expLogica = expLogica</span><br><span class="line">        self.instrIfVerdadero = instrIfVerdadero</span><br><span class="line">        self.instrIfFalso = instrIfFalso</span><br></pre></td></tr></table></figure>

<h3 id="Clases-para-Expresiones"><a href="#Clases-para-Expresiones" class="headerlink" title="Clases para Expresiones"></a><strong>Clases para Expresiones</strong></h3><p>De la misma manera que manejamos las instrucciones manejaremos las expresiones. Definimos 3 clases abstractas que representan los 3 tipos de expresiones soportadas por nuestro lenguaje: Expresiones Aritméticas, Expresiones con Cadenas y Expresiones Lógicas, todas ellas definidas dentro del archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/expresiones.py">expresiones.py</a>.</p>
<p>También haremos uso de enumeraciones para definir constantes de nuestras operaciones, esto es altamente recomendado para evitar bugs durante el desarrollo.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">class OPERACION_ARITMETICA(Enum) :</span><br><span class="line">    MAS = 1</span><br><span class="line">    MENOS = 2</span><br><span class="line">    POR = 3</span><br><span class="line">    DIVIDIDO = 4</span><br><span class="line"></span><br><span class="line">class OPERACION_LOGICA(Enum) :</span><br><span class="line">    MAYOR_QUE = 1</span><br><span class="line">    MENOR_QUE = 2</span><br><span class="line">    IGUAL = 3</span><br><span class="line">    DIFERENTE = 4</span><br></pre></td></tr></table></figure>

<p>Iniciamos definiendo nuestra clase <code>ExpresionNumerica</code> de tipo abstracta y será nuestra clase base para las expresiones numéricas.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ExpresionNumerica:</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa una expresión numérica</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Las formas que puede tomar nuestra clase <code>ExpresionNumerica</code> son las siguientes:</p>
<ul>
<li><code>ExpresionBinaria</code>. Representa una operación aritmética binaria, la clase recibe los 2 operados: <code>exp1</code> y <code>exp2</code>, ambos de tipos <code>ExpresionNumérica</code>. Y recibe el <code>operador</code> el cual es un calor de nuestro <code>enum</code> definidos anteriormente.</li>
<li><code>ExpresionNegativo</code>. Representa la operación aritmética unaria de negación. Únicamente recibe como parámetro la expresión que se negara, esta es también de tipo <code>ExpresionNumerica</code></li>
<li><code>ExpresionNumero</code>. Representa un valor terminal numérico. El parámetro <code>val</code> contiene el valor extraído por el analizador léxico.</li>
<li><code>ExpresionIdentificador</code>. Representa un identificador. El parámetro <code>id</code> representa el nombre de la variable que se desea operar.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class ExpresionBinaria(ExpresionNumerica) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la Expresión Aritmética Binaria.</span></span><br><span class="line"><span class="string">        Esta clase recibe los operandos y el operador</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, exp1, exp2, operador) :</span><br><span class="line">        self.exp1 = exp1</span><br><span class="line">        self.exp2 = exp2</span><br><span class="line">        self.operador = operador</span><br><span class="line"></span><br><span class="line">class ExpresionNegativo(ExpresionNumerica) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la Expresión Aritmética Negativa.</span></span><br><span class="line"><span class="string">        Esta clase recibe la expresion</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    def __init__(self, exp) :</span><br><span class="line">        self.exp = exp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ExpresionNumero(ExpresionNumerica) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa una expresión numérica entera o decimal.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, val = 0) :</span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line">class ExpresionIdentificador(ExpresionNumerica) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa un identificador.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, <span class="built_in">id</span> = <span class="string">&quot;&quot;</span>) :</span><br><span class="line">        self.id = <span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>Ahora, siguiendo el proceso anterior, definimos nuestras expresiones con cadenas.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class ExpresionCadena :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa una Expresión de tipo cadena.</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">class ExpresionConcatenar(ExpresionCadena) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa una Expresión de tipo cadena.</span></span><br><span class="line"><span class="string">        Recibe como parámetros las 2 expresiones a concatenar</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, exp1, exp2) :</span><br><span class="line">        self.exp1 = exp1</span><br><span class="line">        self.exp2 = exp2</span><br><span class="line"></span><br><span class="line">class ExpresionDobleComilla(ExpresionCadena) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa una cadena entre comillas doble.</span></span><br><span class="line"><span class="string">        Recibe como parámetro el valor del token procesado por el analizador léxico</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, val) :</span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line">class ExpresionCadenaNumerico(ExpresionCadena) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa una expresión numérica tratada como cadena.</span></span><br><span class="line"><span class="string">        Recibe como parámetro la expresión numérica</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    def __init__(self, exp) :</span><br><span class="line">        self.exp = exp</span><br></pre></td></tr></table></figure>
<p>Y finalmente, definimos nuestras expresiones lógicas</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ExpresionLogica() :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">        Esta clase representa la expresión lógica.</span></span><br><span class="line"><span class="string">        Esta clase recibe los operandos y el operador</span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, exp1, exp2, operador) :</span><br><span class="line">        self.exp1 = exp1</span><br><span class="line">        self.exp2 = exp2</span><br><span class="line">        self.operador = operador</span><br></pre></td></tr></table></figure>

<h3 id="Construccion-del-AST"><a href="#Construccion-del-AST" class="headerlink" title="Construcción del AST"></a><strong>Construcción del AST</strong></h3><p>Para construir el AST durante nuestro análisis sintáctico importamos nuestras clases de instrucciones y expresiones. Esto también incluye nuestros enum para las constantes, esto se hará en el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/gramatica.py">gramatica.py</a>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definición de la gramática</span></span><br><span class="line"></span><br><span class="line">from expresiones import *</span><br><span class="line">from instrucciones import *</span><br></pre></td></tr></table></figure>

<p>Una vez importados podemos hacer uso de ellas en la gramática. Por ejemplo, para la construcción de operaciones aritméticas hacemos uso de nuestras clases de tipo <code>ExpresionNumerica</code>, pasamos como parámetros los operandos y el tipo operación (utilizando nuestras constantes).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def p_expresion_binaria(t):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;expresion_numerica : expresion_numerica MAS expresion_numerica</span></span><br><span class="line"><span class="string">                        | expresion_numerica MENOS expresion_numerica</span></span><br><span class="line"><span class="string">                        | expresion_numerica POR expresion_numerica</span></span><br><span class="line"><span class="string">                        | expresion_numerica DIVIDIDO expresion_numerica&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> t[2] == <span class="string">&#x27;+&#x27;</span>  : t[0] = ExpresionBinaria(t[1], t[3], OPERACION_ARITMETICA.MAS)</span><br><span class="line">    <span class="keyword">elif</span> t[2] == <span class="string">&#x27;-&#x27;</span>: t[0] = ExpresionBinaria(t[1], t[3], OPERACION_ARITMETICA.MENOS)</span><br><span class="line">    <span class="keyword">elif</span> t[2] == <span class="string">&#x27;*&#x27;</span>: t[0] = ExpresionBinaria(t[1], t[3], OPERACION_ARITMETICA.POR)</span><br><span class="line">    <span class="keyword">elif</span> t[2] == <span class="string">&#x27;/&#x27;</span>: t[0] = ExpresionBinaria(t[1], t[3], OPERACION_ARITMETICA.DIVIDIDO)</span><br><span class="line"></span><br><span class="line">def p_expresion_unaria(t):</span><br><span class="line">    <span class="string">&#x27;expresion_numerica : MENOS expresion_numerica %prec UMENOS&#x27;</span></span><br><span class="line">    t[0] = ExpresionNegativo(t[2])</span><br><span class="line"></span><br><span class="line">def p_expresion_agrupacion(t):</span><br><span class="line">    <span class="string">&#x27;expresion_numerica : PARIZQ expresion_numerica PARDER&#x27;</span></span><br><span class="line">    t[0] = t[2]</span><br><span class="line"></span><br><span class="line">def p_expresion_number(t):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;expresion_numerica : ENTERO</span></span><br><span class="line"><span class="string">                        | DECIMAL&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    t[0] = ExpresionNumero(t[1])</span><br><span class="line"></span><br><span class="line">def p_expresion_id(t):</span><br><span class="line">    <span class="string">&#x27;expresion_numerica   : ID&#x27;</span></span><br><span class="line">    t[0] = ExpresionIdentificador(t[1])</span><br></pre></td></tr></table></figure>

<p>El proceso es el mismo para las Instrucciones, cada producción de tipo Instrucción construye una instancia concreta de la instrucción apropiada.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def p_instruccion_imprimir(t) :</span><br><span class="line">    <span class="string">&#x27;imprimir_instr     : IMPRIMIR PARIZQ expresion_cadena PARDER PTCOMA&#x27;</span></span><br><span class="line">    t[0] =Imprimir(t[3])</span><br><span class="line"></span><br><span class="line">def p_instruccion_definicion(t) :</span><br><span class="line">    <span class="string">&#x27;definicion_instr   : NUMERO ID PTCOMA&#x27;</span></span><br><span class="line">    t[0] =Definicion(t[2])</span><br><span class="line"></span><br><span class="line">def p_asignacion_instr(t) :</span><br><span class="line">    <span class="string">&#x27;asignacion_instr   : ID IGUAL expresion_numerica PTCOMA&#x27;</span></span><br><span class="line">    t[0] =Asignacion(t[1], t[3])</span><br><span class="line"></span><br><span class="line">def p_mientras_instr(t) :</span><br><span class="line">    <span class="string">&#x27;mientras_instr     : MIENTRAS PARIZQ expresion_logica PARDER LLAVIZQ instrucciones LLAVDER&#x27;</span></span><br><span class="line">    t[0] =Mientras(t[3], t[6])</span><br><span class="line"></span><br><span class="line">def p_if_instr(t) :</span><br><span class="line">    <span class="string">&#x27;if_instr           : IF PARIZQ expresion_logica PARDER LLAVIZQ instrucciones LLAVDER&#x27;</span></span><br><span class="line">    t[0] =If(t[3], t[6])</span><br><span class="line"></span><br><span class="line">def p_if_else_instr(t) :</span><br><span class="line">    <span class="string">&#x27;if_else_instr      : IF PARIZQ expresion_logica PARDER LLAVIZQ instrucciones LLAVDER ELSE LLAVIZQ instrucciones LLAVDER&#x27;</span></span><br><span class="line">    t[0] =IfElse(t[3], t[6], t[10])</span><br></pre></td></tr></table></figure>

<p>Finalmente, una vez que hayamos reconocido toda la entrada, construimos un arreglo con cada uno de los nodos. Este será nuestro AST.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def p_init(t) :</span><br><span class="line">    <span class="string">&#x27;init            : instrucciones&#x27;</span></span><br><span class="line">    t[0] = t[1]</span><br><span class="line"></span><br><span class="line">def p_instrucciones_lista(t) :</span><br><span class="line">    <span class="string">&#x27;instrucciones    : instrucciones instruccion&#x27;</span></span><br><span class="line">    t[1].append(t[2])</span><br><span class="line">    t[0] = t[1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def p_instrucciones_instruccion(t) :</span><br><span class="line">    <span class="string">&#x27;instrucciones    : instruccion &#x27;</span></span><br><span class="line">    t[0] = [t[1]]</span><br><span class="line"></span><br><span class="line">def p_instruccion(t) :</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;instruccion      : imprimir_instr</span></span><br><span class="line"><span class="string">                        | definicion_instr</span></span><br><span class="line"><span class="string">                        | asignacion_instr</span></span><br><span class="line"><span class="string">                        | mientras_instr</span></span><br><span class="line"><span class="string">                        | if_instr</span></span><br><span class="line"><span class="string">                        | if_else_instr&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    t[0] = t[1]</span><br></pre></td></tr></table></figure>

<h3 id="La-tabla-de-simbolos"><a href="#La-tabla-de-simbolos" class="headerlink" title="La tabla de símbolos"></a><strong>La tabla de símbolos</strong></h3><p>La <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/ts.py">tabla de símbolos</a> es la que permite el almacenamiento y recuperación de los valores de las variables. Para su implementación hacemos uso de una clase, ya que necesitaremos más de una instancia de tabla de símbolos. Cada ámbito tiene acceso únicamente a su propia tabla de símbolos y a la de los niveles superiores, la definición de esta clase puede encontrarse en el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/ts.py">ts.py</a>.</p>
<p>Definimos las constantes para los tipos de datos, en este tutorial se hace uso únicamente del tipo de dato numérico.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">class TIPO_DATO(Enum) :</span><br><span class="line">    NUMERO = 1</span><br></pre></td></tr></table></figure>

<p>Definimos una clase para los Símbolos.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Simbolo() :</span><br><span class="line">    <span class="string">&#x27;Esta clase representa un simbolo dentro de nuestra tabla de simbolos&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, <span class="built_in">id</span>, tipo, valor) :</span><br><span class="line">        self.id = <span class="built_in">id</span></span><br><span class="line">        self.tipo = tipo</span><br><span class="line">        self.valor = valor</span><br></pre></td></tr></table></figure>

<p>La clase <code>TablaDeSimbolos</code> define la estructura de una tabla de símbolos y sus funciones para agregar, modificar y obtener símbolos.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class TablaDeSimbolos() :</span><br><span class="line">    <span class="string">&#x27;Esta clase representa la tabla de simbolos&#x27;</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, simbolos = &#123;&#125;) :</span><br><span class="line">        self.simbolos = simbolos</span><br><span class="line"></span><br><span class="line">    def agregar(self, simbolo) :</span><br><span class="line">        self.simbolos[simbolo.id] = simbolo</span><br><span class="line">    </span><br><span class="line">    def obtener(self, <span class="built_in">id</span>) :</span><br><span class="line">        <span class="keyword">if</span> not <span class="built_in">id</span> <span class="keyword">in</span> self.simbolos :</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error: variable &#x27;</span>, <span class="built_in">id</span>, <span class="string">&#x27; no definida.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> self.simbolos[<span class="built_in">id</span>]</span><br><span class="line"></span><br><span class="line">    def actualizar(self, simbolo) :</span><br><span class="line">        <span class="keyword">if</span> not simbolo.id <span class="keyword">in</span> self.simbolos :</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error: variable &#x27;</span>, simbolo.id, <span class="string">&#x27; no definida.&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            self.simbolos[simbolo.id] = simbolo</span><br></pre></td></tr></table></figure>

<h3 id="Construccion-del-Interprete"><a href="#Construccion-del-Interprete" class="headerlink" title="Construcción del Intérprete"></a><strong>Construcción del Intérprete</strong></h3><p>La definición del Intérprete se encuentra en el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloPly/blob/master/principal.py">principal.py</a> </p>
<p>Para iniciar con la implementación, primero importamos nuestra gramática, las constantes y clases de nuestro AST y  la Tabla de Símbolos.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import gramatica as g</span><br><span class="line">import ts as TS</span><br><span class="line">from expresiones import *</span><br><span class="line">from instrucciones import *</span><br></pre></td></tr></table></figure>

<p>Seguidamente, obtenemos el AST a partir del archivo de entrada.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">&quot;./entrada.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">input = f.read()</span><br><span class="line"></span><br><span class="line">instrucciones = g.parse(input)</span><br><span class="line">ts_global = TS.TablaDeSimbolos()</span><br><span class="line"></span><br><span class="line">procesar_instrucciones(instrucciones, ts_global)</span><br></pre></td></tr></table></figure>

<p>Nótese que el AST está contenido en la variable <code>instrucciones</code>. </p>
<p>La función principal del intérprete es de reconocer cada instrucción y ejecutarla, para esto es necesario recorrer el AST; es por ello que se ha definido la función <code>procesar_instrucciones</code> la cual itera las instrucciones en un ámbito y las ejecuta.</p>
<p>Para iniciar con la ejecución se crea la tabla de símbolos para el ámbito global y se invoca la función <code>procesar_instrucciones</code> con la raíz del AST y la tabla de símbolos del ámbito global.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def procesar_instrucciones(instrucciones, ts) :</span><br><span class="line">    <span class="comment">## lista de instrucciones recolectadas</span></span><br><span class="line">    <span class="keyword">for</span> instr <span class="keyword">in</span> instrucciones :</span><br><span class="line">        <span class="keyword">if</span> isinstance(instr, Imprimir) : procesar_imprimir(instr, ts)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(instr, Definicion) : procesar_definicion(instr, ts)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(instr, Asignacion) : procesar_asignacion(instr, ts)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(instr, Mientras) : procesar_mientras(instr, ts)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(instr, If) : procesar_if(instr, ts)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(instr, IfElse) : procesar_if_else(instr, ts)</span><br><span class="line">        <span class="keyword">else</span> : <span class="built_in">print</span>(<span class="string">&#x27;Error: instrucción no válida&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>Existe una función para procesar cada instrucción. </p>
<p>Las sentencias Mientras, If e If-Else crean nuevas tablas de símbolos antes de procesar las instrucciones dentro de sus bloques de instrucciones. Estas nuevas tablas de símbolos se inicializan con los valores de la tabla de símbolo actual y al terminar la ejecución de la sentencia los valores son eliminados ya que la instancia se crea localmente en el cuerpo de la función.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def procesar_mientras(instr, ts) :</span><br><span class="line">    <span class="keyword">while</span> resolver_expreision_logica(instr.expLogica, ts) :</span><br><span class="line">        ts_local = TS.TablaDeSimbolos(ts.simbolos)</span><br><span class="line">        procesar_instrucciones(instr.instrucciones, ts_local)</span><br><span class="line"></span><br><span class="line">def procesar_if(instr, ts) :</span><br><span class="line">    val = resolver_expreision_logica(instr.expLogica, ts)</span><br><span class="line">    <span class="keyword">if</span> val :</span><br><span class="line">        ts_local = TS.TablaDeSimbolos(ts.simbolos)</span><br><span class="line">        procesar_instrucciones(instr.instrucciones, ts_local)</span><br><span class="line"></span><br><span class="line">def procesar_if_else(instr, ts) :</span><br><span class="line">    val = resolver_expreision_logica(instr.expLogica, ts)</span><br><span class="line">    <span class="keyword">if</span> val :</span><br><span class="line">        ts_local = TS.TablaDeSimbolos(ts.simbolos)</span><br><span class="line">        procesar_instrucciones(instr.instrIfVerdadero, ts_local)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        ts_local = TS.TablaDeSimbolos(ts.simbolos)</span><br><span class="line">        procesar_instrucciones(instr.instrIfFalso, ts_local)</span><br></pre></td></tr></table></figure>

<p>Las sentencias de Declaración y Asignación agregan y modifican valores de la tabla de símbolos. La sentencia Imprimir muestra el valor de una cadena en la consola.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def procesar_imprimir(instr, ts) :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&gt; &#x27;</span>, resolver_cadena(instr.cad, ts))</span><br><span class="line"></span><br><span class="line">def procesar_definicion(instr, ts) :</span><br><span class="line">    simbolo = TS.Simbolo(instr.id, TS.TIPO_DATO.NUMERO, 0)      <span class="comment"># inicializamos con 0 como valor por defecto</span></span><br><span class="line">    ts.agregar(simbolo)</span><br><span class="line"></span><br><span class="line">def procesar_asignacion(instr, ts) :</span><br><span class="line">    val = resolver_expresion_aritmetica(instr.expNumerica, ts)</span><br><span class="line">    simbolo = TS.Simbolo(instr.id, TS.TIPO_DATO.NUMERO, val)</span><br><span class="line">    ts.actualizar(simbolo)</span><br></pre></td></tr></table></figure>

<p>Finalmente, todas las sentencias descritas anteriormente hacen uso de las operaciones numéricas, con cadenas y lógicas las cuales hacen uso de la tabla de símbolos para obtener valores de las variables.</p>
<p>Para las expresiones numéricas evaluamos el tipo de operación y con base en ellos resolvemos el valor apropiado</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def resolver_expresion_aritmetica(expNum, ts) :</span><br><span class="line">    <span class="keyword">if</span> isinstance(expNum, ExpresionBinaria) :</span><br><span class="line">        exp1 = resolver_expresion_aritmetica(expNum.exp1, ts)</span><br><span class="line">        exp2 = resolver_expresion_aritmetica(expNum.exp2, ts)</span><br><span class="line">        <span class="keyword">if</span> expNum.operador == OPERACION_ARITMETICA.MAS : <span class="built_in">return</span> exp1 + exp2</span><br><span class="line">        <span class="keyword">if</span> expNum.operador == OPERACION_ARITMETICA.MENOS : <span class="built_in">return</span> exp1 - exp2</span><br><span class="line">        <span class="keyword">if</span> expNum.operador == OPERACION_ARITMETICA.POR : <span class="built_in">return</span> exp1 * exp2</span><br><span class="line">        <span class="keyword">if</span> expNum.operador == OPERACION_ARITMETICA.DIVIDIDO : <span class="built_in">return</span> exp1 / exp2</span><br><span class="line">    <span class="keyword">elif</span> isinstance(expNum, ExpresionNegativo) :</span><br><span class="line">        exp = resolver_expresion_aritmetica(expNum.exp, ts)</span><br><span class="line">        <span class="built_in">return</span> exp * -1</span><br><span class="line">    <span class="keyword">elif</span> isinstance(expNum, ExpresionNumero) :</span><br><span class="line">        <span class="built_in">return</span> expNum.val</span><br><span class="line">    <span class="keyword">elif</span> isinstance(expNum, ExpresionIdentificador) :</span><br><span class="line">        <span class="built_in">return</span> ts.obtener(expNum.<span class="built_in">id</span>).valor</span><br></pre></td></tr></table></figure>

<p>Para las expresiones con cadenas también validamos el tipo de operación para verificar si es necesario una operación de concatenación. En cualquier caso se resuelve la cadena.  También es posible concatenar valores numéricos, para esto resolvemos la expresión apoyándonos de la función para procesar expresiones numéricas.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def resolver_cadena(expCad, ts) :</span><br><span class="line">    <span class="keyword">if</span> isinstance(expCad, ExpresionConcatenar) :</span><br><span class="line">        exp1 = resolver_cadena(expCad.exp1, ts)</span><br><span class="line">        exp2 = resolver_cadena(expCad.exp2, ts)</span><br><span class="line">        <span class="built_in">return</span> exp1 + exp2</span><br><span class="line">    <span class="keyword">elif</span> isinstance(expCad, ExpresionDobleComilla) :</span><br><span class="line">        <span class="built_in">return</span> expCad.val</span><br><span class="line">    <span class="keyword">elif</span> isinstance(expCad, ExpresionCadenaNumerico) :</span><br><span class="line">        <span class="built_in">return</span> str(resolver_expresion_aritmetica(expCad.exp, ts))</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error: Expresión cadena no válida&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>Al igual que las expresiones con cadena, las expresiones lógicas también se apoya en la función que procesa expresiones numéricas para poder evaluar las condiciones booleanas.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def resolver_expreision_logica(expLog, ts) :</span><br><span class="line">    exp1 = resolver_expresion_aritmetica(expLog.exp1, ts)</span><br><span class="line">    exp2 = resolver_expresion_aritmetica(expLog.exp2, ts)</span><br><span class="line">    <span class="keyword">if</span> expLog.operador == OPERACION_LOGICA.MAYOR_QUE : <span class="built_in">return</span> exp1 &gt; exp2</span><br><span class="line">    <span class="keyword">if</span> expLog.operador == OPERACION_LOGICA.MENOR_QUE : <span class="built_in">return</span> exp1 &lt; exp2</span><br><span class="line">    <span class="keyword">if</span> expLog.operador == OPERACION_LOGICA.IGUAL : <span class="built_in">return</span> exp1 == exp2</span><br><span class="line">    <span class="keyword">if</span> expLog.operador == OPERACION_LOGICA.DIFERENTE : <span class="built_in">return</span> exp1 != exp2</span><br></pre></td></tr></table></figure>

<p>Para ejecutar nuestro intérprete y procesar el archivo de entrada ejecutamos el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 ./principal.py</span><br></pre></td></tr></table></figure>

<p>Y veremos el resultado en consola.</p>


<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/rjanixz">Rainman Sián</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-03-07T19:53:33.000Z" title="3/7/2020, 1:53:33 PM">2020-03-07</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/07/25-Interprete-sencillo-utilizando-Javacc/">Intérprete sencillo utilizando JavaCC</a></p><div class="content"><p>De no estar familiarizado con la herramienta JavaCC, se recomienda al lector seguir el siguiente tutorial:</p>
<ul>
<li><a href="/2020/02/10/23-Mi-primer-proyecto-utilizando-JavaCC/" title="Mi primer proyecto utilizando JavaCC">Mi primer proyecto utilizando JavaCC</a></li>
</ul>
<p>El desarrollo con JavaCC resulta sencillo, pero la legibilidad de la gramática puede llegar a ser un inconveniente si no se trata con la atención debida, sin embargo, el resto de las funcionalidades que nos ofrece JavaCC son un buen aliciente para utilizarlo, por lo tanto en esta ocasión vamos a desarrollar un intérprete, este contendrá la ejecución de sentencias básicas, como declaraciones de variables, asignaciones, sentencias de control, funciones y demás. El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC">Intérprete sencillo utilizando JavaCC</a></li>
</ul>
<h3 id="Conceptos-basicos"><a href="#Conceptos-basicos" class="headerlink" title="Conceptos básicos"></a><strong>Conceptos básicos</strong></h3><ul>
<li><strong>Intérprete</strong>: Es un tipo común de procesador de lenguaje. En vez de producir un programa destino como una traducción, el intérprete ejecuta directamente las operaciones especificadas en el programa de origen (fuente) con las entradas proporcionadas por el usuario.</li>
<li><strong>Árbol de sintaxis abstracta (AST)</strong>: es una representación simplificada de la estructura sintáctica del código fuente. A nivel de programación un AST es una estructura de datos que se genera durante el proceso de análisis sintáctico.</li>
</ul>
<h3 id="Lenguaje-de-entrada"><a href="#Lenguaje-de-entrada" class="headerlink" title="Lenguaje de entrada"></a><strong>Lenguaje de entrada</strong></h3><p>En la raíz del proyecto hay un archivo llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/entrada.txt">entrada.txt</a>, este contiene un ejemplo con las instrucciones que el lenguaje soporta.</p>
<h3 id="Listado-instrucciones-soportadas"><a href="#Listado-instrucciones-soportadas" class="headerlink" title="Listado instrucciones soportadas"></a><strong>Listado instrucciones soportadas</strong></h3><ul>
<li>Declaración de variables</li>
<li>Asignación de variables</li>
<li>Evaluación de expresiones aritméticas, lógicas y relaciones</li>
<li>If…elseif…else</li>
<li>While</li>
<li>Continue</li>
<li>Break</li>
<li>Return</li>
<li>Declaración de funciones</li>
<li>Llamadas a funciones</li>
<li>Recursividad</li>
<li>Funciones nativas: pie, toUpper. Pie genera una gráfica pie, y toUpper convierte a mayúsculas cierta cadena.</li>
<li>Comentarios de una línea y multilínea</li>
<li>Control de excepciones semánticas</li>
</ul>
<h3 id="Estructura-del-archivo-Gramatica-jj-de-JavaCC"><a href="#Estructura-del-archivo-Gramatica-jj-de-JavaCC" class="headerlink" title="Estructura del archivo Gramatica.jj de JavaCC"></a><strong>Estructura del archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/Analizador/Gramatica.jj">Gramatica.jj</a> de JavaCC</strong></h3><p>La extensión para los archivos JavaCC es .jj, a continuación vamos a describir la estructura del <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/Analizador/Gramatica.jj">archivo de JavaCC utilizado para este ejemplo</a>.</p>
<p><strong>Sección de opciones</strong><br>Aquí vamos a indicar que no haga distinción entre mayúsculas y minúsculas, además de indicar que los métodos de nuestro archivo luego de compilados <strong>no sean estáticos</strong>.</p>
<p><strong>Sección de parserBegin y parserEnd</strong><br>Aquí vamos a definir el nombre de nuestro paquete, adicionalmente y muy importante todos los import de archivos que vayamos a utilizar en las acciones para generar nuestro AST. Por último vamos a crear una clase vacía, esta es la que vamos a utilizar para invocar a nuestra gramática.</p>
<p><strong>Sección de análisis léxico</strong><br>En este punto vamos a definir todos los tokens que vamos a utilizar en el lenguaje:</p>
<ul>
<li><em>Sección skip</em><br>Contendrá todos los tokens que javacc va a ignorar cuando los reconozca, por ejemplo los comentarios o saltos de línea, espacios en blanco, etc.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SKIP : &#123;</span><br><span class="line">      <span class="string">&quot; &quot;</span></span><br><span class="line">    | <span class="string">&quot;\t&quot;</span></span><br><span class="line">    | <span class="string">&quot;\r&quot;</span></span><br><span class="line">    | <span class="string">&quot;\n&quot;</span></span><br><span class="line">    | &lt;<span class="string">&quot;//&quot;</span> (~[<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;\r&quot;</span>])*&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><em>Sección de token</em><br>En esta sección cada vez que se reconozca un lexema este generará un nuevo objeto de tipo token.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TOKEN : &#123;</span><br><span class="line">      &lt;NUMERO: ([<span class="string">&quot;0&quot;</span>-<span class="string">&quot;9&quot;</span>])+&gt;</span><br><span class="line">    | &lt;DECIMAL: ([<span class="string">&quot;0&quot;</span>-<span class="string">&quot;9&quot;</span>])+<span class="string">&quot;.&quot;</span>([<span class="string">&quot;0&quot;</span>-<span class="string">&quot;9&quot;</span>])+&gt;</span><br><span class="line">    | &lt;ENTERO: <span class="string">&quot;Numero&quot;</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><em>Sección more</em><br>Sección utilizada para la creación de estados.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MORE :</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;\&quot;&quot;</span> :STRING_STATE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;STRING_STATE&gt; MORE:</span><br><span class="line">&#123;</span><br><span class="line">    &lt;~[<span class="string">&quot;\&quot;&quot;</span>]&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Seccion-de-analisis-sintactico"><a href="#Seccion-de-analisis-sintactico" class="headerlink" title="Sección de análisis sintáctico"></a><strong>Sección de análisis sintáctico</strong></h3><p>Aquí vamos a definir la gramática y agregar las acciones correspondientes para generar nuestro AST. Ciertas producciones van a generar una clase que tiene cierta funcionalidad donde se indica lo que la ejecución deberá hacer. </p>
<p><em>Veamos el caso del while</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/** While -&gt; <span class="keyword">while</span>(condicion) instrucciones */</span><br><span class="line">AST Mientras() :</span><br><span class="line">&#123;AST e; ArrayList&lt;AST&gt; ins;&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &lt;MIENTRAS&gt; &lt;PARENI&gt; e=Expresion() &lt;PAREND&gt; ins=<span class="function"><span class="title">Bloque</span></span>() </span><br><span class="line">    &#123;<span class="built_in">return</span> new Mientras(e, ins, token.beginLine, token.beginColumn);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Con esta gramática observamos lo siguiente, tenemos dos variables:</p>
<ul>
<li>AST e</li>
<li>ArrayList<AST> ins</li>
</ul>
<p>AST es nuestra clase abstracta asociada con la variable e que contendrá la condición de nuestro while, y el arraylist contendrá una lista de estas clases, esto con el fin de tener una lista de instrucciones.<br>Como sabemos un while necesita de una condición y una lista de instrucciones, lo cual se cumple en el diseño planteado, por lo tanto vamos a retornar una instancia de la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/Instrucciones/Mientras.java">Mientras</a>.</p>
<p>Luego de retornar nuestra clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/Instrucciones/Mientras.java">Mientras</a>, el analizador se encarga de continuar la reducción nuestras producciones, y agregar esta clase a una lista de instrucciones ya que la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/Instrucciones/Mientras.java">Mientras</a> es una instrucción en sí misma.<br>Al finalizar el análisis de la entrada se debería generar un árbol, que básicamente contiene una lista de instrucciones, y estas instrucciones pueden ser mientras, imprimir, llamadas, etc.<br>Esta es la idea general detrás de las acciones del análisis sintáctico, retornar clases que van a formar un AST, que nos servirá para el análisis semántico y para la ejecución de nuestras instrucciones.</p>
<h3 id="Analisis-semantico-y-ejecucion-de-codigo"><a href="#Analisis-semantico-y-ejecucion-de-codigo" class="headerlink" title="Análisis semántico y ejecución de código"></a><strong>Análisis semántico y ejecución de código</strong></h3><p>Aquí nos vamos a encargar de verificar que lo que ejecutemos tenga sentido, vamos a retomar el ejemplo de la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/Instrucciones/Mientras.java">Mientras</a>, específicamente la sobre-escritura del método interpretar:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object interpretar(Tabla tabla, Arbol tree) &#123;</span><br><span class="line">    Object valorCondicion = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Tabla t = new Tabla(tabla);</span><br><span class="line">        valorCondicion = condicion.interpretar(t, tree);</span><br><span class="line">        <span class="keyword">if</span> (valorCondicion instanceof Excepcion) &#123;</span><br><span class="line">            <span class="built_in">return</span> valorCondicion;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(valorCondicion instanceof Boolean)) &#123;</span><br><span class="line">            Excepcion ex = new Excepcion(<span class="string">&quot;Semantico&quot;</span>, <span class="string">&quot;Se esperaba un valor booleano para la condicion&quot;</span>, fila, columna);</span><br><span class="line">            tree.getExcepciones().add(ex);</span><br><span class="line">            <span class="built_in">return</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = null;</span><br><span class="line">        <span class="keyword">if</span> ((Boolean) valorCondicion) &#123;</span><br><span class="line">            for (AST m : instrucciones) &#123;</span><br><span class="line">                result = m.interpretar(t, tree);</span><br><span class="line">                if (result instanceof Retorno || result instanceof Excepcion) &#123;</span><br><span class="line">                    return result;</span><br><span class="line">                &#125;</span><br><span class="line">                if(result instanceof Detener)&#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                if(result instanceof Continue)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((Boolean) valorCondicion);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Se sobre-escribe la función interpretar que viene desde nuestra clase abstracta <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/Abstract/AST.java">AST</a>, cada clase que herede de <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/Abstract/AST.java">AST</a> le dará un distinto comportamiento a este método en base a lo que se quiere realizar.</p>
<p>En este caso necesitamos darle el comportamiento de un while, haciendo lo siguiente:</p>
<ul>
<li>Declaramos una variable que almacenara nuestra condición</li>
<li>Iniciamos un ciclo doWhile con la condición establecida en la variable creada anteriormente</li>
<li>En las instrucciones del do, crearemos un nuevo ámbito para nuestro mientras</li>
<li>Obtenemos el valor de la condición y lo asignamos a la variable creada al inicio</li>
<li>Si el valor obtenido es una excepción vamos a retornar este valor para que sea reportado.</li>
<li>Si continua la ejecución vamos ahora a verificar que el valor obtenido sea de tipo booleano, sino fuera un booleano vamos a generar una nueva excepción y la vamos a retornar para que sea reportada.</li>
<li>Si la condición fuera valida vamos a tener un if con esta condición y si el valor fuera true inicia la ejecución de cada instrucción en nuestra lista</li>
<li>Si fuera false, simplemente ignora el if y nuestro doWhile termina</li>
<li>Dentro del for para recorrer las instrucciones nos encontramos que en cada iteración debemos verificar que lo que obtenemos de valor no sea una excepción ya que si lo fuera la debemos retornar para que sea reportada.</li>
<li>Además verificamos si fuera un break, continue o return para saber que hacer en cada caso.</li>
<li>Por ejemplo si fuera retorno vamos a devolver el valor como tal, si fuera un continue únicamente tenemos que ir a la siguiente iteración por lo que cortamos la iteración del ciclo interno donde estamos para que no se sigan ejecutando el resto de las instrucciones y si fuera un break debemos terminar la ejecución del mientras por lo tanto terminamos la ejecución de nuestro doWhile.<br>Esta sería la lógica para un ciclo while, y así lo haremos con todas las instrucciones, cada una tendrá una implementación distinta.</li>
</ul>
<h3 id="Clases-importantes-del-proyecto"><a href="#Clases-importantes-del-proyecto" class="headerlink" title="**Clases importantes del proyecto **"></a>**Clases importantes del proyecto **</h3><p>Estas clases son clave para el desarrollo de nuestro intérprete y se explicarán a continuación</p>
<ul>
<li><em><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/Abstract/AST.java">Clase abstracta AST</a></em><br>Contiene los atributos y métodos que tendrán las instrucciones en común, además el método interpretar que será sobre-escrito en cada implementación, la finalidad de esta clase es poder modelar clases de distintos tipos que comparten un comportamiento cómun que en este caso sería que se pueden interpretar.</li>
<li><em><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/TablaSimbolos/Simbolo.java">Clase símbolo</a></em><br>Esta clase nos sirve como nodo para crear nuestras variables, vemos que contiene tipo, identificador y valor, aunque esto puede variar dependiendo del tipo de interprete que estemos construyendo.</li>
<li><em><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/TablaSimbolos/Tabla.java">Clase tabla</a></em><br>Esta a tener la función de tabla de símbolos, aquí vamos a almacenar nuestras variables y funciones, nuestras variables las vamos a almacenar en un hashmap y las funciones en un arraylist. Contamos con métodos que nos ayudaran a obtener, guardar variables, obtener y guardar funciones.</li>
<li><em><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/TablaSimbolos/Arbol.java">Clase árbol</a></em><br>Es la clase que nos devuelve el análisis sintáctico contiene las instrucciones que deberán ser ejecutadas, la lista de excepción que vamos a reportar y la tabla global para cuando ejecutemos las llamadas a funciones.</li>
<li><em><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/TablaSimbolos/Tipo.java">Clase tipo</a></em><br>Aquí es donde vamos a definir los tipos que contendrá nuestro interprete.</li>
<li><em><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/Expresiones/Funcion.java">Clase función</a></em><br>Como cualquier otra instrucción, extiende de la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/Abstract/AST.java">AST</a>, y recibe una lista de parámetros y el nombre de la función y una lista de instrucciones.<br>Y para la ejecución únicamente necesitamos recorrer la lista de instrucciones ejecutando el método interpretar asociado a cada una de estas.</li>
</ul>
<h3 id="Creacion-de-funciones-nativas"><a href="#Creacion-de-funciones-nativas" class="headerlink" title="Creación de funciones nativas"></a><strong>Creación de funciones nativas</strong></h3><p>Para funciones nativas es muy sencillo, únicamente debemos extender de la clase función y modificar el comportamiento por cualquier otro que deseemos. Tomamos de ejemplo la función nativa <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/Nativas/aMayuscula.java">aMayuscula</a>, esta recibe en su constructor los mismos datos que la funciones y únicamente se va a diferenciar en el método interpretar donde le daremos una lógica distinta.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object interpretar(Tabla tabla, Arbol tree) &#123;</span><br><span class="line">    Simbolo simbolo = tabla.getVariable(<span class="string">&quot;toUpper%%parametro1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (simbolo == null) &#123;</span><br><span class="line">        Excepcion ex = new Excepcion(<span class="string">&quot;Semantico&quot;</span>, <span class="string">&quot;No se ha encontrado la variable &quot;</span> + this.nombre + <span class="string">&quot;.&quot;</span>, fila, columna);</span><br><span class="line">        tree.getExcepciones().add(ex);</span><br><span class="line">        <span class="built_in">return</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!simbolo.getTipo().equals(new Tipo(Tipo.Tipos.CADENA))) &#123;</span><br><span class="line">        Excepcion ex = new Excepcion(<span class="string">&quot;Semantico&quot;</span>, <span class="string">&quot;El tipo de los parametros no coinciden.&quot;</span>, fila, columna);</span><br><span class="line">        tree.getExcepciones().add(ex);</span><br><span class="line">        <span class="built_in">return</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> (simbolo.getValor() + <span class="string">&quot;&quot;</span>).toUpperCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ejecucion-de-la-entrada"><a href="#Ejecucion-de-la-entrada" class="headerlink" title="Ejecución de la entrada"></a><strong>Ejecución de la entrada</strong></h3><p>Para ejecutar la entrada debemos instanciar nuestra gramática, esto sucede en la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/interpretejavacc/UIController.java">UIController</a>, específicamente dentro del método Ejecutar:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Gramatica parser = new Gramatica(new BufferedReader(new StringReader(entrada.getText())));</span><br><span class="line">Arbol arbol = parser.Analizar();</span><br><span class="line">EjecutarInstrucciones(arbol);</span><br></pre></td></tr></table></figure>
<p>Como mencionamos el resultado de ejecutar nuestra gramática nos devolverá un objeto de tipo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/TablaSimbolos/Arbol.java">Arbol</a>, lo enviamos a un método para tratarlo.<br>En este método pasamos la consola de la interfaz a nuestro árbol para imprimir cosas, crear la tabla global y asignarla a nuestro árbol, crear las funciones nativas.<br>Luego recorremos por primera vez nuestras instrucciones en búsqueda de funciones para declararlas, pero solamente funciones no otra instrucción.<br>Luego recorremos por segunda vez nuestras instrucciones y las ejecutamos utilizando el siempre confiable método interpretar obtenido gracias a nuestra clase abstracta AST. Específicamente con el método EjecutarInstrucciones, de la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/interpretejavacc/UIController.java">UIController</a>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void EjecutarInstrucciones(Arbol tree) &#123;</span><br><span class="line">    tree.setConsola(consola);</span><br><span class="line">    tree.setGrupo(groupChart);</span><br><span class="line">    Tabla tabla = new Tabla(null);</span><br><span class="line">    tree.setGlobal(tabla);</span><br><span class="line">    crearNativas(tabla);</span><br><span class="line">    // Recorrido 1 para insertar funciones</span><br><span class="line">    tree.getInstrucciones().forEach(m -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (m instanceof Funcion) &#123;</span><br><span class="line">            tabla.setFuncion((Funcion) m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    tree.getInstrucciones().forEach(m -&gt; &#123;</span><br><span class="line">        if (!(m instanceof Funcion)) &#123;</span><br><span class="line">            Object result = m.interpretar(tabla, tree);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result instanceof Excepcion) &#123;</span><br><span class="line">                ((Excepcion) result).imprimir(tree.getConsola());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result instanceof Detener) &#123;</span><br><span class="line">                Excepcion ex = new Excepcion(<span class="string">&quot;Semantico&quot;</span>, <span class="string">&quot;Sentencia break fuera de ciclo.&quot;</span>, m.fila, m.columna);</span><br><span class="line">                tree.getExcepciones().add(ex);</span><br><span class="line">                ex.imprimir(tree.getConsola());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result instanceof Retorno) &#123;</span><br><span class="line">                Excepcion ex = new Excepcion(<span class="string">&quot;Semantico&quot;</span>, <span class="string">&quot;Sentencia retorno fuera de funcion.&quot;</span>, m.fila, m.columna);</span><br><span class="line">                tree.getExcepciones().add(ex);</span><br><span class="line">                ex.imprimir(tree.getConsola());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tree.getExcepciones().forEach(m -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span> + m.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Iniciando-funciones-nativas"><a href="#Iniciando-funciones-nativas" class="headerlink" title="Iniciando funciones nativas"></a><strong>Iniciando funciones nativas</strong></h3><p>Para las funciones nativas recordemos deben ser creadas antes de iniciar la ejecución de nuestro interprete. Esta creación de las funciones nativas se encuentra en clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJavaCC/blob/master/src/interpretejavacc/UIController.java">UIController</a>, específicamente en el método crearNativas:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void crearNativas(Tabla t)&#123;</span><br><span class="line">    Tipo tipo = new Tipo(Tipo.Tipos.CADENA);</span><br><span class="line">    String nombre = <span class="string">&quot;toUpper&quot;</span>;</span><br><span class="line">    ArrayList&lt;AST&gt; parametros = new ArrayList&lt;&gt;();</span><br><span class="line">    parametros.add(new Declaracion(tipo, <span class="string">&quot;toUpper%%parametro1&quot;</span>, null, -1, -1));</span><br><span class="line">    ArrayList&lt;AST&gt; instrucciones = new ArrayList&lt;&gt;();</span><br><span class="line">    aMayuscula am = new aMayuscula(tipo, nombre, parametros, instrucciones, -1, -1);</span><br><span class="line">    t.setFuncion(am);</span><br><span class="line">    </span><br><span class="line">    tipo = new Tipo(Tipo.Tipos.CADENA);</span><br><span class="line">    nombre = <span class="string">&quot;pie&quot;</span>;</span><br><span class="line">    parametros = new ArrayList&lt;&gt;();</span><br><span class="line">    parametros.add(new Declaracion(new Tipo(Tipos.LISTA), <span class="string">&quot;pie%%parametro1&quot;</span>, null, -1, -1));</span><br><span class="line">    parametros.add(new Declaracion(new Tipo(Tipos.LISTA), <span class="string">&quot;pie%%parametro2&quot;</span>, null, -1, -1));</span><br><span class="line">    parametros.add(new Declaracion(new Tipo(Tipos.CADENA), <span class="string">&quot;pie%%parametro3&quot;</span>, null, -1, -1));</span><br><span class="line">    instrucciones = new ArrayList&lt;&gt;();</span><br><span class="line">    pieChart pc = new pieChart(tipo, nombre, parametros, instrucciones, -1, -1);</span><br><span class="line">    t.setFuncion(pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Como observamos aquí creamos las funciones nativas de toUpper y pie que mencionamos al inicio. Además los parámetros tienen un nombre especial para que no se confundan con otras variables, al terminar de crearlas las agregamos a nuestra lista de funciones.</p>
<p>Una vez explicado esto procedemos a ejecutar nuestro programa, vemos que contamos con un boton para ejecutar y 2 pestañas, 1 de consola y la otra donde se muestran nuestras graficas:</p>


<p>Agregamos y ejecutamos la entrada proporcionada que produce lo siguiente en la sección de la consola:</p>


<p>Y en la sección de grafica:</p>


<p>Con esto damos por finalizado la explicación de este pequeño proyecto.</p>
<h4 id="Conclusiones"><a href="#Conclusiones" class="headerlink" title="Conclusiones"></a><strong>Conclusiones</strong></h4><ul>
<li>Como pudimos observar el desarrollo de un interprete es largo, pero a su vez es ordenado.</li>
<li>Las gramáticas en javaCC pueden ser poco legibles pero altamente sencillas de crear.</li>
<li><strong>Dry, don’t repeat yourself</strong>: si usamos esta filosofía podemos reducir la cantidad de código hecho, por ejemplo en nuestra clase abstracta agregamos código común para todas las clases que la heredan, o con las funciones nativas únicamente heredamos de algo que ya existía, hay que tratar en la manera de lo posible reutilizar el código existente. </li>
<li>Algo que no se explico porque no era parte del tutorial, pero que es muy útil fue que la interfaz esta hecha en JavaFX, esta nos proporciona una manera más sencilla de utilizar los componentes de la interfaz con nuestra lógica utilizando el modelo MVC.</li>
<li>La utilización de estados en JavaCC nos puede ayudar en casos donde necesitemos crear tokens más complejos.</li>
</ul>
<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/PvasquezF">Pavel Vásquez</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><ul>
<li>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-10T22:17:25.000Z" title="2/10/2020, 4:17:25 PM">2020-02-10</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/10/24-Mi-primer-proyecto-utilizando-PLY/">Mi primer proyecto utilizando PLY con Python 3</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presentando como salida el resultado de dichas expresiones.</p>
<p>Las tecnologías a utilizar son:</p>
<ul>
<li><strong>PLY</strong>: Generador de analizadores léxicos y sintácticos.</li>
<li><strong>Python 3</strong>: Es un lenguaje de programación interpretado de alto nivel.</li>
<li><strong>Visual Studio Code</strong>: Es un editor de código ligero pero poderoso. Existen complementos para trabajar con este lenguaje.</li>
</ul>
<p>El proyecto completo lo pueden descargar del siguiente enlace</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoPly">Mi primer proyecto utilizando PLY</a></li>
</ul>
<h3 id="PLY"><a href="#PLY" class="headerlink" title="PLY"></a><strong>PLY</strong></h3><p><a target="_blank" rel="noopener" href="https://www.dabeaz.com/ply/">PLY</a> es una implementación en Python de lex y yacc, herramientas populares para la construcción de compiladores.</p>
<p>La principal tarea de un analizador léxico es leer los caracteres de entrada del programa fuente, agruparlos en lexemas y producir como salida una secuencia de tokens.</p>
<ul>
<li>Un <em>token</em> es un par que consiste en un nombre de token y un valor de atributo opcional.</li>
<li>Un <em>lexema</em> es una secuencia de caracteres en el programa fuente, que coinciden con el patrón para un token y que el analizador léxico identifica como una instancia de este token.</li>
<li>Un <em>patrón</em> es una descripción de la forma que pueden tomar los lexemas de un token.</li>
</ul>
<p>El analizador sintáctico obtiene una cadena de tokens del analizador léxico y verifica que dicha cadena pueda generarse con la gramática para el lenguaje fuente. Una gramática proporciona una especificación precisa y fácil de entender de un lenguaje de programación.</p>
<p>En <a target="_blank" rel="noopener" href="https://www.dabeaz.com/ply/">PLY</a> se definen los patrones de los diferentes tokens que se desean reconocer, esto se hace a través de expresiones regulares. Mientras que las producciones y acciones para formar la gramática se definen a través de funciones.</p>
<h3 id="Pre-requisitos"><a href="#Pre-requisitos" class="headerlink" title="Pre-requisitos"></a><strong>Pre-requisitos</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.python.org/">Python 3</a></li>
<li><a target="_blank" rel="noopener" href="https://www.dabeaz.com/ply/">PLY</a></li>
</ul>
<h3 id="Instalamos-PLY"><a href="#Instalamos-PLY" class="headerlink" title="Instalamos PLY"></a><strong>Instalamos PLY</strong></h3><p>Para hacer uso de PLY en nuestro proyecto no hacemos instalación como tal, lo que necesitamos es descargar el archivo ply-3.11.tar.gz (versión 3.11 al momento de escribir este tutorial) de la página oficial de <a target="_blank" rel="noopener" href="https://www.dabeaz.com/ply/">PLY</a> y lo que hacemos es copiar el fólder “ply” a nuestro proyecto.</p>


<h3 id="Crear-nuestro-proyecto"><a href="#Crear-nuestro-proyecto" class="headerlink" title="Crear nuestro proyecto"></a><strong>Crear nuestro proyecto</strong></h3><p>Primero crearemos un nuevo fólder, en este caso lo llamaremos PROYECTOPLY. Luego lo abrimos en nuestro editor de texto, en este caso usaremos <a target="_blank" rel="noopener" href="https://code.visualstudio.com/">Visual Studio Code</a>. Finalmente procedemos a crear un nuevo archivo llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoPly/blob/master/gramatica.py">gramatica.py</a> donde escribiremos nuestro compilador.</p>


<p>Los directorios “<strong>pycache</strong>“, al igual que los archivos “parser.out” y “parsetab.py” son generados por Python los cuales pueden ser excluidos en nuestro controlador de versiones. En este caso, los agregamos a nuestro <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoPly/blob/master/.gitignore">.gitignore</a>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser.out</span><br><span class="line">parsetab.py</span><br><span class="line">**/__pycache__/**</span><br></pre></td></tr></table></figure>

<p>El directorio “ply” es el que descargamos y utilizaremos para construir nuestro compilador.</p>
<h3 id="Codigo-Fuente-para-el-analizador-lexico-y-sintactico"><a href="#Codigo-Fuente-para-el-analizador-lexico-y-sintactico" class="headerlink" title="Código Fuente para el analizador léxico y sintáctico"></a><strong>Código Fuente para el analizador léxico y sintáctico</strong></h3><p>En el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoPly/blob/master/gramatica.py">gramatica.py</a> tenemos la construcción de nuestro compilador.</p>
<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-lexico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-lexico" class="headerlink" title="Explicación del código fuente para el analizador léxico"></a><strong>Explicación del código fuente para el analizador léxico</strong></h3><p>Lo primero que debemos hacer es definir el listado de tokens que vamos a reconocer ya asignarlo a la variable tokens</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tokens  = (</span><br><span class="line">    <span class="string">&#x27;REVALUAR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PARIZQ&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PARDER&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;CORIZQ&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;CORDER&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MAS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;MENOS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;POR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;DIVIDIDO&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;DECIMAL&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ENTERO&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PTCOMA&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Luego escribimos los patrones para los tokens que definimos. Existen dos formas de definir las reglas de nuestros tokens.</p>
<p>La primera, es con expresiones regulares, agregamos el prefijo “t_” al token que queremos definir y luego le especificamos la expresión regular, para esto se hace uso del módulo <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/re.html">re</a> de Python.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tokens</span></span><br><span class="line">t_REVALUAR  = r<span class="string">&#x27;Evaluar&#x27;</span></span><br><span class="line">t_PARIZQ    = r<span class="string">&#x27;\(&#x27;</span></span><br><span class="line">t_PARDER    = r<span class="string">&#x27;\)&#x27;</span></span><br><span class="line">t_CORIZQ    = r<span class="string">&#x27;\[&#x27;</span></span><br><span class="line">t_CORDER    = r<span class="string">&#x27;\]&#x27;</span></span><br><span class="line">t_MAS       = r<span class="string">&#x27;\+&#x27;</span></span><br><span class="line">t_MENOS     = r<span class="string">&#x27;-&#x27;</span></span><br><span class="line">t_POR       = r<span class="string">&#x27;\*&#x27;</span></span><br><span class="line">t_DIVIDIDO  = r<span class="string">&#x27;/&#x27;</span></span><br><span class="line">t_PTCOMA    = r<span class="string">&#x27;;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>La otra forma es a través de funciones, esto nos sirve para manipular el valor del token que procesamos. Por ejemplo para los valores numéricos los retornamos con el tipo apropiado, hacer validaciones, etc.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def t_DECIMAL(t):</span><br><span class="line">    r<span class="string">&#x27;\d+\.\d+&#x27;</span></span><br><span class="line">    try:</span><br><span class="line">        t.value = <span class="built_in">float</span>(t.value)</span><br><span class="line">    except ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Floaat value too large %d&quot;</span>, t.value)</span><br><span class="line">        t.value = 0</span><br><span class="line">    <span class="built_in">return</span> t</span><br><span class="line"></span><br><span class="line">def t_ENTERO(t):</span><br><span class="line">    r<span class="string">&#x27;\d+&#x27;</span></span><br><span class="line">    try:</span><br><span class="line">        t.value = int(t.value)</span><br><span class="line">    except ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Integer value too large %d&quot;</span>, t.value)</span><br><span class="line">        t.value = 0</span><br><span class="line">    <span class="built_in">return</span> t</span><br></pre></td></tr></table></figure>

<p>Es importante definir también los caracteres que se van a ignorar.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Caracteres ignorados</span></span><br><span class="line">t_ignore = <span class="string">&quot; \t&quot;</span></span><br></pre></td></tr></table></figure>

<p>Las funciones también llevan el prefijo “t_” antes del nombre del token que queremos procesar. La función recibe un parámetro, “t” en nuestro ejemplo, este contiene el valor del token. Retornamos el valor ya procesado que deseamos, o no retornar nada si lo que deseamos es ignorar el token (por ejemplo: comentarios, contadores, etc.).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def t_newline(t):</span><br><span class="line">    r<span class="string">&#x27;\n+&#x27;</span></span><br><span class="line">    t.lexer.lineno += t.value.count(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line">def t_error(t):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Illegal character &#x27;%s&#x27;&quot;</span> % t.value[0])</span><br><span class="line">    t.lexer.skip(1)</span><br></pre></td></tr></table></figure>

<p>Finalmente construimos el analizador léxico haciendo uso de las librerías de PLY</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Construyendo el analizador léxico</span></span><br><span class="line">import ply.lex as lex</span><br><span class="line">lexer = lex.lex()</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-del-codigo-fuente-para-el-analizador-sintactico"><a href="#Explicacion-del-codigo-fuente-para-el-analizador-sintactico" class="headerlink" title="Explicación del código fuente para el analizador sintáctico"></a><strong>Explicación del código fuente para el analizador sintáctico</strong></h3><p>Otra de las ventajas de Python es que en el mismo archivo podemos definir nuestro análisis sintáctico haciendo uso de los tokens previamente definidos en la sección del analizador léxico.</p>
<p>Primeramente definimos la asociatividad y precedencia de los operadores, ya que la gramática escrita es ambigua, es necesario definir una precedencia para que el analizador no entre en conflicto al analizar, en este caso la precedencia es la misma que la de los operadores aritméticos, la precedencia más baja la tienen la suma y la resta, luego están la multiplicación y la división que tienen una precedencia más alta y por último está el signo menos de las expresiones negativas que tendría la precedencia más alta.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Asociación de operadores y precedencia</span></span><br><span class="line">precedence = (</span><br><span class="line">    (<span class="string">&#x27;left&#x27;</span>,<span class="string">&#x27;MAS&#x27;</span>,<span class="string">&#x27;MENOS&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;left&#x27;</span>,<span class="string">&#x27;POR&#x27;</span>,<span class="string">&#x27;DIVIDIDO&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;right&#x27;</span>,<span class="string">&#x27;UMENOS&#x27;</span>),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>Ahora procedemos a escribir nuestras producciones, aquí vemos otra de las ventajas de Python, las acciones semánticas de nuestras producciones se hacen en forma de funciones. Las características de estas funciones son:</p>
<ul>
<li>El nombre inicia con el prefijo “_p”. El complemento del nombre queda a nuestra discreción</li>
<li>Tiene un único parámetro “t” el cual es una tupla, en cada posición tiene el valor de los terminales y no terminales de la producción.</li>
<li>Haciendo uso del docstring de las funciones de Python especificamos las producciones que serán procesadas por la función.</li>
<li>En el cuerpo de la función definimos la funcionalidad que deseamos</li>
</ul>
<p>Por ejemplo:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def p_expresion_evaluar(t):</span><br><span class="line">     <span class="string">&#x27;expresion : expresion MAS expresion&#x27;</span></span><br><span class="line">     <span class="comment">#   ^            ^      ^    ^</span></span><br><span class="line">     <span class="comment">#  t[0]         t[1]   t[2] t[3]</span></span><br><span class="line"> </span><br><span class="line">     t[0] = t[1] + t[3]</span><br></pre></td></tr></table></figure>

<p>Sintetizamos en p[0] (expresion) el valor del resultado de sumar loo valores de p[1] (expresion) y p[3].</p>
<p>A continuación el código completo de nuestras producciones:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definición de la gramática</span></span><br><span class="line">def p_instrucciones_lista(t):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;instrucciones    : instruccion instrucciones</span></span><br><span class="line"><span class="string">                        | instruccion &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">def p_instrucciones_evaluar(t):</span><br><span class="line">    <span class="string">&#x27;instruccion : REVALUAR CORIZQ expresion CORDER PTCOMA&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;El valor de la expresión es: &#x27;</span> + str(t[3]))</span><br><span class="line"></span><br><span class="line">def p_expresion_binaria(t):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;expresion : expresion MAS expresion</span></span><br><span class="line"><span class="string">                  | expresion MENOS expresion</span></span><br><span class="line"><span class="string">                  | expresion POR expresion</span></span><br><span class="line"><span class="string">                  | expresion DIVIDIDO expresion&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> t[2] == <span class="string">&#x27;+&#x27;</span>  : t[0] = t[1] + t[3]</span><br><span class="line">    <span class="keyword">elif</span> t[2] == <span class="string">&#x27;-&#x27;</span>: t[0] = t[1] - t[3]</span><br><span class="line">    <span class="keyword">elif</span> t[2] == <span class="string">&#x27;*&#x27;</span>: t[0] = t[1] * t[3]</span><br><span class="line">    <span class="keyword">elif</span> t[2] == <span class="string">&#x27;/&#x27;</span>: t[0] = t[1] / t[3]</span><br><span class="line"></span><br><span class="line">def p_expresion_unaria(t):</span><br><span class="line">    <span class="string">&#x27;expresion : MENOS expresion %prec UMENOS&#x27;</span></span><br><span class="line">    t[0] = -t[2]</span><br><span class="line"></span><br><span class="line">def p_expresion_agrupacion(t):</span><br><span class="line">    <span class="string">&#x27;expresion : PARIZQ expresion PARDER&#x27;</span></span><br><span class="line">    t[0] = t[2]</span><br><span class="line"></span><br><span class="line">def p_expresion_number(t):</span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;expresion    : ENTERO</span></span><br><span class="line"><span class="string">                    | DECIMAL&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    t[0] = t[1]</span><br><span class="line"></span><br><span class="line">def p_error(t):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error sintáctico en &#x27;%s&#x27;&quot;</span> % t.value)</span><br></pre></td></tr></table></figure>

<p>Por último, podemos manejar también las producciones de error para el manejo de errores sintácticos.</p>
<p>Ahora construimos el analizador sintáctico,la funcionalidad para leer el archivo y enviarle su contenido a nuestro compilador.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import ply.yacc as yacc</span><br><span class="line">parser = yacc.yacc()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">&quot;./entrada.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">input = f.read()</span><br><span class="line"><span class="built_in">print</span>(input)</span><br><span class="line">parser.parse(input)</span><br></pre></td></tr></table></figure>

<h3 id="Creando-un-archivo-de-entrada-para-nuestro-analizador"><a href="#Creando-un-archivo-de-entrada-para-nuestro-analizador" class="headerlink" title="Creando un archivo de entrada para nuestro analizador"></a><strong>Creando un archivo de entrada para nuestro analizador</strong></h3><p>Creamos un nuevo archivo de texto utilizando nuestro editor llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoPly/blob/master/entrada.txt">entrada.txt</a>. El contenido de este archivo es el siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1+1];</span><br><span class="line">Evaluar[1+1*2];</span><br><span class="line">Evaluar[-(1+1*6/3-5+7)];</span><br><span class="line">Evaluar[-(1+1*6/3-5+1*-2)];</span><br><span class="line">Evaluar[-(1.6+1.45)];</span><br></pre></td></tr></table></figure>

<p>Ejecución</p>
<p>Para ejecutar este script corremos el siguiente comando:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  python3 .\gramatica.py</span><br></pre></td></tr></table></figure>

<p>Como podemos ver, obtenemos la salida esperada.</p>



<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/rjanixz">Rainman Sián</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-02-10T22:14:34.000Z" title="2/10/2020, 4:14:34 PM">2020-02-10</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/10/23-Mi-primer-proyecto-utilizando-JavaCC/">Mi primer proyecto utilizando JavaCC</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presenta como salida el resultado de dichas expresiones.</p>
<p>Las tecnologías para utilizar son:</p>
<ul>
<li><strong>JavaCC</strong>: Generador de analizadores léxicos y sintácticos.</li>
<li><strong>Windows 10</strong>: Sistema operativo.</li>
<li><strong>Netbeans 8.2</strong>: IDE (entorno de desarrollo integrado)</li>
<li><strong>Java 8</strong>: Lenguaje de programación.</li>
</ul>
<p>El proyecto completo del ejemplo puede descargarse del siguiente enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC">Mi primer proyecto utilizando JavaCC</a></li>
</ul>
<h3 id="JavaCC"><a href="#JavaCC" class="headerlink" title="JavaCC"></a><strong>JavaCC</strong></h3><p><a target="_blank" rel="noopener" href="https://javacc.github.io/javacc/">Java Compiler Compiler</a> es un generador de analizadores para utilizar en java. Este generador es una herramienta que lee la especificación gramatical y la convierte en un programa de java que puede reconocer coincidencias con la gramática. Además del generador de analizadores en sí, JavaCC proporciona otras capacidades estándar relacionadas con la generación de analizadores, como la construcción de árboles (a través de una herramienta llamada JJTree incluida con JavaCC), acciones y depuración. Todo lo que se necesita para ejecutar un analizador JavaCC, una vez generado, es Java Runtime Environment (JRE).</p>
<h3 id="Caracteristicas"><a href="#Caracteristicas" class="headerlink" title="Características"></a><strong>Características</strong></h3><ul>
<li>JavaCC utiliza un analizador descendente lo que permite el uso de gramáticas más generales.</li>
<li>Por defecto JavaCC genera un analizador LL(1), aunque JavaCC ofrece capacidades de anticipación sintáctica para resolver ambigüedades.</li>
<li>JavaCC permite la utilización de BNF Extendido, o lo que vendría siendo utilizar expresiones regulares tanto en la parte léxica como gramatical.</li>
<li>JavaCC permite la utilización de estados para manejar de mejor forma las expresiones regulares.</li>
<li>Para más información visitar la página oficial de <a target="_blank" rel="noopener" href="https://javacc.github.io/javacc/">JavaCC</a>.</li>
</ul>
<h3 id="Prerrequisitos"><a href="#Prerrequisitos" class="headerlink" title="Prerrequisitos"></a><strong>Prerrequisitos</strong></h3><p>Para este este ejemplo necesitamos las siguientes herramientas</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/downloads/index.html">Java Development Kit (JDK)</a></li>
<li><a target="_blank" rel="noopener" href="https://netbeans.apache.org/download/index.html">NetBeans</a> (o cualquier IDE de nuestro agrado)</li>
<li><a target="_blank" rel="noopener" href="https://javacc.github.io/javacc/">JavaCC</a></li>
</ul>
<h3 id="Agregar-jdk-a-las-variables-de-entorno"><a href="#Agregar-jdk-a-las-variables-de-entorno" class="headerlink" title="Agregar jdk a las variables de entorno"></a><strong>Agregar jdk a las variables de entorno</strong></h3><p>Debemos asegurarnos de que la carpeta bin del JDK haya sido agregada a nuestra variable de entorno Path, para ello vamos a la configuración de dicha variable de entorno </p>
<ul>
<li>Clic derecho en Este equipo </li>
<li>Propiedades</li>
</ul>


<ul>
<li>Configuración avanzada del sistema </li>
<li>Variables de entorno </li>
<li>Variable Path </li>
<li>Editar</li>
</ul>


<p>y si no existe agregamos la ruta a la carpeta bin del JDK, que en mi caso es: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_211\bin</span><br></pre></td></tr></table></figure>

<h3 id="Descarga-e-instalacion-de-JavaCC"><a href="#Descarga-e-instalacion-de-JavaCC" class="headerlink" title="Descarga e instalación de JavaCC"></a><strong>Descarga e instalación de JavaCC</strong></h3><p>Nos dirigimos a la <a target="_blank" rel="noopener" href="https://javacc.github.io/javacc/">página oficial de JavaCC</a>, al ingresar hacemos clic sobre el botón de Download[Version].zip    </p>


<p>Una vez descargado el archivo, lo extraemos y podremos ver el siguiente contenido:</p>


<p>El archivo que nos interesa es javacc.jar que se encuentra en la carpeta bootstrap:</p>


<p>Por conveniencia, vamos a trasladar el archivo .jar a la carpeta C:&#x2F;javacc, sin embargo, podría guardarse en otra ubicación.</p>

<p>Más adelante le daremos uso a nuestro archivo javacc.jar.</p>
<h3 id="Crear-el-proyecto-utilizando-NetBeans"><a href="#Crear-el-proyecto-utilizando-NetBeans" class="headerlink" title="Crear el proyecto utilizando NetBeans"></a><strong>Crear el proyecto utilizando NetBeans</strong></h3><p>Como mencionamos vamos a utilizar NetBeans, sin embargo podría usarse cualquier otro IDE. Vamos a mostrar la creación del proyecto y su estructura.</p>
<ul>
<li>Seleccionamos la opción de nuevo proyecto.</li>
<li>Ahora seleccionamos el tipo de proyecto, en este caso Java Application y damos clic en siguiente.</li>
</ul>


<ul>
<li>Por último, agregamos el nombre del proyecto y finalizamos.</li>
</ul>


<ul>
<li>Vemos el resultado de la creación del proyecto.</li>
</ul>


<ul>
<li>A continuación, creamos un nuevo paquete llamado Analizador, produciendo el siguiente resultado.</li>
</ul>


<ul>
<li><p>Dentro de este paquete vamos a crear un nuevo archivo llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/Gramatica.jj">Gramatica.jj</a>, este archivo contendrá la gramática para reconocer el lenguaje que vamos a realizar.</p>
</li>
<li><p>Para facilitar la compilación de la gramática vamos a crear un archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/compilarGramatica.bat">compilarGramatica.bat</a>, con el siguiente contenido, siempre en el paquete Analizador.</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> C:\javacc\javacc.jar javacc Gramatica.jj</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>Lo que indican estas sentencias:</p>
<ul>
<li>Agregar el archivo jar al classpath mediante el argumento -cp (classpath) – -cp C:\javacc\javacc.jar (o la ubicación de nuestro archivo javacc.jar)</li>
<li>Ejecutar java – java</li>
<li>Pasar el main del archivo jar – javacc</li>
<li>Pasar la gramática a compilar – Gramatica.jj</li>
<li>Evitar que se cierre la ventana de comando para ver el resultado – pause</li>
<li><em>Nota</em>: utilizamos el argumento classpath para indicarle a java donde debe buscar los paquetes y clases a ejecutar, mas información en el siguiente <a target="_blank" rel="noopener" href="https://howtodoinjava.com/java/basics/java-classpath/">link</a>.</li>
</ul>
<h3 id="Construccion-del-lenguaje-en-JavaCC"><a href="#Construccion-del-lenguaje-en-JavaCC" class="headerlink" title="Construcción del lenguaje en JavaCC"></a><strong>Construcción del lenguaje en JavaCC</strong></h3><p>Luego de esta introducción vamos a construir una programa que reconozca un lenguaje compuesto por una lista de instrucciones <strong>Evaluar</strong> que reciben una expresión aritmética para ser evaluada, por ejemplo:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Evaluar [3*4-2*9]</span><br></pre></td></tr></table></figure>

<h3 id="Explicacion-de-la-estructura-del-archivo-Gramatica-jj"><a href="#Explicacion-de-la-estructura-del-archivo-Gramatica-jj" class="headerlink" title="Explicación de la estructura del archivo Gramatica.jj"></a><strong>Explicación de la estructura del archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/Gramatica.jj">Gramatica.jj</a></strong></h3><ul>
<li><p><strong>Sección de opciones</strong>: Esta sección es opcional, el área de opciones permite especificar algunas directrices que ayuden a JavaCC a generar analizadores léxico-sintácticos más eficientes y adaptados a las necesidades concretas del desarrollador. Existen muchas, si quieres conocerlas mejor puedes verificar la página 132 del libro <a target="_blank" rel="noopener" href="http://www.lcc.uma.es/~galvez/ftp/libros/Compiladores.pdf">Compiladores, de Sergio Gálvez Rojas Y Miguel Ángel Mora Mata</a>. En este caso particular utilizamos solamente dos:</p>
<ul>
<li><strong>Ignore_Case</strong> &#x3D; true, para no hacer distinción entre mayúsculas y minúsculas.</li>
<li><strong>Static</strong> &#x3D; false, para que los métodos que genere la compilación no sean estáticos.</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">IGNORE_CASE = <span class="literal">true</span>;</span><br><span class="line">STATIC = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Clausulas PARSER_BEGIN – PARSER_END</strong>: Sirven para indicarle a JavaCC el nombre de nuestra clase principal, así como para englobar tanto a esta como a cualquier otra que se quiera incluir de apoyo. En este ejemplo no definimos ningun método main, solo una clase llamada gramática para nuestro parser, por supuesto que esta clase gramática es la que debemos utilizar para invocar a nuestro parser, y el main lo incluimos fuera de este para tener un código más claro.</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PARSER_BEGIN(Gramatica)</span><br><span class="line">/** Analizador de expresiones aritmeticas sencillas. */</span><br><span class="line">package Analizador; </span><br><span class="line">public class Gramatica &#123;</span><br><span class="line">&#125;</span><br><span class="line">PARSER_END(Gramatica)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Sección para definición léxica</strong>: Esta sección contendrá los tokens permitidos por nuestro lenguaje, contiene distintas clausulas, pero las que utilizamos son:</p>
<ul>
<li><strong>Token</strong>: Constituyen los tokens que nuestro analizador va a reconocer, generalmente aquí se incluyen todos los terminales de nuestro lenguaje, aunque también se pueden utilizar tokens en la definición sintáctica sin haberlos definido en esta sección.</li>
<li><strong>Skip</strong>: En esta sección se incluyen los tokens que se van a ignorar durante el análisis, por ejemplo, los espacios o saltos de línea.</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/** Lexico */</span><br><span class="line">SKIP : &#123;</span><br><span class="line">	<span class="string">&quot; &quot;</span></span><br><span class="line">	| <span class="string">&quot;\t&quot;</span></span><br><span class="line">	| <span class="string">&quot;\r&quot;</span></span><br><span class="line">	| <span class="string">&quot;\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TOKEN : &#123;</span><br><span class="line">	&lt;NUMERO: ([<span class="string">&quot;0&quot;</span>-<span class="string">&quot;9&quot;</span>])+&gt;</span><br><span class="line">	| &lt;DECIMAL: ([<span class="string">&quot;0&quot;</span>-<span class="string">&quot;9&quot;</span>])+<span class="string">&quot;.&quot;</span>([<span class="string">&quot;0&quot;</span>-<span class="string">&quot;9&quot;</span>])+&gt;</span><br><span class="line">	| &lt;EVALUAR: <span class="string">&quot;Evaluar&quot;</span>&gt;</span><br><span class="line">	| &lt;PCOMA: <span class="string">&quot;;&quot;</span>&gt;</span><br><span class="line">	| &lt;PARENI: <span class="string">&quot;(&quot;</span>&gt;</span><br><span class="line">	| &lt;PAREND: <span class="string">&quot;)&quot;</span>&gt;</span><br><span class="line">	| &lt;CORI: <span class="string">&quot;[&quot;</span>&gt;</span><br><span class="line">	| &lt;CORD: <span class="string">&quot;]&quot;</span>&gt;</span><br><span class="line">	| &lt;MAS: <span class="string">&quot;+&quot;</span>&gt;</span><br><span class="line">	| &lt;MENOS: <span class="string">&quot;-&quot;</span>&gt;</span><br><span class="line">	| &lt;POR: <span class="string">&quot;*&quot;</span>&gt;</span><br><span class="line">	| &lt;DIV: <span class="string">&quot;/&quot;</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line">/** Fin Lexico */</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Sección para definición sintáctica</strong>: Aquí vamos a definir las producciones para nuestro analizador, estas están definidas como funciones. A continuación explicamos la estructura:</p>
<ul>
<li>Como buena práctica es recomendable agregar en un comentario la producción en formato BNF para que sea más fácil entender la producción actual, ya que las reglas sintácticas en JavaCC pueden ser un poco confusas. </li>
<li>La definición de un método incluye:</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TIPO&gt; &lt;NOMBRE&gt; () : </span><br><span class="line">&#123;Sección para código de java, generalmente para declaraciones&#125;</span><br><span class="line">&#123;Producciones, estas pueden incluir notación de expresiones regulares&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Si quisiéramos invocar a otra producción, agregamos su llamada a método y para obtener su valor lo hacemos de la siguiente manera</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/** Instruccion -&gt; evaluar [ Expresion ]; */</span><br><span class="line">void Instruccion() :</span><br><span class="line">&#123;double e;&#125;</span><br><span class="line">&#123;</span><br><span class="line">&lt;EVALUAR&gt; &lt;CORI&gt; e=Expresion() &lt;CORD&gt; &lt;PCOMA&gt; &#123;System.out.println(<span class="string">&quot;El valor de la expresion es: &quot;</span>+e);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>En tal caso necesitásemos obtener el valor de un terminal, debemos utilizar el atributo image, ya que cada terminal es un objeto de tipo Token, para obtenerlo hacemos lo siguiente</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">double Primitivo() :</span><br><span class="line">&#123;double e;&#125;</span><br><span class="line">&#123;</span><br><span class="line">	&lt;NUMERO&gt; &#123;<span class="built_in">return</span> Double.parseDouble(token.image);&#125;</span><br><span class="line">	|</span><br><span class="line">	&lt;DECIMAL&gt; &#123;<span class="built_in">return</span> Double.parseDouble(token.image);&#125;</span><br><span class="line">	|</span><br><span class="line">	&lt;PARENI&gt; e=Expresion() &lt;PAREND&gt; &#123;<span class="built_in">return</span> e;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Algo a tomar en cuenta es que, podemos declarar variables de tipo Token y asignarlas al terminal, esto es por si tuviéramos varios terminales en una misma producción y así sepamos diferenciar cada uno.</li>
</ul>
</li>
</ul>
<h3 id="Compilacion-de-la-gramatica"><a href="#Compilacion-de-la-gramatica" class="headerlink" title="Compilación de la gramática"></a><strong>Compilación de la gramática</strong></h3><p>Una vez finalizado nuestro archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/Gramatica.jj">Gramatica.jj</a>, vamos a compilar este para generar los archivos necesarios para su ejecución, vamos a utilizar el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/compilarGramatica.bat">compilarGramatica.bat</a> creado al inicio. Al ejecutar el archivo veremos lo siguiente:</p>


<p>Como resultado de esto, en nuestro paquete analizador se crearon los siguientes archivos</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/Gramatica.java">Gramatica.java</a></strong>: Este archivo contiene las funciones de cada no terminal de la sección sintáctica </li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/GramaticaConstants.java">GramaticaConstanst.java</a></strong>: Esta interfaz contiene las constantes de tipo entero que identifican a cada token de nuestro lenguaje y son asignadas a las variables kind.</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/GramaticaTokenManager.java">GramaticaTokenManager.java</a></strong>: Se encarga de reconocer los tokens durante el análisis léxico.</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/ParseException.java">ParseException.java</a></strong>: Se utiliza para lanzar los errores durante el análisis sintáctico.</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/TokenMgrError.java">TokenMgrError.java</a></strong>: Se encarga de manejar los errores léxicos.</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/Analizador/Token.java">Token.java</a></strong>: Representa cada token definido en nuestra sección léxica.</li>
</ul>
<h3 id="Clase-Principal"><a href="#Clase-Principal" class="headerlink" title="Clase Principal"></a><strong>Clase Principal</strong></h3><p>Por último, vamos a invocar a nuestro parser en el <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/src/proyectojavacc/ProyectoJavaCC.java">método main</a>, para utilizar nuestro parser basta con crear la clase Gramatica y pasar por parámetro nuestro archivo de entrada, luego de crear la instancia invocamos al método inicial que en nuestro caso sería el método analizar.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package proyectojavacc;</span><br><span class="line"></span><br><span class="line">import Analizador.Gramatica;</span><br><span class="line">import Analizador.ParseException;</span><br><span class="line">import Analizador.TokenMgrError;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.util.logging.Level;</span><br><span class="line">import java.util.logging.Logger;</span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @author Pavel</span><br><span class="line"> */</span><br><span class="line">public class ProyectoJavaCC &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param args the <span class="built_in">command</span> line arguments</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Gramatica parser = new Gramatica(new BufferedReader(new FileReader(<span class="string">&quot;./entrada.txt&quot;</span>)));</span><br><span class="line">            parser.Analizar();</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            Logger.getLogger(ProyectoJavaCC.class.getName()).<span class="built_in">log</span>(Level.SEVERE, <span class="string">&quot;Error al intentar leer el archivo.&quot;</span>, e);</span><br><span class="line">        &#125; catch(TokenMgrError e)&#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ejecucion-del-archivo-de-entrada"><a href="#Ejecucion-del-archivo-de-entrada" class="headerlink" title="Ejecución del archivo de entrada"></a><strong>Ejecución del archivo de entrada</strong></h3><p>El <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoJavaCC/blob/master/entrada.txt">archivo</a> que vamos a utilizar debe encontrarse dentro de la carpeta de nuestro proyecto.</p>
<p>Y su contenido es el siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1+1];</span><br><span class="line">Evaluar[1+1*2];</span><br><span class="line">Evaluar[-(1+1*6/3-5+7)];</span><br><span class="line">Evaluar[-(1+1*6/3-5+1*-2)];</span><br><span class="line">Evaluar[-(1+1)];</span><br></pre></td></tr></table></figure>

<p>Ejecutamos nuestro programa y vemos la siguiente salida:</p>



<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/PvasquezF">Pavel Vásquez</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas"></a><strong>Fuentes consultadas</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.lcc.uma.es/~galvez/ftp/libros/Compiladores.pdf">Java a tope: Compiladores</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/javacc/javacc">JavaCC: Repositorio</a></li>
<li><a target="_blank" rel="noopener" href="https://www.javadoc.io/doc/net.java.dev.javacc/javacc">JavaCC: Documentación</a></li>
<li><a target="_blank" rel="noopener" href="https://howtodoinjava.com/java/basics/java-classpath/">Java: Classpath</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-08-07T21:01:14.000Z" title="8/7/2019, 3:01:14 PM">2019-08-07</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/07/22-Interprete-sencillo-utilizando-Irony-con-CS/">Intérprete sencillo utilizando Irony y C#</a></p><div class="content"><p>En este tutorial se desarrolla un intérprete sencillo que permite ejecutar un archivo de entrada que contiene sentencias tales como declaración de variables, sentencias de control, impresiones en consola, etc. El lenguaje de programación fue diseñado especialmente para este ejemplo. El proyecto cuenta con comentarios que explican su funcionamiento.</p>
<p>Las tecnologías a utilizar son:</p>
<ul>
<li><strong>Irony</strong>: Generador de analizadores léxicos y sintácticos que retorna un AST (Abstract Syntax Tree).</li>
<li><strong>Visual Studio 2017</strong>: Entorno de desarrollo integrado utilizado para programar en C#.</li>
<li><strong>Windows 10</strong>: Sistema Operativo.</li>
<li><strong>Irony.dll</strong>: DLL que permite la integración de Irony con C#.</li>
</ul>
<p>El proyecto completo de este ejemplo puede descargarse del siguiente enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloIronyCS">Intérprete Sencillo Utilizando Irony</a></li>
</ul>
<p>Si desean una pequeña introducción a Irony pueden revisar el post:</p>
<ul>
<li><a href="/2019/07/24/19-Mi-primer-proyecto-utilizando-Irony-Windows/" title="Mi primer proyecto utilizando Irony">Mi primer proyecto utilizando Irony</a></li>
</ul>
<p>En el que se explica paso a paso como utilizar esta herramienta.</p>
<h3 id="El-lenguaje-de-entrada"><a href="#El-lenguaje-de-entrada" class="headerlink" title="El lenguaje de entrada"></a><strong>El lenguaje de entrada</strong></h3><p>Dentro de la <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloIronyCS/tree/master/InterpreteSencillo/InterpreteSencillo">carpeta del proyecto</a> podremos acceder a <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloIronyCS/tree/master/InterpreteSencillo/InterpreteSencillo/input">&#x2F;input</a> y allí encontraremos un archivo de entrada llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloIronyCS/blob/master/InterpreteSencillo/InterpreteSencillo/input/entrada.txt">“entrada.txt”</a>, en él se muestran ejemplos de todas las funciones del lenguaje diseñado para esta aplicación, al leerlo se puede tener una idea clara de las funciones con las que el lenguaje cuenta, este archivo contiene lo siguiente:</p>
<ul>
<li>   Comentarios simples, es decir de una sola línea (&#x2F;&#x2F;)</li>
<li>   Comentarios múltiples, es decir de más de una línea (&#x2F;* *&#x2F;)</li>
<li>   Concatenación de cadenas, mediante el operador <em>&amp;</em></li>
<li>   Función Imprimir: Recibe como parámetro una cadena e imprime su valor en consola.</li>
<li>   Declaración de variables: Únicamente se acepta definición de variables de tipo <em>numero</em> incluyendo enteros y decimales.</li>
<li>   Asignación de variables: A cualquier variable se le puede asignar cualquier expresión que tenga como resultado un número.</li>
<li>   Instrucción Mientras: Tiene el comportamiento clásico del ciclo while, ejecuta el ciclo mientras la expresión booleana que recibe sea verdadera. Esta instrucción soporta anidamiento. </li>
<li>   Instrucción If e If-Else: Tiene el comportamiento clásico de las sentencias de selección If e If-Else, evalúa la expresión booleana y ejecuta el bloque de instrucciones en If si es verdadera. En caso contrario y si existe un bloque Else se ejecuta este bloque de instrucciones. Estas instrucciones también soportan anidamiento.</li>
<li>   Expresiones aritméticas: Se soportan las expresiones aritméticas binarias: suma, resta, multiplicación y división. También la expresión unaria: negación. Adicionalmente se soporta expresiones agrupadas en paréntesis. Se maneja la precedencia habitual de las expresiones aritméticas.</li>
<li>   Expresiones booleanas: Comparan dos expresiones que tengan como resultado un número y soportan unicamente los operados <em>mayor que</em> y <em>menor que</em> (&lt;, &gt;).</li>
</ul>
<p><strong>El resultado de la ejecución</strong><br>Al ejecutar la entrada mostrada en nuestro ejemplo, esta fue la salida obtenida:</p>


<h3 id="Tabla-de-simbolos"><a href="#Tabla-de-simbolos" class="headerlink" title="Tabla de símbolos"></a><strong>Tabla de símbolos</strong></h3><p>La <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloIronyCS/blob/master/InterpreteSencillo/InterpreteSencillo/arbol/TablaDeSimbolos.cs">tabla de símbolos</a> es una parte importante en el proceso de ejecución del código, es en esta estructura de datos en donde guardamos información de las variables como su tipo, identificador y valor. En esta estructura podemos agregar variables, modificar los valores de las variables existentes, así como obtener sus valores.</p>
<h3 id="Entornos"><a href="#Entornos" class="headerlink" title="Entornos"></a><strong>Entornos</strong></h3><p>El manejo de entornos es sumamente importante ya que deberíamos de crear un nuevo entorno por cada alcance, de manera que los entornos superiores no tengan acceso a las variables declaradas en entornos inferiores pero los entornos inferiores puedan acceder tanto a sus variables como a las de los entornos superiores, esto funciona de manera muy similar a una pila, ya que el ultimo entorno creado debería ser el primero en ser eliminado.</p>
<p>En este ejemplo, esto se logra mediante el creando una tabla local para cada sentencia ejecutada que posea un ámbito propio, como el If, While, etc. Luego de crear la tabla local se agregan todos los símbolos de la tabla del ámbioto padre y se utiliza esta tabla local como tabla principal, al terminar de ejecutar la sentencia esta tabla local desaparece, pues fue declarada dentro de la sentencia que se ejecuta.</p>
<h3 id="Arbol-de-analisis-abstracto-AST"><a href="#Arbol-de-analisis-abstracto-AST" class="headerlink" title="Árbol de análisis abstracto AST"></a><strong>Árbol de análisis abstracto AST</strong></h3><p>Un árbol de sintaxis abstracta (AST) es una representación simplificada de la estructura sintáctica del código fuente. A nivel de programación un AST es una estructura de datos que se genera durante el proceso de análisis sintáctico.<br>En el código de Irony lo vamos armando por medio de listas de instrucciones, donde cada sentencia es una instrucción y en el bloque contenido en esta sentencia tendríamos otra lista de instrucciones, armando así un árbol en donde cada nodo es un objeto que implementa la interfaz instrucción y puede contener múltiples hijos que serían otros objetos que implementan la interfaz instrucción, que serían otras instrucciones.</p>
<p>El código de nuestro proyecto está organizado en dos paquetes:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloIronyCS/tree/master/InterpreteSencillo/InterpreteSencillo/analizador">analizador</a>: que contiene los archivos de Irony.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloIronyCS/tree/master/InterpreteSencillo/InterpreteSencillo/arbol">arbol</a>: que contiene todas las clases que forman parte del AST, que se utiliza como estructura primaria en la aplicación.</li>
</ul>
<p>Teniendo únicamente una clase afuera que seria la clase principal de la aplicación <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloIronyCS/blob/master/InterpreteSencillo/InterpreteSencillo/Program.cs">Program.cs</a>.</p>
<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/201504481">Julio Arango</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><ul>
<li>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-08-07T14:15:54.000Z" title="8/7/2019, 8:15:54 AM">2019-08-07</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/07/21-Interprete-sencillo-utilizando-GOLD-Parser-y-Visual-Basic/">Intérprete sencillo utilizando Gold Parser y Visual Basic</a></p><div class="content"><p>En los cursos de compiladores de la universidad, es común que se solicite al estudiante desarrollar un intérprete, una herramienta que reciba como entrada cierto lenguaje de programación y lo ejecute, pero la mayoría de documentación al respecto solo muestra ejemplos de cosas sencillas, como una calculadora o un lenguaje que imprime cadenas en consola. Qué pasa si lo que deseamos es que se ejecuten sentencias de control como el IF o ciclos como la sentencia WHILE y que además estas sentencias soporten muchos niveles de anidamiento, que se declaren variables y se asigne valores a estas variables, que se tenga control de los ámbitos de las variables, en fin, que tenga las funciones básicas de un lenguaje de programación. No es común encontrar este tipo de ejemplos, en lo personal, puedo asegurar que nunca encontré un tutorial en el que se mostrara un ejemplo documentado y bien explicado sobre esto. Por ello es que se elaboró este ejemplo, espero que les sea útil.</p>
<h3 id="Funcionamiento-de-la-aplicacion"><a href="#Funcionamiento-de-la-aplicacion" class="headerlink" title="Funcionamiento de la aplicación"></a><strong>Funcionamiento de la aplicación</strong></h3><p>En este tutorial se desarrolla un intérprete sencillo que permite ejecutar un archivo de entrada que contiene sentencias tales como declaraciones de variables, sentencias de control, impresiones en consola, etc. El lenguaje de programación fue diseñado especialmente para esta aplicación, primero se hace análisis léxico y sintáctico de dicha entrada asistidos por Gold Parser. Una vez Gold Parser genera el árbol de análisis sintáctico, recorreremos dicho árbol para crear nuestro propio árbol. Todo el código se encuentra comentado, por lo que podremos entender la función específica de cada nodo del árbol.</p>
<p>La versión original de este tutorial, realizada con JLex y Cup puede consultarse en el siguiente enlace:</p>
<ul>
<li><a href="/2019/04/26/05-Interprete-sencillo-utilizando-Java-Jlex-y-Cup/" title="Intérprete sencillo utilizando Java, Jlex y Cup">Intérprete sencillo utilizando Java, Jlex y Cup</a></li>
</ul>
<p>El proyecto completo de este ejemplo puede descargarse del siguiente enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB">Intérprete Sencillo Utilizando Gold Parser</a></li>
</ul>
<h3 id="Diseno-utilizado-para-el-desarrollo-de-este-ejemplo"><a href="#Diseno-utilizado-para-el-desarrollo-de-este-ejemplo" class="headerlink" title="Diseño utilizado para el desarrollo de este ejemplo"></a><strong>Diseño utilizado para el desarrollo de este ejemplo</strong></h3><p>Para este ejemplo se crea un objeto por cada una de las sentencias que reconoce nuestra gramática, cada objeto implementa la interfaz instruccion que representa un nodo en nuestro árbol. Esto nos permite tratar todas las sentencias como nodos y asignarle acciones específicas a cada uno según su tipo. Se puede entender nuestra gramática de la siguiente forma:</p>

<h3 id="El-lenguaje-de-entrada"><a href="#El-lenguaje-de-entrada" class="headerlink" title="El lenguaje de entrada"></a><strong>El lenguaje de entrada</strong></h3><p>Dentro de la <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/tree/master/InterpreteSencillo/InterpreteSencillo">carpeta del proyecto</a> podremos acceder a <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/tree/master/InterpreteSencillo/InterpreteSencillo/bin/Debug">&#x2F;bin&#x2F;Debug</a> y allí encontraremos un archivo de entrada llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/blob/master/InterpreteSencillo/InterpreteSencillo/bin/Debug/entrada.txt">“entrada.txt”</a>, en él se muestran ejemplos de todas las funciones del lenguaje diseñado para esta aplicación, al leerlo se puede tener una idea clara de las funciones con las que el lenguaje cuenta, este archivo contiene lo siguiente:</p>
<ul>
<li>   Comentarios simples, es decir de una sola línea (&#x2F;&#x2F;)</li>
<li>   Comentarios múltiples, es decir de más de una línea (&#x2F;* *&#x2F;)</li>
<li>   Concatenación de cadenas, mediante el operador <em>&amp;</em></li>
<li>   Función Imprimir: Recibe como parámetro una cadena e imprime su valor en consola.</li>
<li>   Declaración de variables: Únicamente se acepta definición de variables de tipo <em>numero</em> incluyendo enteros y decimales.</li>
<li>   Asignación de variables: A cualquier variable se le puede asignar cualquier expresión que tenga como resultado un número.</li>
<li>   Instrucción Mientras: Tiene el comportamiento clásico del ciclo while, ejecuta el ciclo mientras la expresión booleana que recibe sea verdadera. Esta instrucción soporta anidamiento. </li>
<li>   Instrucción If e If-Else: Tiene el comportamiento clásico de las sentencias de selección If e If-Else, evalúa la expresión booleana y ejecuta el bloque de instrucciones en If si es verdadera. En caso contrario y si existe un bloque Else se ejecuta este bloque de instrucciones. Estas instrucciones también soportan anidamiento.</li>
<li>   Expresiones aritméticas: Se soportan las expresiones aritméticas binarias: suma, resta, multiplicación y división. También la expresión unaria: negación. Adicionalmente se soporta expresiones agrupadas en paréntesis. Se maneja la precedencia habitual de las expresiones aritméticas.</li>
<li>   Expresiones booleanas: Comparan dos expresiones que tengan como resultado un número y soportan unicamente los operados <em>mayor que</em> y <em>menor que</em> (&lt;, &gt;).</li>
</ul>
<p>La gramatica utilizada para este ejemplo puede encontrarse en la carpeta <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/tree/master/InterpreteSencillo/InterpreteSencillo/Gramatica"><em>Gramatica</em></a>, en el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/blob/master/InterpreteSencillo/InterpreteSencillo/Gramatica/Gramatica.grm"><em>Gramatica.grm</em></a>. Gold Parser permite la definición de expresiones regulares con las que podremos definir algunos tokens del programa, tales como:</p>


<ul>
<li>   <em>Entero</em> acepta todos los numero que no poseen punto decimal</li>
<li>   <em>Decimal</em> acepta todo tipo de números decimales</li>
<li>   <em>Car</em> Acepta todos los caracteres imprimibles que pueden venir dentro de una cadena con la excepción de las comillas dobles</li>
<li>   <em>Cadena</em> Acepta un conjunto de caracteres delimitados por comillas dobles</li>
<li>   <em>ID Head</em> Acepta todas las letras del alfabeto además del guien bajo, se utiliza para la primera letra de los identificadores.</li>
<li>   <em>ID Tail</em> Acepta Todos los caracteres alfanuméricos además del guion bajo, se utiliza para todos los caracteres del identificador con la excepción de la primera letra</li>
<li>   <em>ID</em> Agrupa <em>ID Head</em> e <em>ID Tail</em> para poder conformar un identificador valido para nuestro lenguaje</li>
</ul>
<p>De igual manera, Gold Parser posee palabras reservadas para definir los comentarios, por lo que no tendremos que escribir una expresión regular personalizada.</p>


<h3 id="El-resultado-de-la-ejecucion"><a href="#El-resultado-de-la-ejecucion" class="headerlink" title="El resultado de la ejecución"></a><strong>El resultado de la ejecución</strong></h3><p>Al ejecutar la entrada mostrada en nuestro ejemplo, esta fue la salida obtenida:</p>


<h3 id="Sobre-la-tabla-de-simbolos"><a href="#Sobre-la-tabla-de-simbolos" class="headerlink" title="Sobre la tabla de símbolos"></a><strong>Sobre la tabla de símbolos</strong></h3><p>La <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/blob/master/InterpreteSencillo/InterpreteSencillo/Arbol/TablaSimbolos.vb">tabla de símbolos</a> es una parte importante en el proceso de ejecución del código, es en esta estructura de datos en donde guardamos información de las variables como su tipo, identificador y valor. En esta estructura podemos agregar variables, modificar los valores de las variables existentes, así como obtener sus valores. Otra alternativa más detallada es utilizar entornos, un ejemplo de esto se puede encontrar en el libro del curso (Ver Referencias) en la página 87, en donde se habla sobre tablas de símbolos por alcance, a través de entornos anidados.<br>El manejo de entornos es sumamente importante ya que deberíamos de crear un nuevo entorno por cada alcance, de manera que los entornos superiores no tengan acceso a las variables declaradas en entornos inferiores pero los entornos inferiores puedan acceder tanto a sus variables como a las de los entornos superiores, esto funciona de manera muy similar a una pila, ya que el ultimo entorno creado debería ser el primero en ser eliminado.<br>En este ejemplo, esto se logra mediante el método AddAll de la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/blob/master/InterpreteSencillo/InterpreteSencillo/Arbol/TablaSimbolos.vb">TablaSimbolos.vb</a>, que agrega todos los símbolos del entorno anterior al final del nuevo entorno.</p>


<h3 id="La-magia-detras-de-todo-esto-Arbol-de-sintaxis-abstracta-AST"><a href="#La-magia-detras-de-todo-esto-Arbol-de-sintaxis-abstracta-AST" class="headerlink" title="La magia detrás de todo esto: Árbol de sintaxis abstracta (AST)"></a><strong>La magia detrás de todo esto: Árbol de sintaxis abstracta (AST)</strong></h3><p>Un árbol de sintaxis abstracta (AST) es una representación simplificada de la estructura sintáctica del código fuente. A nivel de programación un AST es una estructura de datos que se genera durante el proceso de análisis sintáctico.<br>Gold Parser nos genera un árbol de análisis sintáctico, sin embargo, es mucho más práctico generar el nuestro que nos permita poder ejecutar las acciones al mismo tiempo que visitamos los nodos. Si creamos nuestro <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/blob/master/InterpreteSencillo/InterpreteSencillo/Arbol/AST.vb">propio árbol</a> tendremos completo control sobre nuestra gramática, tendremos código más entendible, reportes de errores más detallados y menos dolores de cabeza al tratar de encontrar un error.<br>Como se observa en el código fuente, las únicas acciones que realizamos en el <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/blob/master/InterpreteSencillo/InterpreteSencillo/Analisis/SkeletonProgram.vb">árbol de Gold Parser</a> es retornar nodos que nos permitan generar nuestro árbol. En la producción inicial debemos crear nuestro AST, que funcionara como raíz desde la cual debemos comenzar la ejecución de nuestro programa.</p>


<p>En este ejemplo el AST es la pieza más importante, porque al recorrerlo pueden ejecutarse las acciones del código de entrada y ese es el principal objetivo de la aplicación. Esta se conforma únicamente de dos paquetes:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/tree/master/InterpreteSencillo/InterpreteSencillo/Analisis"><em>Análisis</em></a>: Este paquete únicamente contiene la clase SkeletonProgram, que es el que nos genera Gold Parser por defecto y sobre el archivo que crearemos nuestro AST.</li>
</ul>


<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/tree/master/InterpreteSencillo/InterpreteSencillo/Arbol"><em>Árbol</em></a>:  Posee todas las clases necesarias que nos permiten crear nuestro AST, así como la interfaz operación que es la que permite tratar a todos los nodos del árbol como uno mismo.</li>
</ul>


<p>Además, es importante destacar que existe un archivo más que se encuentra en la <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/tree/master/InterpreteSencillo/InterpreteSencillo">carpeta raíz</a> de nuestro programa, es la clase principal que visual nos crea por defecto y en este caso se denomina <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloGoldParserVB/blob/master/InterpreteSencillo/InterpreteSencillo/Module1.vb">Module1.Vb</a>. Desde este archivo comienza toda la ejecución del programa y es desde donde debemos de configurar nuestro parser con el método setup (método por defecto de Gold Parser) y también donde deberemos de mandar a ejecutar las acciones de nuestro árbol con el método ejecutar una vez que estemos seguros que la entrada fue aceptada.</p>


<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/luisferliza">Luis Lizama</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><ul>
<li>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</li>
<li><a target="_blank" rel="noopener" href="http://www.goldparser.org/doc/index.htm">Documentación de Gold Parser</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-08-01T20:19:35.000Z" title="8/1/2019, 2:19:35 PM">2019-08-01</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/01/20-Interprete-sencillo-utilizando-Jison-con-Nodejs-Ubuntu/">Intérprete sencillo utilizando Jison con Nodejs (Ubuntu)</a></p><div class="content"><h3 id="Funcionamiento-de-la-aplicacion"><a href="#Funcionamiento-de-la-aplicacion" class="headerlink" title="Funcionamiento de la aplicación"></a><strong>Funcionamiento de la aplicación</strong></h3><p>En este tutorial se desarrolla un intérprete que recibe como entrada un archivo de texto que contiene varias sentencias de un lenguaje de programación diseñado especialmente para esta aplicación. Primero se hace análisis léxico y sintáctico de dicha entrada, durante el análisis sintáctico se carga en memoria un Árbol de Sintaxis Abstracta (AST) que se utiliza posteriormente para ejecutar las sentencias. El analizador se genera con Jison utilizando Nodejs en Ubuntu 18.04. El proyecto completo puede descargarse del siguiente enlace:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJisonJS">Intérprete sencillo utilizando Jison con Nodejs (Ubuntu)</a></p>
<p>Todo el código del proyecto está documentado con comentarios que contienen los detalles de su funcionamiento.</p>
<p>Si se desea una introducción sobre el uso de Jison con Nodejs pueden visitar el post: <a href="/2019/07/21/17-Mi-primer-proyecto-utilizando-Jison-Linux/" title="Mi primer proyecto utilizando Jison (Linux)">Mi primer proyecto utilizando Jison (Linux)</a> en el cual se describe los pre-requisitos y cómo crear un proyecto utilizando npm.</p>
<h3 id="El-lenguaje-de-entrada"><a href="#El-lenguaje-de-entrada" class="headerlink" title="El lenguaje de entrada"></a><strong>El lenguaje de entrada</strong></h3><p>Dentro de la carpeta del proyecto, hay un archivo de entrada llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJisonJS/blob/master/entrada.txt">entrada.txt</a> en el cual se muestran ejemplos de todas las funciones del lenguaje diseñado para esta aplicación, al leerlo se puede tener una idea clara de las funciones con las que el lenguaje cuenta, este archivo contiene lo siguiente:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************</span></span><br><span class="line"><span class="comment"> * Ejemplo desarrollado por Erick Navarro *</span></span><br><span class="line"><span class="comment"> * GitHub Page: ericknavarro.github.io    *</span></span><br><span class="line"><span class="comment"> * Septiembre - 2015                      *</span></span><br><span class="line"><span class="comment"> ******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Se imprime el encabezado</span></span><br><span class="line"><span class="title function_">imprimir</span>(<span class="string">&quot;Tablas de&quot;</span> &amp; <span class="string">&quot; multiplicar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Se declara la variable a, de tipo numero</span></span><br><span class="line">numero a;</span><br><span class="line"><span class="comment">//Se asigna a la variable a el valor 0</span></span><br><span class="line">a=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//Se declara la variable c, de tipo numero</span></span><br><span class="line">numero c;</span><br><span class="line"><span class="comment">//Se asigna a la variable c el valor 0</span></span><br><span class="line">c=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//Se imprime un separador</span></span><br><span class="line"><span class="title function_">imprimir</span>(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Se imprimen las tablas del 1 al 5 y </span></span><br><span class="line"><span class="comment"> * para cada tabla, se imprimen los resultados</span></span><br><span class="line"><span class="comment"> * desde el uno hasta el 5, esto se hace con </span></span><br><span class="line"><span class="comment"> * dos ciclos while anidados. </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="title function_">mientras</span>(<span class="params">a&lt;<span class="number">4</span>+c</span>)&#123;	</span><br><span class="line">	a=a+<span class="number">1</span>;</span><br><span class="line">	numero b;</span><br><span class="line">	b=<span class="number">0</span>;</span><br><span class="line">	<span class="title function_">mientras</span>(<span class="params">b&lt;<span class="number">4</span>+c</span>)&#123;</span><br><span class="line">		b=b+<span class="number">1</span>;</span><br><span class="line">		<span class="title function_">imprimir</span>(a &amp; <span class="string">&quot; * &quot;</span> &amp; b &amp; <span class="string">&quot; = &quot;</span> &amp; a * b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">imprimir</span>(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Se asigna a la variable a el valor de 11</span></span><br><span class="line">a=<span class="number">11</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * La variable b ya había sido declarada pero </span></span><br><span class="line"><span class="comment"> * dentro del ámbito del primer ciclo while, </span></span><br><span class="line"><span class="comment"> * entonces no existe en este ámbito por lo que </span></span><br><span class="line"><span class="comment"> * debe declararse.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">numero b;</span><br><span class="line"><span class="comment">//Se asigna valor de 12 a b y valor de 13 a c</span></span><br><span class="line">b=<span class="number">12</span>;</span><br><span class="line">c=<span class="number">13</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Se evalua si el valor de la variable a es </span></span><br><span class="line"><span class="comment"> * mayor que 10, si el b es mayor que 11 y si</span></span><br><span class="line"><span class="comment"> * el de c es mayor que 12. </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="title class_">If</span>(a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">	<span class="title function_">imprimir</span>(<span class="string">&quot;a es mayor que 10.&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(b&gt;<span class="number">11</span>)&#123;</span><br><span class="line">		<span class="title function_">imprimir</span>(<span class="string">&quot;a es mayor que 10 y b es mayor que 11.&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(c&gt;<span class="number">12</span>)&#123;</span><br><span class="line">			<span class="title function_">imprimir</span>(<span class="string">&quot;a es mayor que 10, b es mayor que 11 y c es mayor que 12.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="title function_">imprimir</span>(<span class="string">&quot;a es menor o igual que 10.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Como se puede observar, el lenguaje acepta:</p>
<ul>
<li>   Comentarios simples, es decir de una sola línea (&#x2F;&#x2F;)</li>
<li>   Comentarios múltiples, es decir de más de una línea (&#x2F;* *&#x2F;)</li>
<li>   Concatenación de cadenas, mediante el operador <em>&amp;</em></li>
<li>   Función Imprimir: Recibe como parámetro una cadena e imprime su valor en consola.</li>
<li>   Declaración de variables: Únicamente se acepta definición de variables de tipo <em>numero</em> incluyendo enteros y decimales.</li>
<li>   Asignación de variables: A cualquier variable se le puede asignar cualquier expresión que tenga como resultado un número.</li>
<li>   Instrucción Mientras: Tiene el comportamiento clásico del ciclo while, ejecuta el ciclo mientras la expresión booleana que recibe sea verdadera. Esta instrucción soporta anidamiento. </li>
<li>   Instrucción If e If-Else: Tiene el comportamiento clásico de las sentencias de selección If e If-Else, evalúa la expresión booleana y ejecuta el bloque de instrucciones en If si es verdadera. En caso contrario y si existe un bloque Else se ejecuta este bloque de instrucciones. Estas instrucciones también soportan anidamiento.</li>
<li>   Expresiones aritméticas: Se soportan las expresiones aritméticas binarias: suma, resta, multiplicación y división. También la expresión unaria: negación. Adicionalmente se soporta expresiones agrupadas en paréntesis. Se maneja la precedencia habitual de las expresiones aritméticas.</li>
<li>   Expresiones booleanas: Comparan dos expresiones que tengan como resultado un número y soportan unicamente los operados <em>mayor que</em> y <em>menor que</em> (&lt;, &gt;).</li>
</ul>
<p><em><strong>El analizador léxico y sintáctico</strong></em></p>
<p>En el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJisonJS/blob/master/gramatica.jison">gramatica.jison</a> detallamos la estructura del lenguaje utilizando Jison. A continuación detallaremos los aspectos más relevantes.</p>
<ul>
<li><em><strong>Sobre el analizador léxico</strong></em></li>
</ul>
<p>El analizador léxico define los patrones para los tokens que deseamos reconocer. Hacemos uso de expresiones regulares para identificar números, cadenas y comentarios.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\<span class="string">&quot;[^\&quot;]*\&quot;              &#123; yytext = yytext.substr(1,yyleng-2); return &#x27;CADENA&#x27;; &#125;</span></span><br><span class="line"><span class="string">[0-9]+(&quot;</span>.<span class="string">&quot;[0-9]+)?\b    return &#x27;DECIMAL&#x27;;</span></span><br><span class="line"><span class="string">[0-9]+\b                return &#x27;ENTERO&#x27;;</span></span><br><span class="line"><span class="string">([a-zA-Z])[a-zA-Z0-9_]* return &#x27;IDENTIFICADOR&#x27;;</span></span><br></pre></td></tr></table></figure>

<p>Nótese que los comentarios son tratados de la misma manera que los espacios en blanco, no retornamos ningún valor.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\s+                                 <span class="comment">// se ignoran espacios en blanco</span></span><br><span class="line"><span class="string">&quot;//&quot;</span>.*                              <span class="comment">// comentario simple línea</span></span><br><span class="line">[<span class="regexp">/][*][^*]*[*]+([^/*][^*]*[*]+)*[/] /</span>/ comentario multiple líneas</span><br></pre></td></tr></table></figure>

<ul>
<li><em><strong>Sobre el analizador sintáctico</strong></em></li>
</ul>
<p>El objetivo principal de nuestro analizador sintáctico es validar que la entrada sea válida y, si lo es, construir el AST (Abstract Syntax Tree). Para lograr esto hacemos uso de funciones utilitarias definidas en un API externa. Esta API contiene toda la lógica necesaria para crear el AST, la idea es centralizar toda esta funcionalidad en un solo lugar, evitando redundancia de funcionalidad y así evitar cometer errores.</p>
<p>Esto también es posible gracias a <a target="_blank" rel="noopener" href="https://nodejs.org/es/">Nodejs</a> ya que nos permite incluir esta funcionalidad en nuestro script para generar nuestro parser. </p>
<p><em><strong>La API de Instrucciones</strong></em></p>
<p>Una de las ventajas de usar <a target="_blank" rel="noopener" href="https://nodejs.org/es/">Nodejs</a> con <a target="_blank" rel="noopener" href="https://zaa.ch/jison/">Jison</a> es que podemos exportar porciones de scripts de un archivo hacia otro. Para nuestra API definimos constantes y funciones que nos ayudan durante la construcción del AST. Nuestra API se encuentra en el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJisonJS/blob/master/instrucciones.js">instrucciones.js</a>.</p>
<p>El uso de constantes es altamente recomendado, a través de estos podemos evitar bugs durante el desarrollo. Para este tutorial definimos constantes para los tipos de valores que soporta nuestro lenguaje: números, cadenas e identificadores. También definimos constantes para los tipos de operaciones soportadas y las instrucciones válidas.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constantes para los tipos de &#x27;valores&#x27; que reconoce nuestra gramática.</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TIPO_VALOR</span> = &#123;</span><br><span class="line">	<span class="attr">NUMERO</span>:        <span class="string">&#x27;VAL_NUMERO&#x27;</span>,</span><br><span class="line">	<span class="attr">IDENTIFICADOR</span>: <span class="string">&#x27;VAL_IDENTIFICADOR&#x27;</span>,</span><br><span class="line">	<span class="attr">CADENA</span>:        <span class="string">&#x27;VAL_CADENA&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constantes para los tipos de &#x27;operaciones&#x27; que soporta nuestra gramática.</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TIPO_OPERACION</span> = &#123;</span><br><span class="line">	<span class="attr">SUMA</span>:           <span class="string">&#x27;OP_SUMA&#x27;</span>,</span><br><span class="line">	<span class="attr">RESTA</span>:          <span class="string">&#x27;OP_RESTA&#x27;</span>,</span><br><span class="line">	<span class="attr">MULTIPLICACION</span>: <span class="string">&#x27;OP_MULTIPLICACION&#x27;</span>,</span><br><span class="line">	<span class="attr">DIVISION</span>:       <span class="string">&#x27;OP_DIVISION&#x27;</span>,</span><br><span class="line">	<span class="attr">NEGATIVO</span>:       <span class="string">&#x27;OP_NEGATIVO&#x27;</span>,</span><br><span class="line">	<span class="attr">MAYOR_QUE</span>:      <span class="string">&#x27;OP_MAYOR_QUE&#x27;</span>,</span><br><span class="line">	<span class="attr">MENOR_QUE</span>:      <span class="string">&#x27;OP_MENOR_QUE&#x27;</span>,</span><br><span class="line">	<span class="attr">CONCATENACION</span>:  <span class="string">&#x27;OP_CONCATENACION&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constantes para los tipos de &#x27;instrucciones&#x27; válidas en nuestra gramática.</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TIPO_INSTRUCCION</span> = &#123;</span><br><span class="line">	<span class="attr">IMPRIMIR</span>:    <span class="string">&#x27;INSTR_IMPRIMIR&#x27;</span>,</span><br><span class="line">	<span class="attr">MIENTRAS</span>:    <span class="string">&#x27;INSTR_MIENTRAS&#x27;</span>,</span><br><span class="line">	<span class="attr">DECLARACION</span>: <span class="string">&#x27;INSTR_DECLARACION&#x27;</span>,</span><br><span class="line">	<span class="attr">ASIGNACION</span>:  <span class="string">&#x27;INSTR_ASIGANCION&#x27;</span>,</span><br><span class="line">	<span class="attr">IF</span>:          <span class="string">&#x27;INSTR_IF&#x27;</span>,</span><br><span class="line">	<span class="attr">IF_ELSE</span>:     <span class="string">&#x27;INSTR_ELSE&#x27;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Seguidamente, tenemos la definición de una función llamada <em>nuevaOperacion</em>. Nótese que esta función está fuera de nuestra API, es decir no es <em>pública</em>, es para uso interno. Esta función crea objetos genéricos para las operaciones.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Esta función se encarga de crear objetos tipo Operación.</span></span><br><span class="line"><span class="comment"> * Recibe como parámetros el operando izquierdo y el operando derecho.</span></span><br><span class="line"><span class="comment"> * También recibe como parámetro el tipo del operador</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; operandoIzq </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; operandoDer </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; tipo </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nuevaOperacion</span>(<span class="params">operandoIzq, operandoDer, tipo</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">operandoIzq</span>: operandoIzq,</span><br><span class="line">		<span class="attr">operandoDer</span>: operandoDer,</span><br><span class="line">		<span class="attr">tipo</span>: tipo</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>La definición de funciones con tareas genéricas también es recomendable para evitar errores.</p>
<p>Finalmente, está la definición de nuestra API. En nuestra API tenemos tres tipos de funciones:</p>
<ul>
<li>Funciones para Operaciones.</li>
<li>Funciones para Valores </li>
<li>Funciones para Instrucciones.</li>
</ul>
<p>Cada una de estas funciones representa un Nodo en el AST. Las funciones para operaciones hacen uso de nuestra función privada, de esta forma logramos que nuestros objetos de tipo <em>Operación</em> tengan la misma estructura.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * El objetivo de esta API es proveer las funciones necesarias para la construcción de operaciones e instrucciones.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> instruccionesAPI = &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Crea un nuevo objeto tipo Operación para las operaciones binarias válidas.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; operandoIzq </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; operandoDer </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; tipo </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="attr">nuevoOperacionBinaria</span>: <span class="keyword">function</span>(<span class="params">operandoIzq, operandoDer, tipo</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">nuevaOperacion</span>(operandoIzq, operandoDer, tipo);</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Crea un nuevo objeto tipo Operación para las operaciones unarias válidas</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; operando </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; tipo </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="attr">nuevoOperacionUnaria</span>: <span class="keyword">function</span>(<span class="params">operando, tipo</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">nuevaOperacion</span>(operando, <span class="literal">undefined</span>, tipo);</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Crea un nuevo objeto tipo Valor, esto puede ser una cadena, un número o un identificador</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; valor </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; tipo </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="attr">nuevoValor</span>: <span class="keyword">function</span>(<span class="params">valor, tipo</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">tipo</span>: tipo,</span><br><span class="line">			<span class="attr">valor</span>: valor</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Crea un objeto tipo Instrucción para la sentencia Imprimir.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; expresionCadena </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="attr">nuevoImprimir</span>: <span class="keyword">function</span>(<span class="params">expresionCadena</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">tipo</span>: <span class="variable constant_">TIPO_INSTRUCCION</span>.<span class="property">IMPRIMIR</span>,</span><br><span class="line">			<span class="attr">expresionCadena</span>: expresionCadena</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Crea un objeto tipo Instrucción para la sentencia Mientras.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; expresionLogica </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; instrucciones </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="attr">nuevoMientras</span>: <span class="keyword">function</span>(<span class="params">expresionLogica, instrucciones</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">tipo</span>: <span class="variable constant_">TIPO_INSTRUCCION</span>.<span class="property">MIENTRAS</span>,</span><br><span class="line">			<span class="attr">expresionLogica</span>: expresionLogica,</span><br><span class="line">			<span class="attr">instrucciones</span>: instrucciones</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Crea un objeto tipo Instrucción para la sentencia Declaración.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; identificador </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="attr">nuevoDeclaracion</span>: <span class="keyword">function</span>(<span class="params">identificador</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">tipo</span>: <span class="variable constant_">TIPO_INSTRUCCION</span>.<span class="property">DECLARACION</span>,</span><br><span class="line">			<span class="attr">identificador</span>: identificador</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Crea un objeto tipo Instrucción para la sentencia Asignación.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; identificador </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; expresionNumerica </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="attr">nuevoAsignacion</span>: <span class="keyword">function</span>(<span class="params">identificador, expresionNumerica</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">tipo</span>: <span class="variable constant_">TIPO_INSTRUCCION</span>.<span class="property">ASIGNACION</span>,</span><br><span class="line">			<span class="attr">identificador</span>: identificador,</span><br><span class="line">			<span class="attr">expresionNumerica</span>: expresionNumerica</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Crea un objeto tipo Instrucción para la sentencia If.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; expresionLogica </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; instrucciones </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="attr">nuevoIf</span>: <span class="keyword">function</span>(<span class="params">expresionLogica, instrucciones</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">tipo</span>: <span class="variable constant_">TIPO_INSTRUCCION</span>.<span class="property">IF</span>,</span><br><span class="line">			<span class="attr">expresionLogica</span>: expresionLogica,</span><br><span class="line">			<span class="attr">instrucciones</span>: instrucciones</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Crea un objeto tipo Instrucción para la sentencia If-Else.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; expresionLogica </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; instruccionesIfVerdadero </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; instruccionesIfFalso </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="attr">nuevoIfElse</span>: <span class="keyword">function</span>(<span class="params">expresionLogica, instruccionesIfVerdadero, instruccionesIfFalso</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">tipo</span>: <span class="variable constant_">TIPO_INSTRUCCION</span>.<span class="property">IF_ELSE</span>,</span><br><span class="line">			<span class="attr">expresionLogica</span>: expresionLogica,</span><br><span class="line">			<span class="attr">instruccionesIfVerdadero</span>: instruccionesIfVerdadero,</span><br><span class="line">			<span class="attr">instruccionesIfFalso</span>: instruccionesIfFalso</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Para poder utilizar las constantes y el API fuera de este archivo utilizamos la instrucción “module.exports” con el cual exportamos todo lo que deseamos que sea público</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exportamos nuestras constantes y nuestra API</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">TIPO_OPERACION</span> = <span class="variable constant_">TIPO_OPERACION</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">TIPO_INSTRUCCION</span> = <span class="variable constant_">TIPO_INSTRUCCION</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">TIPO_VALOR</span> = <span class="variable constant_">TIPO_VALOR</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">instruccionesAPI</span> = instruccionesAPI;</span><br></pre></td></tr></table></figure>

<p><em><strong>Construcción del AST</strong></em></p>
<p>Para construir el AST durante nuestro análisis sintáctico importamos nuestra API y las constantes. Esto lo hacemos dentro de los símbolos “%{“ y “}%” en el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJisonJS/blob/master/gramatica.jison">gramatica.jison</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="variable constant_">TIPO_OPERACION</span>	= <span class="built_in">require</span>(<span class="string">&#x27;./instrucciones&#x27;</span>).<span class="property">TIPO_OPERACION</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="variable constant_">TIPO_VALOR</span> 		= <span class="built_in">require</span>(<span class="string">&#x27;./instrucciones&#x27;</span>).<span class="property">TIPO_VALOR</span>;</span><br><span class="line">	<span class="keyword">const</span> instruccionesAPI	= <span class="built_in">require</span>(<span class="string">&#x27;./instrucciones&#x27;</span>).<span class="property">instruccionesAPI</span>;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<p>Una vez importemos nuestras constantes y funciones ya podemos hacer uso de ellas en la gramática. Por ejemplo, para la construcción de operaciones aritméticas hacemos uso de la función nuevoOperacionBinaria de nuestra API de Instrucciones, pasamos como parámetros los operandos y el tipo operación (utilizando nuestras constantes).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expresion_numerica</span><br><span class="line">   : <span class="variable constant_">MENOS</span> expresion_numerica %prec <span class="variable constant_">UMENOS</span>          &#123; $$ = instruccionesAPI.<span class="title function_">nuevoOperacionUnaria</span>($2, <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">NEGATIVO</span>); &#125;</span><br><span class="line">   | expresion_numerica <span class="variable constant_">MAS</span> expresion_numerica      &#123; $$ = instruccionesAPI.<span class="title function_">nuevoOperacionBinaria</span>($1, $3, <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">SUMA</span>); &#125;</span><br><span class="line">   | expresion_numerica <span class="variable constant_">MENOS</span> expresion_numerica    &#123; $$ = instruccionesAPI.<span class="title function_">nuevoOperacionBinaria</span>($1, $3, <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">RESTA</span>); &#125;</span><br><span class="line">   | expresion_numerica <span class="variable constant_">POR</span> expresion_numerica      &#123; $$ = instruccionesAPI.<span class="title function_">nuevoOperacionBinaria</span>($1, $3, <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">MULTIPLICACION</span>); &#125;</span><br><span class="line">   | expresion_numerica <span class="variable constant_">DIVIDIDO</span> expresion_numerica &#123; $$ = instruccionesAPI.<span class="title function_">nuevoOperacionBinaria</span>($1, $3, <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">DIVISION</span>); &#125;</span><br><span class="line">   | <span class="variable constant_">PARIZQ</span> expresion_numerica <span class="variable constant_">PARDER</span>               &#123; $$ = $2; &#125;</span><br><span class="line">   | <span class="variable constant_">ENTERO</span>                                         &#123; $$ = instruccionesAPI.<span class="title function_">nuevoValor</span>(<span class="title class_">Number</span>($1), <span class="variable constant_">TIPO_VALOR</span>.<span class="property">NUMERO</span>); &#125;</span><br><span class="line">   | <span class="variable constant_">DECIMAL</span>                                        &#123; $$ = instruccionesAPI.<span class="title function_">nuevoValor</span>(<span class="title class_">Number</span>($1), <span class="variable constant_">TIPO_VALOR</span>.<span class="property">NUMERO</span>); &#125;</span><br><span class="line">   | <span class="variable constant_">IDENTIFICADOR</span>                                  &#123; $$ = instruccionesAPI.<span class="title function_">nuevoValor</span>($1, <span class="variable constant_">TIPO_VALOR</span>.<span class="property">IDENTIFICADOR</span>); &#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>También hacemos uso de la función nuevoValor para las expresiones con valor.</p>
<p>El proceso es el mismo para las Instrucciones, cada producción de tipo Instrucción invoca a su función designada en nuestra API.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">instruccion</span><br><span class="line">   : <span class="variable constant_">RIMPRIMIR</span> <span class="variable constant_">PARIZQ</span> expresion_cadena <span class="variable constant_">PARDER</span> <span class="variable constant_">PTCOMA</span>                        &#123; $$ = instruccionesAPI.<span class="title function_">nuevoImprimir</span>($3); &#125;</span><br><span class="line">   | <span class="variable constant_">RMIENTRAS</span> <span class="variable constant_">PARIZQ</span> expresion_logica <span class="variable constant_">PARDER</span> <span class="variable constant_">LLAVIZQ</span> instrucciones <span class="variable constant_">LLAVDER</span> &#123; $$ = instruccionesAPI.<span class="title function_">nuevoMientras</span>($3, $6); &#125;</span><br><span class="line">   | <span class="variable constant_">RNUMERO</span> <span class="variable constant_">IDENTIFICADOR</span> <span class="variable constant_">PTCOMA</span>                                           &#123; $$ = instruccionesAPI.<span class="title function_">nuevoDeclaracion</span>($2); &#125;</span><br><span class="line">   | <span class="variable constant_">IDENTIFICADOR</span> <span class="variable constant_">IGUAL</span> expresion_numerica <span class="variable constant_">PTCOMA</span>                          &#123; $$ = instruccionesAPI.<span class="title function_">nuevoAsignacion</span>($1, $3); &#125;</span><br><span class="line">   | <span class="variable constant_">RIF</span> <span class="variable constant_">PARIZQ</span> expresion_logica <span class="variable constant_">PARDER</span> <span class="variable constant_">LLAVIZQ</span> instrucciones <span class="variable constant_">LLAVDER</span>       &#123; $$ = instruccionesAPI.<span class="title function_">nuevoIf</span>($3, $6); &#125;</span><br><span class="line">   | <span class="variable constant_">RIF</span> <span class="variable constant_">PARIZQ</span> expresion_logica <span class="variable constant_">PARDER</span> <span class="variable constant_">LLAVIZQ</span> instrucciones <span class="variable constant_">LLAVDER</span> <span class="variable constant_">RELSE</span> <span class="variable constant_">LLAVIZQ</span> instrucciones <span class="variable constant_">LLAVDER</span></span><br><span class="line">                                                                            &#123; $$ = instruccionesAPI.<span class="title function_">nuevoIf</span>($3, $6, $10); &#125;</span><br><span class="line">   | error &#123; <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Este es un error sintáctico: &#x27;</span> + yytext + <span class="string">&#x27;, en la linea: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">_$</span>.<span class="property">first_line</span> + <span class="string">&#x27;, en la columna: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">_$</span>.<span class="property">first_column</span>); &#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>Finalmente, una vez que hayamos reconocido toda la entrada, construimos un arreglo con cada uno de los nodos. Este será nuestro AST.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ini</span><br><span class="line">	: instrucciones <span class="variable constant_">EOF</span> &#123;</span><br><span class="line">		<span class="comment">// cuado se haya reconocido la entrada completa retornamos el AST</span></span><br><span class="line">		<span class="keyword">return</span> $1;</span><br><span class="line">	&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">instrucciones</span><br><span class="line">	: instrucciones instruccion &#123; $1.<span class="title function_">push</span>($2); $$ = $1; &#125;</span><br><span class="line">	| instruccion               &#123; $$ = [$1]; &#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>Para generar el parser ejecutamos el script compilar.sh dentro de nuestro proyecto</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh compilar.<span class="property">sh</span></span><br></pre></td></tr></table></figure>

 

<p>Esto generará el script <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJisonJS/blob/master/gramatica.js">gramatica.js</a> con el cual ya podremos procesar nuestro archivo de entrada.</p>
<p><em><strong>La tabla de símbolos</strong></em></p>
<p>La <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJisonJS/blob/master/tabla_simbolos.js">tabla de símbolos</a> es la que permite el almacenamiento y recuperación de los valores de las variables. Para su implementación hacemos uso de una clase, ya que necesitaremos más de una instancia de tabla de símbolos. Cada ámbito tiene acceso únicamente a su propia tabla de símbolos y a la de los niveles superiores.</p>
<p>Definimos las constantes para los tipos de datos, en este tutorial se hace uso únicamente del tipo de dato numérico.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constantes para los tipos de datos.</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TIPO_DATO</span> = &#123;</span><br><span class="line">    <span class="attr">NUMERO</span>: <span class="string">&#x27;NUMERO&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Se define una función para crear objetos de tipo Símbolo.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Función que crea objetos de tipo Símbolo.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; id </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; tipo </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; valor </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">crearSimbolo</span>(<span class="params">id, tipo, valor</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">id</span>: id,</span><br><span class="line">        <span class="attr">tipo</span>: tipo,</span><br><span class="line">        <span class="attr">valor</span>: valor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>La clase TS define las estructura de una tabla de símbolos y sus funciones para agregar, modificar y obtener símbolos.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clase que representa una Tabla de Símbolos.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TS</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * El costructor recibe como parámetro los simbolos de la tabla padre.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; simbolos </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span> (<span class="params">simbolos</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_simbolos</span> = simbolos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Función para gregar un nuevo símbolo.</span></span><br><span class="line"><span class="comment">     * Esta función se usa en la sentencia de Declaración.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; id </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; tipo </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">agregar</span>(<span class="params">id, tipo</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> nuevoSimbolo = <span class="title function_">crearSimbolo</span>(id, tipo);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_simbolos</span>.<span class="title function_">push</span>(nuevoSimbolo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Función para actualizar el valor de un símbolo existente.</span></span><br><span class="line"><span class="comment">     * Esta función se usa en la sentencia de Asignación.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; id </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; valor </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">actualizar</span>(<span class="params">id, valor</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> simbolo = <span class="variable language_">this</span>.<span class="property">_simbolos</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">simbolo</span> =&gt;</span> simbolo.<span class="property">id</span> === id)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (simbolo) simbolo.<span class="property">valor</span> = valor;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="string">&#x27;ERROR: variable: &#x27;</span> + id + <span class="string">&#x27; no ha sido definida&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Función para obtener el valor de un símbolo existente.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; id </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">obtener</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> simbolo = <span class="variable language_">this</span>.<span class="property">_simbolos</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">simbolo</span> =&gt;</span> simbolo.<span class="property">id</span> === id)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (simbolo) <span class="keyword">return</span> simbolo.<span class="property">valor</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="string">&#x27;ERROR: variable: &#x27;</span> + id + <span class="string">&#x27; no ha sido definida&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Función getter para obtener los símbolos.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">simbolos</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_simbolos</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finalmente, exportamos las constantes y la clase</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exportamos las constantes y la clase.</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">TIPO_DATO</span> = <span class="variable constant_">TIPO_DATO</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">TS</span> = <span class="variable constant_">TS</span>;</span><br></pre></td></tr></table></figure>

<p><em><strong>Construcción del Intérprete</strong></em></p>
<p>La definición del Intérprete se encuentra en el archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJisonJS/blob/master/interprete.js">interprete.js</a>.</p>
<p>Para iniciar con la implementación, primero importamos el parser, las constantes del AST y  de la Tabla de Símbolos.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); </span><br><span class="line"><span class="keyword">var</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;./gramatica&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constantes para operaciones, instrucciones y valores</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TIPO_INSTRUCCION</span> = <span class="built_in">require</span>(<span class="string">&#x27;./instrucciones&#x27;</span>).<span class="property">TIPO_INSTRUCCION</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TIPO_OPERACION</span> = <span class="built_in">require</span>(<span class="string">&#x27;./instrucciones&#x27;</span>).<span class="property">TIPO_OPERACION</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TIPO_VALOR</span> = <span class="built_in">require</span>(<span class="string">&#x27;./instrucciones&#x27;</span>).<span class="property">TIPO_VALOR</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tabla de Simbolos</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TIPO_DATO</span> = <span class="built_in">require</span>(<span class="string">&#x27;./tabla_simbolos&#x27;</span>).<span class="property">TIPO_DATO</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TS</span> = <span class="built_in">require</span>(<span class="string">&#x27;./tabla_simbolos&#x27;</span>).<span class="property">TS</span>;</span><br></pre></td></tr></table></figure>

<p>Seguidamente, obtenemos el AST a partir del archivo de entrada.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ast;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// leemos nuestro archivo de entrada</span></span><br><span class="line">    <span class="keyword">const</span> entrada = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./entrada.txt&#x27;</span>);</span><br><span class="line">    <span class="comment">// invocamos a nuestro parser con el contendio del archivo de entradas</span></span><br><span class="line">    ast = parser.<span class="title function_">parse</span>(entrada.<span class="title function_">toString</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// imrimimos en un archivo el contendio del AST en formato JSON</span></span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./ast.json&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(ast, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nótese que se escribe el contenido del AST en un archivo llamado <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJisonJS/blob/master/ast.json">ast.json</a> en formato JSON, esto no es necesario, pero es una forma de ver el contenido del AST en un formato entendible. </p>
<p>El contenido del formato JSON se puede visualizar en cualquier herramienta. Por ejemplo la extensión de Google Chrome <a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/json-viewer-awesome/iemadiahhbebdklepanmkjenfdebfpfe?hl=en">JSON Viewer Awesome</a>.</p>


<p>El cual cuenta con una vista gráfica y nos permite visualizar el AST así como también navegar por sus nodos</p>


<p>La función principal del <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/InterpreteSencilloJisonJS/blob/master/interprete.js">intérprete</a> es de reconocer cada instrucción instrucción y ejecutarla, para esto es necesario recorrer el AST; es por ello que se ha definido la función <em>procesarBloque</em> el cual itera las instrucciones en un ámbito y las ejecuta.</p>
<p>Para iniciar con la ejecución se crea la tabla de símbolos para el ámbito global y se invoca la función <em>procesarBloque</em> con la raíz del AST y la tabla de símbolos del ámbito global.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creación de una tabla de simbolos GLOBAL para iniciar con el interprete</span></span><br><span class="line"><span class="keyword">const</span> tsGlobal = <span class="keyword">new</span> <span class="title function_">TS</span>([]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Procesamos las instrucciones reconocidas en nuestro AST</span></span><br><span class="line"><span class="title function_">procesarBloque</span>(ast, tsGlobal);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Este es el método principal. Se encarga de recorrer las instrucciones en un bloque,</span></span><br><span class="line"><span class="comment"> * identificarlas y procesarlas</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; instrucciones </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; tablaDeSimbolos </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">procesarBloque</span>(<span class="params">instrucciones, tablaDeSimbolos</span>) &#123;</span><br><span class="line">    instrucciones.<span class="title function_">forEach</span>(<span class="function"><span class="params">instruccion</span> =&gt;</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span> (instruccion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_INSTRUCCION</span>.<span class="property">IMPRIMIR</span>) &#123;</span><br><span class="line">            <span class="comment">// Procesando Instrucción Imprimir</span></span><br><span class="line">            <span class="title function_">procesarImprimir</span>(instruccion, tablaDeSimbolos);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instruccion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_INSTRUCCION</span>.<span class="property">MIENTRAS</span>) &#123;</span><br><span class="line">            <span class="comment">// Procesando Instrucción Mientras</span></span><br><span class="line">            <span class="title function_">procesarMientras</span>(instruccion, tablaDeSimbolos);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instruccion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_INSTRUCCION</span>.<span class="property">DECLARACION</span>) &#123;</span><br><span class="line">            <span class="comment">// Procesando Instrucción Declaración</span></span><br><span class="line">            <span class="title function_">procesarDeclaracion</span>(instruccion, tablaDeSimbolos);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instruccion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_INSTRUCCION</span>.<span class="property">ASIGNACION</span>) &#123;</span><br><span class="line">            <span class="comment">// Procesando Instrucción Asignación</span></span><br><span class="line">            <span class="title function_">procesarAsignacion</span>(instruccion, tablaDeSimbolos);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instruccion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_INSTRUCCION</span>.<span class="property">IF</span>) &#123;</span><br><span class="line">            <span class="comment">// Procesando Instrucción If</span></span><br><span class="line">            <span class="title function_">procesarIf</span>(instruccion, tablaDeSimbolos);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instruccion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_INSTRUCCION</span>.<span class="property">IF_ELSE</span>) &#123;</span><br><span class="line">            <span class="comment">// Procesando Instrucción If Else</span></span><br><span class="line">            <span class="title function_">procesarIfElse</span>(instruccion, tablaDeSimbolos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&#x27;ERROR: tipo de instrucción no válido: &#x27;</span> + instruccion;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Existe una función para procesar cada instrucción. </p>
<p>Las sentencias Mientras, If e If-Else crean nuevas tablas de símbolos antes de procesar las instrucciones dentro de sus bloques de instrucciones. Estas nuevas tablas de símbolos se inicializan con los valores de la tabla de símbolo actual y al terminar la ejecución de la sentencia los valores son eliminados ya que la instancia se crea localmente en el cuerpo de la función.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Función que se encarga de procesar la instrucción Mientras</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">procesarMientras</span>(<span class="params">instruccion, tablaDeSimbolos</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="title function_">procesarExpresionLogica</span>(instruccion.<span class="property">expresionLogica</span>, tablaDeSimbolos)) &#123;</span><br><span class="line">        <span class="keyword">const</span> tsMientras = <span class="keyword">new</span> <span class="title function_">TS</span>(tablaDeSimbolos.<span class="property">simbolos</span>);</span><br><span class="line">        <span class="title function_">procesarBloque</span>(instruccion.<span class="property">instrucciones</span>, tsMientras);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Función que se encarga de procesar la instrucción If</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">procesarIf</span>(<span class="params">instruccion, tablaDeSimbolos</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> valorCondicion = <span class="title function_">procesarExpresionLogica</span>(instruccion.<span class="property">expresionLogica</span>, tablaDeSimbolos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valorCondicion) &#123;</span><br><span class="line">        <span class="keyword">const</span> tsIf = <span class="keyword">new</span> <span class="title function_">TS</span>(tablaDeSimbolos.<span class="property">simbolos</span>);</span><br><span class="line">        <span class="title function_">procesarBloque</span>(instruccion.<span class="property">instrucciones</span>, tsIf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Función que se encarga de procesar la instrucción If-Else</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; instruccion </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; tablaDeSimbolos </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">procesarIfElse</span>(<span class="params">instruccion, tablaDeSimbolos</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> valorCondicion = <span class="title function_">procesarExpresionLogica</span>(instruccion.<span class="property">expresionLogica</span>, tablaDeSimbolos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valorCondicion) &#123;</span><br><span class="line">        <span class="keyword">const</span> tsIf = <span class="keyword">new</span> <span class="title function_">TS</span>(tablaDeSimbolos.<span class="property">simbolos</span>);</span><br><span class="line">        <span class="title function_">procesarBloque</span>(instruccion.<span class="property">instruccionesIfVerdadero</span>, tsIf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> tsElse = <span class="keyword">new</span> <span class="title function_">TS</span>(tablaDeSimbolos.<span class="property">simbolos</span>);</span><br><span class="line">        <span class="title function_">procesarBloque</span>(instruccion.<span class="property">instruccionesIfFalso</span>, tsElse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Las sentencias de Declaración y Asignación agregan y modifican valores de la tabla de símbolos. La sentencia Imprimir muestra el valor de una cadena en la consola.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Función que se encarga de procesar la instrucción Imprimir</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; instruccion </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; tablaDeSimbolos </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">procesarImprimir</span>(<span class="params">instruccion, tablaDeSimbolos</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cadena = <span class="title function_">procesarExpresionCadena</span>(instruccion.<span class="property">expresionCadena</span>, tablaDeSimbolos);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&gt; &#x27;</span> + cadena);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Función que se encarga de procesar la instrucción Declaración</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; instruccion </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; tablaDeSimbolos </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">procesarDeclaracion</span>(<span class="params">instruccion, tablaDeSimbolos</span>) &#123;</span><br><span class="line">    tablaDeSimbolos.<span class="title function_">agregar</span>(instruccion.<span class="property">identificador</span>, <span class="variable constant_">TIPO_DATO</span>.<span class="property">NUMERO</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Función que se encarga de procesar la instrucción Asignación</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; instruccion </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; tablaDeSimbolos </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">procesarAsignacion</span>(<span class="params">instruccion, tablaDeSimbolos</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> valor = <span class="title function_">procesarExpresionNumerica</span>(instruccion.<span class="property">expresionNumerica</span>, tablaDeSimbolos)</span><br><span class="line">    tablaDeSimbolos.<span class="title function_">actualizar</span>(instruccion.<span class="property">identificador</span>, valor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finalmente, todas las sentencias descritas anteriormente hacen uso de las operaciones numéricas, con cadenas y lógicas las cuales hacen uso de la tabla de símbolos para obtener valores de las variables.</p>
<p>Para las expresiones numéricas evaluamos el tipo de operación y con base en ellos resolvemos el valor apropiado.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * De acuerdo con nuestra gramática, aqui, expresión puede ser una operación aritmética binaria (SUMA, RESTA, MULTIPLICACION, DIVISION),</span></span><br><span class="line"><span class="comment"> * una operación aritmética unaria (NEGATIVO) o un valor correspondiente a un NUMERO o a un IDENTIFICADOR</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; expresion </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TS</span>&#125; <span class="variable">tablaDeSimbolos</span></span></span><br><span class="line"><span class="comment"> * Evaluamos cada caso para resolver a un valor tipo número de acuerdo al tipo de operación.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">procesarExpresionNumerica</span>(<span class="params">expresion, tablaDeSimbolos</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">NEGATIVO</span>) &#123;</span><br><span class="line">        <span class="comment">// Es un valor negado.</span></span><br><span class="line">        <span class="comment">// En este caso necesitamos procesar el valor del operando para poder negar su valor.</span></span><br><span class="line">        <span class="comment">// Para esto invocamos (recursivamente) esta función para sesolver el valor del operando.</span></span><br><span class="line">        <span class="keyword">const</span> valor = <span class="title function_">procesarExpresionNumerica</span>(expresion.<span class="property">operandoIzq</span>, tablaDeSimbolos);     <span class="comment">// resolvemos el operando</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Retornamos el valor negado.</span></span><br><span class="line">        <span class="keyword">return</span> valor * -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">SUMA</span> </span><br><span class="line">        || expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">RESTA</span></span><br><span class="line">        || expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">MULTIPLICACION</span></span><br><span class="line">        || expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">DIVISION</span>) &#123;</span><br><span class="line">        <span class="comment">// Es una operación aritmética.</span></span><br><span class="line">        <span class="comment">// En este caso necesitamos procesar los operandos antes de realizar la operación.</span></span><br><span class="line">        <span class="comment">// Para esto incovacmos (recursivamente) esta función para resolver los valores de los operandos.</span></span><br><span class="line">        <span class="keyword">const</span> valorIzq = <span class="title function_">procesarExpresionNumerica</span>(expresion.<span class="property">operandoIzq</span>, tablaDeSimbolos);      <span class="comment">// resolvemos el operando izquierdo.</span></span><br><span class="line">        <span class="keyword">const</span> valorDer = <span class="title function_">procesarExpresionNumerica</span>(expresion.<span class="property">operandoDer</span>, tablaDeSimbolos);      <span class="comment">// resolvemos el operando derecho.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">SUMA</span>) <span class="keyword">return</span> valorIzq + valorDer;</span><br><span class="line">        <span class="keyword">if</span> (expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">RESTA</span>) <span class="keyword">return</span> valorIzq - valorDer;</span><br><span class="line">        <span class="keyword">if</span> (expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">MULTIPLICACION</span>) <span class="keyword">return</span> valorIzq * valorDer;</span><br><span class="line">        <span class="keyword">if</span> (expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">DIVISION</span>) <span class="keyword">return</span> valorIzq / valorDer;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_VALOR</span>.<span class="property">NUMERO</span>) &#123;</span><br><span class="line">        <span class="comment">// Es un valor numérico.</span></span><br><span class="line">        <span class="comment">// En este caso únicamente retornamos el valor obtenido por el parser directamente.</span></span><br><span class="line">        <span class="keyword">return</span> expresion.<span class="property">valor</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_VALOR</span>.<span class="property">IDENTIFICADOR</span>) &#123;</span><br><span class="line">        <span class="comment">// Es un identificador.</span></span><br><span class="line">        <span class="comment">// Obtenemos el valor de la tabla de simbolos</span></span><br><span class="line">        <span class="keyword">return</span> tablaDeSimbolos.<span class="title function_">obtener</span>(expresion.<span class="property">valor</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;ERROR: expresión numérica no válida: &#x27;</span> + expresion;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Para las expresiones con cadenas también validamos el tipo de operación para verificar si es necesario una operación de concatenación. En cualquier caso se resuelve la cadena.  También es posible concatenar valores numéricos, para esto resolvemos la expresión apoyándonos de la función para procesar expresiones numéricas.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * De acuerdo con nuestra gramática, aqui, expresión puede ser una operacion CONCATENACION, CADENA o una expresión numérica</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; expresion </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TS</span>&#125; <span class="variable">tablaDeSimbolos</span></span></span><br><span class="line"><span class="comment"> * Evaluamos cada caso para resolver a un valor tipo cadena de acuerdo al tipo de operación.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">procesarExpresionCadena</span>(<span class="params">expresion, tablaDeSimbolos</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">CONCATENACION</span>) &#123;</span><br><span class="line">        <span class="comment">// Es una operación de concatenación.</span></span><br><span class="line">        <span class="comment">// En este caso necesitamos procesar los operandos antes de realizar la concatenación.</span></span><br><span class="line">        <span class="comment">// Para esto invocamos (recursivamente) esta función para resolver los valores de los operandos.</span></span><br><span class="line">        <span class="keyword">const</span> cadIzq = <span class="title function_">procesarExpresionCadena</span>(expresion.<span class="property">operandoIzq</span>, tablaDeSimbolos);      <span class="comment">// resolvemos el operando izquierdo.</span></span><br><span class="line">        <span class="keyword">const</span> cadDer = <span class="title function_">procesarExpresionCadena</span>(expresion.<span class="property">operandoDer</span>, tablaDeSimbolos);      <span class="comment">// resolvemos el operando derecho.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retornamos el resultado de la operación de concatenación.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cadIzq + cadDer;     </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_VALOR</span>.<span class="property">CADENA</span>) &#123;</span><br><span class="line">        <span class="comment">// Es una cadena.</span></span><br><span class="line">        <span class="comment">// En este caso únicamente retornamos el valor obtenido por el parser directamente.</span></span><br><span class="line">        <span class="keyword">return</span> expresion.<span class="property">valor</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Es una epresión numérica.</span></span><br><span class="line">        <span class="comment">// En este caso invocamos la función que se encarga de procesar las expresiones numéricas</span></span><br><span class="line">        <span class="comment">// y retornamos su valor en cadena.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">procesarExpresionNumerica</span>(expresion, tablaDeSimbolos).<span class="title function_">toString</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Al igual que las expresiones con cadena, las expresiones lógicas también se apoya en la función que procesa expresiones numéricas para poder evaluar las condiciones booleanas.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * De acuerdo con nuestra gramática, aqui, expresión puede ser una operación lógica MAYOR QUE o MENOR QUE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; expresion </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TS</span>&#125; <span class="variable">tablaDeSimbolos</span></span></span><br><span class="line"><span class="comment"> * Evaluamos cada caso para resolver a un valor tipo booleando de acuerdo al tipo de operación.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">procesarExpresionLogica</span>(<span class="params">expresion, tablaDeSimbolos</span>) &#123;</span><br><span class="line">    <span class="comment">// En este caso necesitamos procesar los operandos antes de realizar la comparación.</span></span><br><span class="line">    <span class="keyword">const</span> valorIzq = <span class="title function_">procesarExpresionNumerica</span>(expresion.<span class="property">operandoIzq</span>, tablaDeSimbolos);      <span class="comment">// resolvemos el operando izquierdo.</span></span><br><span class="line">    <span class="keyword">const</span> valorDer = <span class="title function_">procesarExpresionNumerica</span>(expresion.<span class="property">operandoDer</span>, tablaDeSimbolos);      <span class="comment">// resolvemos el operando derecho.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">MAYOR_QUE</span>) <span class="keyword">return</span> valorIzq &gt; valorDer;</span><br><span class="line">    <span class="keyword">if</span> (expresion.<span class="property">tipo</span> === <span class="variable constant_">TIPO_OPERACION</span>.<span class="property">MENOR_QUE</span>) <span class="keyword">return</span> valorIzq &lt; valorDer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Para ejecutar nuestro intérprete y procesar el archivo de entrada ejecutamos el siguiente comando:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node interprete</span><br></pre></td></tr></table></figure>

<p>Y veremos el resultado en consola.</p>


<p><em><strong>Acerca del autor:</strong></em></p>
<p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/rjanixz">Rainman Sián</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<p><em><strong>Fuentes consultadas:</strong></em></p>
<p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-07-24T14:21:58.000Z" title="7/24/2019, 8:21:58 AM">2019-07-24</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/24/19-Mi-primer-proyecto-utilizando-Irony-Windows/">Mi primer proyecto utilizando Irony</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presenta como salida el resultado de dichas expresiones evaluadas.</p>
<p>Las tecnologías a utilizar son:</p>
<ul>
<li><strong>Irony</strong>: Generador de analizadores léxicos y sintácticos que retorna un AST (Abstract Syntax Tree).</li>
<li><strong>Visual Studio 2017</strong>: Entorno de desarrollo integrado utilizado para programar en C#.</li>
<li><strong>Windows 10</strong>: Sistema Operativo.</li>
<li><strong>Irony.dll</strong>: DLL que permite la integración de Irony con C#.</li>
</ul>
<p>El proyecto completo puede descargarse del siguiente enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS">Mi primer proyecto utilizando Irony</a></li>
</ul>
<h3 id="Irony"><a href="#Irony" class="headerlink" title="Irony"></a><strong>Irony</strong></h3><p><a target="_blank" rel="noopener" href="https://archive.codeplex.com/?p=irony">Irony</a> es un kit de desarrollo para implementar lenguajes en la plataforma .NET. A diferencia de la mayoría de las soluciones de estilo yacc &#x2F; lex existentes, Irony no emplea ninguna generación de scanner (analizador léxico) o parser (analizador sintáctico) a partir de especificaciones gramaticales escritas en un meta-lenguaje especializado. En Irony, la gramática del lenguaje se codifica directamente en C# utilizando la sobrecarga de operadores para expresar construcciones gramaticales. Los módulos de scanner y parser de Irony utilizan la gramática codificada como una clase de C# para controlar el proceso de análisis. En la página principal de <a target="_blank" rel="noopener" href="https://archive.codeplex.com/?p=irony">Irony</a>, se anuncia que el proyecto se ha movido a un <a target="_blank" rel="noopener" href="https://github.com/IronyProject/">repositorio en GitHub</a>.</p>
<h3 id="Analizador-lexico-Scanner"><a href="#Analizador-lexico-Scanner" class="headerlink" title="Analizador léxico (Scanner)"></a><strong>Analizador léxico (Scanner)</strong></h3><p>La principal tarea de un analizador léxico es leer los caracteres de entrada del programa fuente, agruparlos en lexemas y producir como salida una secuencia de tokens.</p>
<ul>
<li><p>Un <em>token</em> es un par que consiste en un nombre de token y un valor de atributo opcional.</p>
</li>
<li><p>Un <em>lexema</em> es una secuencia de caracteres en el programa fuente, que coinciden con el patrón para un token y que el analizador léxico identifica como una instancia de este tóken.</p>
</li>
<li><p>Un <em>patrón</em> es una descripción de la forma que pueden tomar los lexemas de un token.</p>
</li>
</ul>
<h3 id="Analizador-sintactico-Parser"><a href="#Analizador-sintactico-Parser" class="headerlink" title="Analizador sintáctico (Parser)"></a><strong>Analizador sintáctico (Parser)</strong></h3><p>El analizador sintáctico obtiene una cadena de tokens del analizador léxico y verifica que dicha cadena pueda generarse con la gramática para el lenguaje fuente. Una gramática proporciona una especificación precisa y fácil de entender de un lenguaje de programación.</p>
<h3 id="Pre-requisitos"><a href="#Pre-requisitos" class="headerlink" title="Pre-requisitos"></a><strong>Pre-requisitos</strong></h3><ul>
<li><strong>Obtención del archivo <a target="_blank" rel="noopener" href="https://archive.codeplex.com/?p=irony">Irony.DDL</a></strong></li>
</ul>
<p>El <a target="_blank" rel="noopener" href="https://github.com/IronyProject/">proyecto de Irony</a> anteriormente mencionado es un proyecto de C#, el cual contiene la aplicación de Irony, sin embargo, a nosotros únicamente nos interesa las librerías que este proyecto genera, para obtener dichas librerías debemos seguir los siguientes pasos: </p>
<ol>
<li>   Descargar el repositorio completo de Irony desde <a target="_blank" rel="noopener" href="https://github.com/IronyProject/Irony/">GitHub</a>.</li>
</ol>


<ol start="2">
<li>Descomprimimos el repositorio e ingresamos a la carpeta <em>Irony.Interpreter</em></li>
</ol>


<ol start="3">
<li>   Dentro de la carpeta <em>Irony.Interpreter</em>, encontraremos el proyecto <em>015.Irony.Interpreter.csproj</em>, debemos abrir este proyecto con Visual Studio.</li>
</ol>


<ol start="4">
<li>   Al tener abierto el proyecto en Visual Studio, procedemos a dar click derecho en el nombre del proyecto → “Build Solution” en el nombre del .</li>
</ol>


<ol start="5">
<li>   Luego de haber ejecutado exitosamente la opción “Build Solution” se creará la carpeta <em>bin&#x2F;Debug</em> dentro de la carpeta del proyecto <em>Irony.Interpreter</em>. Encontraremos en esta carpeta generada dos carpetas: <em>net40</em>, <em>netstandard2.0</em>. Nosotros escogeremos la carpeta <em>net40</em>, que corresponde a .NET Framework 4.0, nosotros escogeremos esta que sería la versión más reciente, que además es compatible con el proyecto que crearemos en Visual Studio 2017.</li>
</ol>


<ol start="6">
<li>   Dentro de la carpeta <em>net40</em> encontraremos el archivo Irony.dll, que utilizaremos en nuestro proyecto.</li>
</ol>


<ul>
<li><strong>Creación del proyecto en el que utilizaremos Irony</strong></li>
</ul>
<ol>
<li>Abrimos Visual Studio y seleccionamos la opción “File” → “New” → “Project…”.</li>
</ol>


<ol start="2">
<li>Una vez abierto el wizard para crear nuevos proyectos seleccionamos el apartado “Visual C#” → “Windows Desktop” → “Console App (.NET Framework)” y le pondremos como nombre ProyectoIronyCS.</li>
</ol>


<ol start="3">
<li>Posteriormente creamos una carpeta lib dentro de nuestro proyecto, para ello vamos al explorador de soluciones y hacemos click derecho en el nombre del proyecto, “Add” → “New Folder”. En la carpeta <em>lib</em> recién creada, pegamos el archivo <em>Irony.dll</em> anteriormente generado.</li>
</ol>


<ol start="4">
<li>Luego de pegar el archivo <em>Irony.dll</em>, volvemos al explorador de soluciones y damos click derecho en la carpeta <em>lib</em>, “Add” → “Existing Item…”.</li>
</ol>


<ol start="5">
<li>Buscamos el archivo <em>Irony.dll</em> que acabamos de pegar en la carpeta <em>lib</em> y lo agregamos.</li>
</ol>


<ol start="6">
<li>Importamos la librería <em>Irony.dll</em> que acabamos de pegar en nuestra carpeta <em>lib</em>, para hacerlo daremos click derecho en “References” → “Add Reference…”</li>
</ol>


<ol start="7">
<li>Esto nos desplegara una nueva ventana, seleccionamos la opción “Browse…” y seleccionamos nuestro archivo .dll y daremos click en aceptar.</li>
</ol>


<ul>
<li><strong>Creación de la gramática</strong></li>
</ul>
<ol>
<li>La creación de la gramática se realiza por medio de un archivo .cs, para ello agregaremos primero una carpeta a la solución con el nombre de analizador, esto no es completamente necesario, lo hacemos para tener el código organizado.<br>Para crear la carpeta es clic derecho sobre el nombre de nuestro proyecto en el explorador de soluciones. “Add” → “New Folder”, le asignamos el nombre “analizador”.</li>
</ol>

<ol start="2">
<li>Dentro de la carpeta creamos una nueva clase de nombre <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/analizador/Gramatica.cs">“Gramatica”</a> que contendrá toda la gramática para Irony, para ello hacemos click derecho sobre la carpeta “Add” → “Class”.</li>
</ol>


<hr>


<ol start="3">
<li>En la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/analizador/Gramatica.cs">“Gramatica”</a> incorporamos el código de la gramática correspondiente a este ejemplo, dicho código puede consultarse en el <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/analizador/Gramatica.cs">repositorio</a>.</li>
</ol>
<ul>
<li><strong>Explicación de la gramática creada</strong></li>
</ul>
<p>A continuación se explican los principales elementos de la clase gramática:</p>
<ul>
<li>Se importan las librerías de Irony a utilizar</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using Irony.Ast;</span><br><span class="line">using Irony.Parsing;</span><br></pre></td></tr></table></figure>
<ul>
<li>Nos aseguramos de que la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/analizador/Gramatica.cs">“Gramatica”</a> herede de la clase “Grammar” de Irony.Parsing.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Gramatica : Grammar</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Una de las principales características de Irony es poder organizar todo en regiones, para crear una región se debe escribir el nombre de la región de la siguiente manera:</p>
<ul>
<li>Se comienza la región con “#region ” seguido del nombre de la región </li>
<li>Se finaliza la región con “#endregion”</li>
</ul>
</li>
<li><p>Para la gramática anterior se definen las siguientes regiones:</p>
<ul>
<li>ER: Expresiones regulares de los tokens que nuestra gramática reconocerá.</li>
<li>Terminales: Conjunto de terminales que serán utilizados en nuestra gramática, que no fueron aceptados por ninguna de las expresiones regulares definidas anteriormente.</li>
<li>No terminales: Conjunto de no terminales que serán utilizados en nuestra gramática.</li>
<li>Gramática: Región donde se define la gramática. </li>
<li>Preferencia: Configuraciones especiales necesarias para el uso de Irony.</li>
</ul>
</li>
<li><p>La gramática debe reconocer números enteros y decimales, por lo que creamos las expresiones regulares para reconocer estos tokens. Para ello se crean objetos del tipo “RegexBasedTerminal”, el cual recibirá de parámetros: el nombre con que se va a reducir y la expresión regular a cumplir.</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var NUMERO = new NumberLiteral(<span class="string">&quot;Numero&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Posteriormente se escriben los terminales, para estos no es necesario escribir expresiones regulares pues son caracteres simples o bien palabras reservadas por esta razón es que no se incluyeron en la región ER. Para definir los terminales se crean variables instanciadas con la función “ToTerm”, que recibe de parámetro el símbolo terminal con el que debe de cumplir, para el ejemplo se definieron los siguientes:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var REVALUAR = ToTerm(<span class="string">&quot;Evaluar&quot;</span>);</span><br><span class="line">var PTCOMA = ToTerm(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">var PARIZQ = ToTerm(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">var PARDER = ToTerm(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">var CORIZQ = ToTerm(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">var CORDER = ToTerm(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">var MAS = ToTerm(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">var MENOS = ToTerm(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">var POR = ToTerm(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">var DIVIDIDO = ToTerm(<span class="string">&quot;/&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Se agrega precedencia a los operadores aritméticos, esto se hace con la función “RegisterOperators” que recibe como parámetro el nivel de precedencia y la lista de terminales que corresponde a dicho nivel.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RegisterOperators(1, MAS, MENOS);</span><br><span class="line">RegisterOperators(2, POR, DIVIDIDO);</span><br></pre></td></tr></table></figure>
<ul>
<li>Se crean los No Terminales para nuestra gramática, para esta declaración se deben crear objetos de tipo “NonTerminal” que en su constructor recibe de parámetro el nombre del no terminal.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NonTerminal ini = new NonTerminal(<span class="string">&quot;ini&quot;</span>);</span><br><span class="line">NonTerminal instruccion = new NonTerminal(<span class="string">&quot;instruccion&quot;</span>);</span><br><span class="line">NonTerminal instrucciones = new NonTerminal(<span class="string">&quot;instrucciones&quot;</span>);</span><br><span class="line">NonTerminal expresion = new NonTerminal(<span class="string">&quot;expresion&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Con lo anterior definido, se crea la gramática, para ello es importante resaltar los siguientes puntos:</p>
<ul>
<li>Toda producción debe iniciar con el nombre de algún no terminal previamente declarado y el atributo Rule “Produccion.Rule”.</li>
<li>Se finalizan las producciones con punto y coma.</li>
<li>Se pueden tener diferentes producciones en un solo no terminal, para ello cada una de ellas se separa con un “|”.</li>
<li>Para concatenar terminales o no terminales a la producción se debe usar siempre el signo “+”.</li>
</ul>
</li>
<li><p>Gramática utilizada:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ini.Rule = instrucciones;</span><br><span class="line"></span><br><span class="line">instrucciones.Rule = instruccion + instrucciones</span><br><span class="line">    | instruccion;</span><br><span class="line"></span><br><span class="line">instruccion.Rule = REVALUAR + CORIZQ + expresion + CORDER + PTCOMA;</span><br><span class="line"></span><br><span class="line">expresion.Rule = MENOS + expresion</span><br><span class="line">    | expresion + MAS + expresion</span><br><span class="line">    | expresion + MENOS + expresion</span><br><span class="line">    | expresion + POR + expresion</span><br><span class="line">    | expresion + DIVIDIDO + expresion</span><br><span class="line">    | NUMERO</span><br><span class="line">    | PARIZQ + expresion + PARDER;</span><br></pre></td></tr></table></figure>

<p>Para finalizar, es necesario declarar nuestra producción de inicio, para ello asignamos al atributo Root el no terminal con el cual comenzara nuestra gramática.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.Root = ini;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Recorrido del AST</strong></li>
</ul>
<p>Para realizar este recorrido se crea la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/analizador/Sintactico.cs">“Sintactico”</a> dentro de la carpeta analizador, tal como creamos la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/analizador/Gramatica.cs">“Gramatica”</a>:</p>


<p>El código de la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/analizador/Sintactico.cs">“Sintactico”</a>, puede consultarse en el <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/analizador/Sintactico.cs">repositorio</a>.</p>
<p>A continuación analizaremos el contenido de la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/analizador/Sintactico.cs">“Sintactico”</a>, pero antes de continuar es necesario tener presentes los siguientes conceptos de Irony:</p>
<ul>
<li><em>ParseTree</em>: AST devuelto por Irony que será posteriormente recorrido y analizado.</li>
<li><em>ParseTreeNode</em>: Cada uno de los nodos del <em>ParseTree</em>, el atributo mas importante de este nodo es:<ul>
<li><em>ChildNodes</em>: Atributo de cada <em>ParseTreeNode</em>, este atributo es de tipo Array y contiene todas las cualidades de una lista, tales como Count, ElementAt, etc. Si esta lista esta vacía significa que el nodo es un nodo hoja, caso contrario es un subárbol.</li>
</ul>
</li>
</ul>
<p>Como ya hemos mencionado, Irony no acepta acciones entre sus producciones, se limita a devolver el AST (Abstract Syntax Tree) que arma luego de ser aceptada la cadena de entrada.</p>
<p>Dentro de la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/analizador/Sintactico.cs">“Sintactico”</a>, podemos encontrar el método analizar para cargar el árbol y disparar el recorrido de dicho árbol a través de una llamada al método instrucciones a la que se le manda el nodo raíz del árbol.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void analizar(String cadena)</span><br><span class="line">&#123;</span><br><span class="line">    Gramatica gramatica = new Gramatica();</span><br><span class="line">    LanguageData lenguaje = new LanguageData(gramatica);</span><br><span class="line">    Parser parser = new Parser(lenguaje);</span><br><span class="line">    ParseTree arbol = parser.Parse(cadena);</span><br><span class="line">    ParseTreeNode raiz = arbol.Root;</span><br><span class="line"></span><br><span class="line">    instrucciones(raiz.ChildNodes.ElementAt(0));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>En el método tenemos lo siguiente:</p>
<ol>
<li>   Declarar un objeto de la clase que contiene nuestra gramática, en este caso será un objeto de la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/analizador/Gramatica.cs">“Gramatica”</a>.</li>
<li>   Crear un objeto de la clase “LanguageData”, el cual recibirá de parámetro la variable de nuestra gramática.</li>
<li>   Crear un objeto de la clase “Parser”, el cual recibirá de parámetro la variable de la clase “LenguageData”.</li>
<li>   Obtener el AST (Abstract Syntax Tree) de la entrada procesada creando un objeto de la clase “ParseTree”.</li>
<li>   Obtener la raíz del árbol con el atributo “root” del ParseTree, este es un objeto de tipo “ParseTreeNode” y contiene toda la información del nodo, en este caso el nodo raíz.</li>
<li>   Invocar el método instrucciones enviándole como parámetro el nodo raíz del AST.</li>
</ol>
<p>Para recorrer el AST (Abstract Syntax Tree) es importante comprender cómo está armado según la gramática definida. Para la entrada: “Evaluar[1+1];”, por ejemplo, el árbol que arma nuestra gramática es:</p>


<p>Analizando la imagen con la estructura del árbol tenemos que:</p>
<ul>
<li>Los No terminales se guardan en el nodo únicamente con el nombre que se les dio para reducir al momento de declararlos.</li>
<li>Los Terminales se guardan junto a un Keyword.</li>
<li>Los Token dados con expresiones regulares, guardan el valor original con que coincidió la ER, seguido del nombre que se le dio para reducir.</li>
</ul>
<p>Teniendo lo anterior en cuenta creamos dentro de la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/analizador/Sintactico.cs">“Sintactico”</a> un set de funciones representativas para cada producción, estas siempre recibirán como  parámetro el nodo padre y usaran la información almacenada en los nodos para ejecutar las acciones correspondientes.</p>
<ul>
<li><em>Para las producciones del no terminal “instrucciones”, tenemos la siguiente función:</em></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void instrucciones(ParseTreeNode actual) &#123;</span><br><span class="line">    <span class="keyword">if</span> (actual.ChildNodes.Count == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        instruccion(actual.ChildNodes.ElementAt(0));</span><br><span class="line">        instrucciones(actual.ChildNodes.ElementAt(1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        instruccion(actual.ChildNodes.ElementAt(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>En nuestra gramática, el no terminal “instrucciones”, contaba con 2 posibles producciones, una en la cual tenia dos hijos y en la otra solamente uno, con esta información y usando la propiedad ChildNodes, hacemos el recorrido de esa producción, haciendo llamadas a otras funciones según el no terminal encontrado.</p>
<ul>
<li><em>Para la producción del no terminal “instruccion”, tendremos la siguiente función:</em></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void instruccion(ParseTreeNode actual) &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;El valor de la expresion es: &quot;</span> + expresion(actual.ChildNodes.ElementAt(2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Este no terminal posee solamente una producción, por lo cual no es necesario evaluar condiciones para determinar qué método debe ejecutar posteriormente. Este método imprime “El valor de la expresión es:”, seguido del resultado que nos devuelve la llamada a expresión.</p>
<ul>
<li><em>Para la producción de “expresion”, tendremos la siguiente función:</em></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public double expresion(ParseTreeNode actual) &#123;</span><br><span class="line">    <span class="keyword">if</span> (actual.ChildNodes.Count == 3) &#123;</span><br><span class="line">        string tokenOperador = actual.ChildNodes.ElementAt(1).ToString().Split(<span class="string">&#x27; &#x27;</span>)[0];</span><br><span class="line">        switch (tokenOperador) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                <span class="built_in">return</span> expresion(actual.ChildNodes.ElementAt(0))  + expresion(actual.ChildNodes.ElementAt(2));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="built_in">return</span> expresion(actual.ChildNodes.ElementAt(0)) - expresion(actual.ChildNodes.ElementAt(2));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="built_in">return</span> expresion(actual.ChildNodes.ElementAt(0)) * expresion(actual.ChildNodes.ElementAt(2));</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="built_in">return</span> expresion(actual.ChildNodes.ElementAt(0)) / expresion(actual.ChildNodes.ElementAt(2));</span><br><span class="line">            default:</span><br><span class="line">                <span class="built_in">return</span> expresion(actual.ChildNodes.ElementAt(1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (actual.ChildNodes.Count == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> -1 * expresion(actual.ChildNodes.ElementAt(1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> Double.Parse(actual.ChildNodes.ElementAt(0).ToString().Split(<span class="string">&#x27; &#x27;</span>)[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Como en los casos anteriores, debemos plantear condiciones para determinar qué producción se está reconociendo, estas condiciones pueden basarse en la cantidad de hijos de la producción.</p>
<ul>
<li><p>Si tiene un hijo se trata de un número entero o decimal, por lo cual retornamos únicamente el valor del número.</p>
</li>
<li><p>Si tiene dos hijos es la producción de “menos &lt;expresión&gt;” por lo cual multiplicamos el valor de la expresión por menos uno.</p>
</li>
<li><p>Si tiene 3 hijos puede tratarse de una suma, resta, multiplicación o división, para determinar de cuál se trata, recogemos el valor del hijo de en medio que contiene el operador y ejecutamos según corresponda, esto se hace dentro de la sentencia switch del método.</p>
</li>
<li><p><strong>Interpretación del archivo de entrada</strong></p>
</li>
</ul>
<p>Esta interpretación se ejecuta dentro del método Main de la clase <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/Program.cs">“Program”</a> que se creo automáticamente en nuestro proyecto.</p>
<p>En esta clase se importa la referencia a la carpeta analizador para poder usar la clase Sintactico recién creada:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using ProyectoIronyCS.sol.com.analizador;</span><br></pre></td></tr></table></figure>

<p>Y en el método Main encontramos lo siguiente:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string text = System.IO.File.ReadAllText(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, @<span class="string">&quot;..\..\input&quot;</span>, <span class="string">&quot;entrada.txt&quot;</span>));</span><br><span class="line">Sintactico sintac = new Sintactico();</span><br><span class="line">sintac.analizar(text);</span><br></pre></td></tr></table></figure>

<p>Estos comandos realizan las siguientes acciones:</p>
<ol>
<li>Cargar el contenido del archivo <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/input/entrada.txt">“entrada.txt”</a> que debe ser creado dentro de la carpeta <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/tree/master/ProyectoIronyCS/input"><em>&#x2F;input</em></a> que también debemos crear dentro de nuestro proyecto.</li>
<li>Crear el analizador sintáctico a utilizar</li>
<li>Analizar el texto del archivo de entrada</li>
</ol>
<p>El archivo de <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoIronyCS/blob/master/ProyectoIronyCS/input/entrada.txt">“entrada.txt”</a> tiene el siguiente contenido:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[1+1];</span><br><span class="line">Evaluar[1+1*2];</span><br><span class="line">Evaluar[-(1+1*6/3-5+7)];</span><br><span class="line">Evaluar[-(1+1*6/3-5+1*-2)];</span><br><span class="line">Evaluar[-(1+1)];</span><br></pre></td></tr></table></figure>

<p>Y tras analizarlo con nuestra solución genera la siguiente salida:</p>


<p>Como podemos ver, obtenemos la salida esperada.</p>
<p>Y el AST que formaría dicha entrada sería:</p>


<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/201504481">Julio Arango</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-07-22T17:40:13.000Z" title="7/22/2019, 11:40:13 AM">2019-07-22</time></span><span class="level-item"> Erick Navarro </span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a><span> / </span><a class="link-muted" href="/categories/Computer-Science/Compilers/">Compilers</a></span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/22/18-Mi-Primer-Proyecto-Utilizando-GOLD-Parser-Windows/">Mi primer proyecto utilizando Gold Parser</a></p><div class="content"><p>Se desarrollará un intérprete que recibe como entrada varias expresiones aritméticas y presenta como salida el resultado de dichas expresiones evaluadas.</p>
<p>Las tecnologías a utilizar son:</p>
<ul>
<li><strong>Gold Parser Builder</strong>: Generador de analizadores léxicos y sintácticos diseñado para funcionar en múltiples lenguajes de programación.</li>
<li><strong>Visual Studio 2017</strong>: Entorno de desarrollo integrado para programar Visual Basic y C#, entre otros.</li>
<li><strong>Windows 10</strong>: Sistema operativo</li>
</ul>
<p>El proyecto completo puede descargarse del siguiente enlace:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoGoldParserVB">Mi primer proyecto utilizando Gold Parser</a></li>
</ul>
<h3 id="Gold-Parser"><a href="#Gold-Parser" class="headerlink" title="Gold Parser"></a><strong>Gold Parser</strong></h3><p><a target="_blank" rel="noopener" href="http://www.goldparser.org/">Gold Parser</a> es un generador de analizadores léxicos y sintácticos que soporta lenguajes tales como C#, COBOL, DELPHI, Visual Basic, Java entre otros. Este programa realiza de manera conjunta el análisis léxico y sintáctico, por lo que no tenemos la necesidad de recurrir a ningún programa externo.</p>
<p>La principal tarea de un analizador léxico es leer los caracteres de entrada del programa fuente, agruparlos en lexemas y producir como salida una secuencia de tokens.</p>
<ul>
<li><p>Un <em>token</em> es un par que consiste en un nombre de token y un valor de atributo opcional.</p>
</li>
<li><p>Un <em>lexema</em> es una secuencia de caracteres en el programa fuente, que coinciden con el patrón para un token y que el analizador léxico identifica como una instancia de este tóken.</p>
</li>
<li><p>Un <em>patrón</em> es una descripción de la forma que pueden tomar los lexemas de un token.</p>
</li>
</ul>
<p>El analizador sintáctico obtiene una cadena de tokens del analizador léxico y verifica que dicha cadena pueda generarse con la gramática para el lenguaje fuente. Una gramática proporciona una especificación precisa y fácil de entender de un lenguaje de programación.</p>
<h3 id="Pre-requisitos"><a href="#Pre-requisitos" class="headerlink" title="Pre-requisitos"></a><strong>Pre-requisitos</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.goldparser.org/builder/index.htm">Gold Parser Builder</a></li>
</ul>
<p>Este programa puede descargarse de la <a target="_blank" rel="noopener" href="http://www.goldparser.org/builder/index.htm">página oficial de Gold Parser</a></p>


<p>Descomprimimos el archivo ZIP descargado y ejecutamos el archivo setup.exe que encontraremos dentro de los files descomprimidos.</p>

<p>Esto nos desplegará el asistente de instalación, en la primera ventana no debemos de seleccionar nada, por lo que únicamente presionaremos el botón de siguiente.</p>

<p>Posteriormente, se nos preguntará en qué ruta deseamos instalar Gold Parser, en este caso dejaremos la ruta por defecto que es “C:\Program Files (x86)\Gold Parser Builder”, seleccionar si queremos instalarlo para todos los usuarios o solo para nosotros, en este caso seleccionaremos “Everyone” para que todos los usuarios puedan utilizarlo. Damos click en siguiente para continuar con la instalación.</p>


<p>Luego se nos mostrará una ventana que pide nuestra confirmación para continuar con la instalación de Gold Parser, hacemos click en siguiente.</p>


<p>Por último se nos mostrará la ventana de confirmación que indica que Gold Parser fue instalado correctamente.</p>


<h3 id="Generando-nuestro-analizador-lexico-y-sintactico-con-Gold-Parser"><a href="#Generando-nuestro-analizador-lexico-y-sintactico-con-Gold-Parser" class="headerlink" title="Generando nuestro analizador léxico y sintáctico con Gold Parser"></a><strong>Generando nuestro analizador léxico y sintáctico con Gold Parser</strong></h3><p>Hacemos clic en el botón de Windows y buscamos “gold parser builder”.</p>


<p>Ejecutamos la aplicación Gold Parser Builder y tendremos un ambiente de trabajo como el que se muestra a continuación.</p>


<p>Lo primero que debemos hacer para comenzar a trabajar con Gold Parser Builder es definir la gramática, el ejemplo que inspiró este tutorial fue realizado con Jlex y Cup:</p>
<ul>
<li><a href="/2019/04/26/02-Mi-primer-proyecto-utilizando-Jlex-y-Cup-Windows/" title="Mi primer proyecto utilizando Jlex y Cup (Windows)">Mi primer proyecto utilizando Jlex y Cup (Windows)</a></li>
</ul>
<p>La gramática planteada para Jlex y Cup era ambigua y dicha ambigüedad se resolvía indicando de forma explicita la precedencia de los operadores aritméticos:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">precedence left MAS,MENOS;</span><br><span class="line">precedence left POR,DIVIDIDO;</span><br><span class="line">precedence right UMENOS; </span><br></pre></td></tr></table></figure>

<p>Cup permite definir la precedencia y asociatividad de los operadores de forma explícita, en el caso de Gold Parser, esta opción no está disponible, por lo que es necesario utilizar una gramática no ambigua que respete la precedencia y asociatividad de los operadores.</p>
<p>Tomando en cuenta lo anterior, se propone la siguiente gramática escrita con la sintaxis propia de Gold Parser:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Name&quot;</span>    = <span class="string">&#x27;Mi Primer Proyecto en Gold Parser&#x27;</span></span><br><span class="line"><span class="string">&quot;Author&quot;</span>  = <span class="string">&#x27;Luis Lizama&#x27;</span></span><br><span class="line"><span class="string">&quot;Version&quot;</span> = <span class="string">&#x27;1.0&#x27;</span> </span><br><span class="line"><span class="string">&quot;About&quot;</span>   = <span class="string">&#x27;Ejemplo de una gramática simple que reconoce expresiones aritméticas&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Case Sensitive&quot;</span> = False </span><br><span class="line"><span class="string">&quot;Start Symbol&quot;</span>   = &lt;Statements&gt;</span><br><span class="line">    </span><br><span class="line">DECIMAL = &#123;Digit&#125;+<span class="string">&#x27;.&#x27;</span>&#123;Digit&#125;+</span><br><span class="line">ENTERO = &#123;Digit&#125;+</span><br><span class="line"></span><br><span class="line">&lt;Statements&gt; ::= &lt;Statement&gt; &lt;Statements&gt;</span><br><span class="line">               | &lt;Statement&gt;</span><br><span class="line"></span><br><span class="line">&lt;Statement&gt;  ::= Evaluar <span class="string">&#x27;[&#x27;</span> &lt;Expression&gt; <span class="string">&#x27;]&#x27;</span><span class="string">&#x27;;&#x27;</span></span><br><span class="line">               </span><br><span class="line">&lt;Expression&gt;   ::= &lt;Expression&gt; <span class="string">&#x27;+&#x27;</span> &lt;Mult Exp&gt; </span><br><span class="line">                 | &lt;Expression&gt; <span class="string">&#x27;-&#x27;</span> &lt;Mult Exp&gt; </span><br><span class="line">                 | &lt;Mult Exp&gt; </span><br><span class="line"></span><br><span class="line">&lt;Mult Exp&gt;    ::= &lt;Mult Exp&gt; <span class="string">&#x27;*&#x27;</span> &lt;Negate Exp&gt; </span><br><span class="line">                | &lt;Mult Exp&gt; <span class="string">&#x27;/&#x27;</span> &lt;Negate Exp&gt; </span><br><span class="line">                | &lt;Negate Exp&gt; </span><br><span class="line"></span><br><span class="line">&lt;Negate Exp&gt;  ::= <span class="string">&#x27;-&#x27;</span> &lt;Value&gt; </span><br><span class="line">                | &lt;Value&gt; </span><br><span class="line"></span><br><span class="line">&lt;Value&gt;       ::= ENTERO </span><br><span class="line">                | DECIMAL </span><br><span class="line">                | <span class="string">&#x27;(&#x27;</span> &lt;Expression&gt; <span class="string">&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Toda la documentación relacionada con la sintaxis de Gold Parser puede encontrarse en la <a target="_blank" rel="noopener" href="http://www.goldparser.org/">página oficial</a>.</p>
<p>Una vez tengamos lista nuestra gramática, la ingresamos en la ventana Grammar de la aplicación Gold Parser Builder (para esto basta con copiar y pegar la gramática mostrada anteriormente).</p>


<p>Luego procedemos a guardar la gramática seleccionando la opción “File” → “Save”, el archivo resultante tendrá extensión GRM, que es una extensión propia de Gold Parser.</p>


<p>El archivo GRM con la gramática utilizada para este ejemplo está disponible en la <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoGoldParserVB/tree/master/Gram%C3%A1tica">carpeta Gramática</a> del repositorio de este ejemplo.</p>
<p>Posteriormente seleccionamos la opción “Project” → “Analyze the Grammar”, esto analizará la gramática y nos mostrará los conflictos si existieran.</p>


<p>Debemos corregir todos los errores antes de continuar, para este ejemplo no había ninguno. Esto podemos confirmarlo en la parte inferior de nuestro editor de Gold Parser Builder.</p>


<p>Si existiesen errores o notificaciones se nos mostrarán en una ventana emergente de la siguiente manera:</p>


<p>En este caso no teníamos errores, así que podemos proseguir con la creación de las tablas para el análisis LALR. Esto lo hacemos seleccionando la opción “Project” → “Create LALR Parse Tables”</p>


<p>Podemos confirmar que nuestras tablas LALR fueron creadas exitosamente en la parte inferior de nuestro editor de Gold Parser Builder.</p>


<p>Durante la creación de las tablas LALR es posible de que se detecten conflictos de desplazamiento-reducción y el asistente no nos permita continuar, en este caso debemos resolver estos conflictos y luego continuar. Por el contrario, si no tenemos conflictos que resolver, podemos continuar al último paso, crear las tablas del autómata finito determinista que será el encargado de realizar el análisis léxico. Para ello seleccionamos la opción “Project” → “Create DFA Lexer Tables”.</p>


<p>Podemos confirmar que nuestras tablas para el autómata finito determinista fueron creadas exitosamente en la parte inferior de nuestro editor de Gold Parser Builder.</p>


<p>Por último, procedemos a guardar todas las tablas, estas serán importadas posteriormente en nuestro programa para poder realizar el análisis léxico y sintáctico del texto recibido como entrada. Para ello seleccionamos la opción “Project” → “Save the Tables”.</p>


<p>Se nos mostrará una ventana para que indiquemos la ruta en la cual deseamos almacenar las tablas, la seleccionamos y damos click en aceptar, con esto habremos generado un archivo EGT, esta ventana se cerrará y Gold Parser nos mostrará un mensaje diciendo que se guardaron las tablas correctamente.</p>


<p>EGT es una extensión propia de Gold parser.</p>


<p>El archivo EGT con las tablas generado para este ejemplo está disponible en la <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoGoldParserVB/tree/master/Gram%C3%A1tica">carpeta Gramática</a> del repositorio de este ejemplo.</p>
<p>Una de las principales ventajas de Gold Parser es que tiene un módulo de test que permite visualizar el proceso de análisis de una forma detallada. Para utilizar el módulo de test, hacemos click en el ícono correspondiente, que tiene un pequeño cheque verde.</p>


<p>O bien seleccionando la opción “Window” → “Test Grammar”</p>


<p>Esto nos desplegará una ventana de test en la que podemos ingresar en el lado izquiero una entrada y posteriormente evaluar paso a paso esta entrada con el botón verde de ejecutar que se encuentra en la parte inferior izquierda, esto nos permitirá ver el progreso del análisis en el panel derecho con el detalle de cada estado.</p>


<p>Luego de este pequeño paréntesis para explorar el módulo de test de Gold Parser continuaremos con nuestro proyecto. </p>
<p>El siguiente paso es crear el esqueleto de un programa, para ello seleccionamos “Project” → “Create a Skeleton Program…”. </p>


<p>Se nos desplegarán varias opciones para generar el esqueleto, para este ejemplo en específico utilizaremos Visual Basic .NET y como motor Cock .NET DLL.</p>


<p>Seleccionaremos la opción de crear y nos mostrará una ventana desde la cual podremos seleccionar la ruta en la cual queremos guardar el esqueleto de nuestro programa. Obtendremos como resultado un archivo con extensión VB.</p>


<p>El archivo VB generado con el esqueleto está disponible en la <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoGoldParserVB/tree/master/Gram%C3%A1tica">carpeta Gramática</a> del repositorio de este ejemplo.</p>
<p>Esto es todo lo que haremos en Gold Parser, de acá en adelante utilizaremos Visual Studio.</p>
<p>Abrimos Visual Studio.</p>


<p>Seleccionamos “File” → “New” → “Project”, una vez abierto el wizard para crear nuevos proyectos seleccionamos el apartado “Visual Basic” → “Windows Desktop” → “Console App (.NET Framework)” y le pondremos como nombre Calculadora.</p>


<p>Para poder utilizar el esqueleto que generamos en Gold Parser en el proyecto que acabamos de crear necesitaremos importar la librería .NET DLL que realiza el proceso de análisis, esta libería debe descargarse en la <a target="_blank" rel="noopener" href="http://goldparser.org/engine/5/net/index.htm">página oficial</a>. </p>


<p>Luego de descargar y descomprimir la librería obtendremos el archivo “Gold Engine.dll” que es el que debemos importar en nuestro proyecto.</p>


<p>Con el proyecto creado debemos de pegar el archivo de las tablas de análisis generadas en Gold Parser (Expresiones aritméticas.egt) y la librería que acabamos de descargar (GOLD Engine.dll) en la carpeta Calculadora&#x2F;Calculadora&#x2F;bin&#x2F;debug de nuestro proyecto. </p>


<p>También debemos de pegar el esqueleto que generamos con Gold Parser (Expresiones aritméticas.vb) en la carpeta principal de nuestro proyecto.</p>

<p>Regresamos a Visual Studio y desde el explorador de soluciones debemos de realizar dos procedimientos. </p>
<p>El primero es importar el archivo que contiene el esqueleto generado en Gold Parser (Expresiones aritméticas.vb), para ello hacemos click derecho sobre el nombre de nuestro proyecto “Add” → “Existing Item…”.</p>


<p>Luego seleccionamos el archivo de nuestro esqueleto.</p>


<p>Veremos que ahora aparece en el explorador de soluciones.</p>


<p>El segundo procedimiento a realizar en el explorador de soluciones es importar la librería que acabamos de pegar en nuestra carpeta debug, para hacerlo daremos click derecho en “References” → “Add Reference…”</p>


<p>Esto nos desplegara una nueva ventana, seleccionamos la opción “Browse…” y seleccionamos nuestro archivo .dll y daremos click en aceptar.</p>


<p>Por último, abrimos el archivo que contiene el esqueleto que generamos con Gold Parser (Expresiones aritméticas.vb) y dentro de las líneas de código buscar el método con el nombre Setup. Es la única instrucción que posee este método, debemos cambiar el nombre del archivo gramar.egt por el nombre de nuestro archivo de tablas (Expresiones aritméticas.egt), es de suma importancia que hayamos pegado nuestras tablas en la carpeta debug, de otra manera nuestro programa no las podrá encontrar y nos arrojará un error en tiempo de ejecución.</p>


<p>Estas son todas las configuraciones que debemos de realizar para poder utilizar Gold Parser, de acá en adelante, el tutorial se enfoca en explicar el funcionamiento de los archivos que se generaron anteriormente.</p>
<h3 id="Creando-un-archivo-de-entrada-para-nuestro-analizador"><a href="#Creando-un-archivo-de-entrada-para-nuestro-analizador" class="headerlink" title="Creando un archivo de entrada para nuestro analizador"></a><strong>Creando un archivo de entrada para nuestro analizador</strong></h3><p>Creamos un nuevo archivo de texto llamado entrada.txt. El contenido de este archivo es el siguiente:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Evaluar[<span class="number">1</span>+<span class="number">1</span>];</span><br><span class="line">Evaluar[<span class="number">1</span>+<span class="number">1</span>*<span class="number">2</span>];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>*<span class="number">6</span>/<span class="number">3</span>-<span class="number">5</span>+<span class="number">7</span>)];</span><br><span class="line">Evaluar[-(<span class="number">1</span>+<span class="number">1</span>*<span class="number">6</span>/<span class="number">3</span>-<span class="number">5</span>+<span class="number">1</span>*-<span class="number">2</span>)];</span><br><span class="line">Evaluar[-(<span class="number">1.6</span>+<span class="number">1.45</span>)];</span><br></pre></td></tr></table></figure>

<p>Este archivo de entrada será creado en la carpeta Calculadora&#x2F;Calculadora&#x2F;bin&#x2F;debug de nuestro proyecto. </p>


<h3 id="Utilizando-el-esqueleto-generado-con-Gold-Parser"><a href="#Utilizando-el-esqueleto-generado-con-Gold-Parser" class="headerlink" title="Utilizando el esqueleto generado con Gold Parser"></a><strong>Utilizando el esqueleto generado con Gold Parser</strong></h3><p>En los pasos anteriores nos enfocamos en la definición de la gramática y las configuraciones que tenemos que realizar para poder utilizar los archivos que generamos con Gold Parser, pero no hemos programado ningún tipo de instrucción dentro de nuestro programa. </p>
<p>Gold Parser se centra en generar un árbol de análisis sintáctico, de esta manera nosotros podremos recorrer este árbol como sea más conveniente, es por ello que no nos permite incrustar acciones semánticas al momento de definir la gramática, debemos de realizarlo directamente en el esqueleto generado, este esqueleto será modificado según convenaga para lograr nuestro objetivo.</p>
<p>El archivo VB generado con el esqueleto (Expresiones aritméticas.vb) modificado con las acciones necesarias para evaluar las expresiones aritméticas, además de estar en la <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoGoldParserVB/tree/master/Calculadora/Calculadora">carpeta principal del proyecto</a> dentro del repositorio, está disponible en la <a target="_blank" rel="noopener" href="https://github.com/ericknavarro/ProyectoGoldParserVB/tree/master/Gram%C3%A1tica">carpeta Gramática</a>.</p>
<p>Podremos notar que el esqueleto generado, en su método parse, posee una serie de estados los cuales por defecto tienen comentado su funcionamiento, los estados que alteraremos en este ejemplo son: </p>
<ul>
<li>LexicalError : Reportar errores léxicos.</li>
<li>SyntaxError : Reportar errores sintácticos.</li>
<li>Accept : Crear la raíz de nuestro árbol de análisis sintáctico.</li>
</ul>
<p>Definiremos una variable Root de tipo Gold.Reduction que será la raíz de nuestro árbol.</p>
<p>Adicionalmente, podremos notar que el archivo también posee una función denominada CreateNewObject que posee una serie de casos los cuales tienen comentado a que producción de la gramática pertenecen, es aquí donde debemos de introducir las acciones semánticas que deseamos que se ejecuten al momento de reducir por cada producción.</p>
<p>Esta función CreateNewObject viene definida únicamente como una plantilla, pero podremos darle la funcionalidad que nosotros deseemos. Para este ejemplo en específico se le cambió el nombre por “GetValue” ya que lo que necesitamos al final es obtener el valor resultante de evaluar cada expresión aritmética.</p>
<p>Los métodos de nuestro parser son estáticos y no es necesario crear una instancia parser, pero si es necesario ejecutar el método Setup para que cargue las tablas de análisis.</p>
<p>El programa por defecto está configurado para leer el archivo entrada.txt en la carpeta Calculadora&#x2F;Calculadora&#x2F;bin&#x2F;debug del proyecto.</p>
<p>A continuación se muestra el resultado de ejecutar el archivo de entrada que preparamos anteriormente.</p>


<p>Como podemos ver, obtenemos la salida esperada.</p>
<h3 id="Acerca-del-autor"><a href="#Acerca-del-autor" class="headerlink" title="Acerca del autor:"></a><strong>Acerca del autor:</strong></h3><p>Este tutorial fue elaborado por el Auxiliar de Cátedra <a target="_blank" rel="noopener" href="https://github.com/luisferliza">Luis Lizama</a>, como contribución al curso de Organización de Lenguajes y Compiladores 2 de la Universidad de San Carlos de Guatemala.</p>
<h3 id="Fuentes-consultadas"><a href="#Fuentes-consultadas" class="headerlink" title="Fuentes consultadas:"></a><strong>Fuentes consultadas:</strong></h3><p>Compiladores, principios, técnicas y herramientas. Aho, Lam, Sethi y Ullman. Segunda Edición.</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/Computer-Science/page/0/">Previous</a></div><div class="pagination-next"><a href="/categories/Computer-Science/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/Computer-Science/">1</a></li><li><a class="pagination-link" href="/categories/Computer-Science/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Erick Navarro"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Erick Navarro</p><p class="is-size-6 is-block">Data Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Guatemala</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.linkedin.com/in/ericknd/" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ericknavarro"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LinkedIn" href="https://www.linkedin.com/in/ericknd/"><i class="fab fa-linkedin"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AWS/"><span class="level-start"><span class="level-item">AWS</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/AWS/Alexa-Skills/"><span class="level-start"><span class="level-item">Alexa Skills</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/CloudFront/"><span class="level-start"><span class="level-item">CloudFront</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/EC2/"><span class="level-start"><span class="level-item">EC2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/Lambda/"><span class="level-start"><span class="level-item">Lambda</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/Route-53/"><span class="level-start"><span class="level-item">Route 53</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AWS/S3/"><span class="level-start"><span class="level-item">S3</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Computer-Science/"><span class="level-start"><span class="level-item">Computer Science</span></span><span class="level-end"><span class="level-item tag">19</span></span></a><ul><li><a class="level is-mobile" href="/categories/Computer-Science/Compilers/"><span class="level-start"><span class="level-item">Compilers</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Computer-Science/Data-Structures/"><span class="level-start"><span class="level-item">Data Structures</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Programming/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/2020/10/01/27-Mi-primer-proyecto-utilizando-Yacc-y-Lex/"><img src="/gallery/thumbnails/27.png" alt="Mi primer proyecto utilizando Yacc y Lex"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-10-01T21:03:28.000Z">2020-10-01</time></p><p class="title"><a href="/2020/10/01/27-Mi-primer-proyecto-utilizando-Yacc-y-Lex/">Mi primer proyecto utilizando Yacc y Lex</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/03/15/26-Interprete-sencillo-utilizando-PLY/"><img src="/gallery/thumbnails/26.png" alt="Intérprete sencillo utilizando PLY con Python 3"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-03-16T01:09:28.000Z">2020-03-15</time></p><p class="title"><a href="/2020/03/15/26-Interprete-sencillo-utilizando-PLY/">Intérprete sencillo utilizando PLY con Python 3</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/03/07/25-Interprete-sencillo-utilizando-Javacc/"><img src="/gallery/thumbnails/25.png" alt="Intérprete sencillo utilizando JavaCC"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-03-07T19:53:33.000Z">2020-03-07</time></p><p class="title"><a href="/2020/03/07/25-Interprete-sencillo-utilizando-Javacc/">Intérprete sencillo utilizando JavaCC</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/02/10/24-Mi-primer-proyecto-utilizando-PLY/"><img src="/gallery/thumbnails/24.png" alt="Mi primer proyecto utilizando PLY con Python 3"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-02-10T22:17:25.000Z">2020-02-10</time></p><p class="title"><a href="/2020/02/10/24-Mi-primer-proyecto-utilizando-PLY/">Mi primer proyecto utilizando PLY con Python 3</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/02/10/23-Mi-primer-proyecto-utilizando-JavaCC/"><img src="/gallery/thumbnails/23.png" alt="Mi primer proyecto utilizando JavaCC"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-02-10T22:14:34.000Z">2020-02-10</time></p><p class="title"><a href="/2020/02/10/23-Mi-primer-proyecto-utilizando-JavaCC/">Mi primer proyecto utilizando JavaCC</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a> / <a href="/categories/Computer-Science/Compilers/">Compilers</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">October 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">August 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">May 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">April 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Alexa-Skills/"><span class="tag">Alexa Skills</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C#</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CloudFront/"><span class="tag">CloudFront</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compilers/"><span class="tag">Compilers</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Data-Structures/"><span class="tag">Data Structures</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/EC2/"><span class="tag">EC2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lambda/"><span class="tag">Lambda</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Route-53/"><span class="tag">Route 53</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/S3/"><span class="tag">S3</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Visual-Basic/"><span class="tag">Visual Basic</span><span class="tag">4</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Erick Navarro" height="28"></a><p class="is-size-7"><span>&copy; 2025 Erick Navarro</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>